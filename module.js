;{try{let e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="1437f2f6-84db-407a-a260-961580278020",e._sentryDebugIdIdentifier="sentry-dbid-1437f2f6-84db-407a-a260-961580278020")}catch(e){}};{
    let _global =
      typeof window !== 'undefined' ?
        window :
        typeof global !== 'undefined' ?
          global :
          typeof globalThis !== 'undefined' ?
            globalThis :
            typeof self !== 'undefined' ?
              self :
              {};

    _global.SENTRY_RELEASE={id:"seasons-and-stars@0.7.0"};}

/**
 * Centralized logging system for Seasons & Stars module
 * Provides debug mode toggle and user-friendly error notifications
 */
/* eslint-disable no-console */
class Logger {
    /**
     * Log debug messages (only shown when debug mode is enabled)
     */
    static debug(message, data) {
        if (this.isDebugEnabled()) {
            console.log(`[S&S] ${message}`, data || '');
        }
    }
    /**
     * Log informational messages
     */
    static info(message, data) {
        console.log(`[S&S] ${message}`, data || '');
    }
    /**
     * Log warning messages
     */
    static warn(message, data) {
        console.warn(`[S&S WARNING] ${message}`, data || '');
        if (this.shouldShowUserNotifications()) {
            ui?.notifications?.warn(`Seasons & Stars: ${message}`);
        }
    }
    /**
     * Log error messages with user notification
     */
    static error(message, error) {
        console.error(`[S&S ERROR] ${message}`, error || '');
        if (this.shouldShowUserNotifications()) {
            ui?.notifications?.error(`Seasons & Stars: ${message}`);
        }
    }
    /**
     * Log critical errors that require immediate user attention
     */
    static critical(message, error) {
        console.error(`[S&S CRITICAL] ${message}`, error || '');
        // Always show critical errors regardless of settings
        ui?.notifications?.error(`Seasons & Stars: ${message}`);
    }
    /**
     * Check if debug mode is enabled
     */
    static isDebugEnabled() {
        try {
            return game.settings?.get(this.MODULE_ID, 'debugMode') === true;
        }
        catch {
            return false; // Fallback if settings not available
        }
    }
    /**
     * Check if user notifications should be shown
     */
    static shouldShowUserNotifications() {
        try {
            return game.settings?.get(this.MODULE_ID, 'showNotifications') !== false;
        }
        catch {
            return true; // Default to showing notifications
        }
    }
    /**
     * Performance timing utility
     */
    static time(label) {
        if (this.isDebugEnabled()) {
            console.time(`[S&S] ${label}`);
        }
    }
    /**
     * End performance timing
     */
    static timeEnd(label) {
        if (this.isDebugEnabled()) {
            console.timeEnd(`[S&S] ${label}`);
        }
    }
    /**
     * Log API calls for debugging integration issues
     */
    static api(method, params, result) {
        if (this.isDebugEnabled()) {
            console.group(`[S&S API] ${method}`);
            if (params)
                console.log('Parameters:', params);
            if (result !== undefined)
                console.log('Result:', result);
            console.groupEnd();
        }
    }
    /**
     * Log module integration events
     */
    static integration(event, data) {
        if (this.isDebugEnabled()) {
            console.log(`[S&S Integration] ${event}`, data || '');
        }
    }
}
Logger.MODULE_ID = 'seasons-and-stars';

/**
 * Application-wide constants for Seasons & Stars
 */
// Time-related constants
const TIME_CONSTANTS = {
    DEFAULT_DAWN_HOUR: 6,
    DEFAULT_DUSK_HOUR: 18,
};
// Widget positioning constants (consolidated from individual widgets)
const WIDGET_POSITIONING = {
    Z_INDEX: 101,
    ESTIMATED_MINI_HEIGHT: 80, // Fixed inconsistency - now matches general usage
    POSITIONING_RETRY_DELAY: 100,
    MAX_POSITIONING_ATTEMPTS: 10,
    FADE_ANIMATION_DURATION: 200,
    STANDALONE_BOTTOM_OFFSET: 150,
    VIEWPORT_PADDING: 10, // Minimum distance from viewport edges
    // Widget dimensions for consistency
    MINI_WIDGET_WIDTH: 200, // default min width; actual width is measured dynamically,
    MINI_WIDGET_HEIGHT: 80,
};
// UI constants for consistent styling
const UI_CONSTANTS = {
    DEFAULT_QUICK_TIME_BUTTONS: [-15, 15, 30, 60, 240],
};

/**
 * Calendar Time Utilities
 *
 * Utility functions for calendar-specific time calculations that replace
 * hardcoded assumptions throughout the codebase.
 *
 * Eliminates hardcoded values like:
 * - 86400 (seconds per day)
 * - 24 * 60 * 60 (seconds per day)
 * - 365 (days per year)
 * - 12 (months per year)
 * - 7 (days per week)
 *
 * These functions work with any calendar system by using the calendar's
 * actual time configuration instead of Earth-based assumptions.
 */
class CalendarTimeUtils {
    /**
     * Get seconds per day for a calendar
     * Replaces hardcoded 86400 or 24 * 60 * 60
     */
    static getSecondsPerDay(calendar) {
        return calendar.time.hoursInDay * calendar.time.minutesInHour * calendar.time.secondsInMinute;
    }
    /**
     * Get seconds per hour for a calendar
     * Replaces hardcoded 3600 or 60 * 60
     */
    static getSecondsPerHour(calendar) {
        return calendar.time.minutesInHour * calendar.time.secondsInMinute;
    }
    /**
     * Get days per week for a calendar
     * Replaces hardcoded 7
     */
    static getDaysPerWeek(calendar) {
        return calendar.weekdays.length;
    }
    /**
     * Get months per year for a calendar
     * Replaces hardcoded 12
     */
    static getMonthsPerYear(calendar) {
        return calendar.months.length;
    }
    /**
     * Convert days to seconds using calendar-specific day length
     * Replaces hardcoded days * 86400
     */
    static daysToSeconds(days, calendar) {
        return days * this.getSecondsPerDay(calendar);
    }
    /**
     * Convert weeks to days using calendar-specific week length
     * Replaces hardcoded weeks * 7
     */
    static weeksToDays(weeks, calendar) {
        return weeks * this.getDaysPerWeek(calendar);
    }
    /**
     * Convert hours to seconds using calendar-specific hour length
     * Replaces hardcoded hours * 3600
     */
    static hoursToSeconds(hours, calendar) {
        return hours * this.getSecondsPerHour(calendar);
    }
    /**
     * Convert weeks to seconds using calendar-specific time units
     * Combines week length and day length calculations
     */
    static weeksToSeconds(weeks, calendar) {
        const days = this.weeksToDays(weeks, calendar);
        return this.daysToSeconds(days, calendar);
    }
    /**
     * Convert seconds to world time components (days, hours, minutes, seconds)
     * Uses calendar-specific time units for accurate breakdown
     */
    static secondsToWorldTimeUnits(totalSeconds, calendar) {
        const secondsPerDay = this.getSecondsPerDay(calendar);
        const secondsPerHour = this.getSecondsPerHour(calendar);
        const secondsPerMinute = calendar.time.secondsInMinute;
        const days = Math.floor(totalSeconds / secondsPerDay);
        let remainingSeconds = totalSeconds % secondsPerDay;
        const hours = Math.floor(remainingSeconds / secondsPerHour);
        remainingSeconds = remainingSeconds % secondsPerHour;
        const minutes = Math.floor(remainingSeconds / secondsPerMinute);
        const seconds = remainingSeconds % secondsPerMinute;
        return { days, hours, minutes, seconds };
    }
    // === DATE COMPARISON UTILITIES ===
    /**
     * Compare two dates chronologically
     * Returns: -1 if dateA < dateB, 0 if equal, 1 if dateA > dateB
     * Replaces repeated date comparison patterns throughout codebase
     */
    static compareDates(dateA, dateB) {
        if (dateA.year !== dateB.year)
            return dateA.year - dateB.year;
        if (dateA.month !== dateB.month)
            return dateA.month - dateB.month;
        return dateA.day - dateB.day;
    }
    /**
     * Check if two dates are equal (ignores weekday and time)
     * Replaces repeated date equality checks
     */
    static isDateEqual(dateA, dateB) {
        return this.compareDates(dateA, dateB) === 0;
    }
    /**
     * Check if dateA is before dateB chronologically
     * Replaces repeated date ordering checks
     */
    static isDateBefore(dateA, dateB) {
        return this.compareDates(dateA, dateB) < 0;
    }
    /**
     * Check if dateA is after dateB chronologically
     * Replaces repeated date ordering checks
     */
    static isDateAfter(dateA, dateB) {
        return this.compareDates(dateA, dateB) > 0;
    }
    // === DATE ARITHMETIC UTILITIES ===
    /**
     * Normalize month values with year overflow/underflow handling
     * Replaces repeated month normalization patterns
     */
    static normalizeMonth(month, year, calendar) {
        const monthsPerYear = this.getMonthsPerYear(calendar);
        let normalizedMonth = month;
        let normalizedYear = year;
        // Handle month overflow
        while (normalizedMonth > monthsPerYear) {
            normalizedMonth -= monthsPerYear;
            normalizedYear++;
        }
        // Handle month underflow
        while (normalizedMonth < 1) {
            normalizedMonth += monthsPerYear;
            normalizedYear--;
        }
        return { month: normalizedMonth, year: normalizedYear };
    }
    /**
     * Add months to a date with proper year overflow and day clamping
     * Replaces repeated month arithmetic patterns
     */
    static addMonthsToDate(date, months, calendar) {
        // Calculate new month and year
        const { month: newMonth, year: newYear } = this.normalizeMonth(date.month + months, date.year, calendar);
        // Handle day overflow (e.g., Jan 31 + 1 month = Feb 28/29)
        const maxDayInNewMonth = calendar.months[newMonth - 1]?.days || 30; // Fallback to 30
        const clampedDay = Math.min(date.day, maxDayInNewMonth);
        return {
            year: newYear,
            month: newMonth,
            day: clampedDay,
            weekday: date.weekday, // Preserve weekday (would need calendar engine for accurate calculation)
            time: date.time,
        };
    }
    /**
     * Normalize weekday values using calendar-specific week length
     * Replaces repeated weekday normalization patterns
     */
    static normalizeWeekday(weekday, calendar) {
        const weekLength = this.getDaysPerWeek(calendar);
        let normalized = weekday % weekLength;
        // Handle negative weekdays
        if (normalized < 0) {
            normalized += weekLength;
        }
        return normalized;
    }
    // === FORMATTING UTILITIES ===
    /**
     * Add ordinal suffix to numbers (1st, 2nd, 3rd, 4th, etc.)
     * Replaces repeated ordinal formatting patterns
     */
    static addOrdinalSuffix(num) {
        const lastDigit = num % 10;
        const lastTwoDigits = num % 100;
        // Special cases for 11th, 12th, 13th (always 'th')
        if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
            return `${num}th`;
        }
        // Regular ordinal rules
        switch (lastDigit) {
            case 1:
                return `${num}st`;
            case 2:
                return `${num}nd`;
            case 3:
                return `${num}rd`;
            default:
                return `${num}th`;
        }
    }
    /**
     * Format time component with zero-padding
     * Replaces repeated time formatting patterns
     */
    static formatTimeComponent(value, padLength = 2) {
        return value.toString().padStart(padLength, '0');
    }
    // === CALENDAR-SPECIFIC YEAR OPERATIONS ===
    /**
     * Calculate approximate year length by summing month days
     * Replaces hardcoded 365 day assumptions
     */
    static getApproximateYearLength(calendar) {
        return calendar.months.reduce((sum, month) => sum + month.days, 0);
    }
}

/**
 * Date Formatter - Handlebars-based date formatting for Seasons & Stars
 */
class DateFormatter {
    constructor(calendar) {
        /**
         * Template compilation cache - intentionally unlimited size
         *
         * ARCHITECTURAL DECISION: No runtime cache size limits by design
         *
         * Memory Management Strategy:
         * - Input validation enforces maximum 100 date formats per calendar (see calendar validation)
         * - Realistic usage: 10-25 formats typical, 100 is generous upper bound
         * - Memory math: 100 templates × ~2KB each = ~200KB maximum per calendar instance
         * - Foundry context: Game assets (maps, tokens, audio) use 100-1000× more memory
         * - Session lifecycle: Browser refresh every 2-4 hours naturally clears cache
         *
         * Alternative Approaches Considered & Rejected:
         * - LRU cache with size limits: 65+ lines of complexity for theoretical problem
         * - Periodic cleanup: Unnecessary overhead when input validation prevents the issue
         * - WeakMap: Cannot iterate or debug, provides no practical benefit
         *
         * Performance Characteristics:
         * - Cache hits: O(1) Map lookup (2-3 microseconds)
         * - Template compilation: O(n) in template complexity (10-50 milliseconds)
         * - Memory usage: Linear with unique templates, bounded by validation
         *
         * When This Design Should Be Reconsidered:
         * - Calendar validation allows >1000 formats per calendar
         * - Template compilation becomes a performance bottleneck
         * - Memory constraints become critical (embedded/mobile Foundry)
         * - Dynamic template generation outside calendar definitions
         *
         * For Future Reviewers:
         * This unlimited cache is not an oversight or technical debt. It's a conscious
         * architectural choice based on realistic usage patterns and proper input validation.
         * The alternative (runtime size limits) adds complexity without meaningful benefit
         * given the constraints of the Foundry VTT environment and calendar use cases.
         */
        this.templateCache = new Map();
        this.calendar = calendar;
        // Register this instance for helper access
        DateFormatter.helperRegistry.set(calendar.id, this);
        // Only register helpers once globally to avoid unnecessary re-registration
        if (!DateFormatter.helpersRegistered) {
            this.registerCustomHelpers();
            DateFormatter.helpersRegistered = true;
        }
    }
    /**
     * Reset helper registration state (for testing purposes)
     * @internal
     */
    static resetHelpersForTesting() {
        DateFormatter.helpersRegistered = false;
        DateFormatter.notifiedErrors.clear();
        DateFormatter.helperRegistry.clear();
    }
    /**
     * Handle template compilation errors with appropriate user feedback
     */
    notifyTemplateError(template, error, formatName) {
        // Create error key for throttling
        const errorKey = `${this.calendar.id}:${formatName || 'template'}:${error.message}`;
        // Don't spam the same error repeatedly
        if (DateFormatter.notifiedErrors.has(errorKey)) {
            return;
        }
        DateFormatter.notifiedErrors.add(errorKey);
        // Check if debug mode is enabled (use debug setting instead of NODE_ENV)
        const isDebugEnabled = typeof game !== 'undefined' && game.settings?.get('seasons-and-stars', 'debugMode') === true;
        if (isDebugEnabled) {
            // Debug mode: Show UI notifications with detailed information
            if (typeof ui !== 'undefined' && ui.notifications) {
                if (formatName && this.calendar.id) {
                    // Calendar-specific format error
                    const calendarName = this.calendar.name || this.calendar.id;
                    ui.notifications.warn(`Calendar "${calendarName}" has syntax errors in "${formatName}" format: ${error.message}`);
                }
                else {
                    // Generic template error
                    ui.notifications.warn(`Date format template has syntax errors: ${error.message}`);
                }
                // Provide helpful hints for common errors (debug mode only)
                if (error.message.includes('quote')) {
                    ui.notifications.warn('Hint: Use double quotes in format helpers, e.g., {{ss-hour format="pad"}} not {{ss-hour format=\'pad\'}}');
                }
            }
        }
        else {
            // Production mode: Only log to console (no UI notifications)
            if (formatName && this.calendar.id) {
                // Calendar-specific format error
                const calendarName = this.calendar.name || this.calendar.id;
                console.warn(`[S&S] Calendar "${calendarName}" has syntax errors in "${formatName}" format: ${error.message}`);
            }
            else {
                // Generic template error
                console.warn(`[S&S] Date format template has syntax errors: ${error.message}`);
            }
        }
    }
    /**
     * Format a date using a Handlebars template string
     */
    format(date, template) {
        return this.formatWithContext(date, template);
    }
    /**
     * Compile and cache a template, or retrieve from cache
     */
    compileAndCacheTemplate(processedTemplate) {
        let compiledTemplate = this.templateCache.get(processedTemplate);
        if (!compiledTemplate) {
            // Use Foundry's global Handlebars to compile template
            compiledTemplate = Handlebars.compile(processedTemplate);
            this.templateCache.set(processedTemplate, compiledTemplate);
        }
        return compiledTemplate;
    }
    /**
     * Format a date using a Handlebars template string with error context
     */
    formatWithContext(date, template, formatName, visited = new Set()) {
        // Type safety check at entry point
        if (typeof template !== 'string') {
            console.debug('[S&S] Invalid template type passed to format(), falling back to basic format');
            return this.getBasicFormat(date);
        }
        try {
            // Use consolidated template caching
            const compiledTemplate = this.compileAndCacheTemplate(template);
            // Prepare context data for template with visited formats for circular reference detection
            const context = this.prepareTemplateContext(date, visited);
            // Execute template with context
            const result = compiledTemplate(context);
            // Validate template output - detect malformed templates that produce empty/invalid output
            if (this.isInvalidTemplateOutput(result, template)) {
                return this.getBasicFormat(date);
            }
            return result;
        }
        catch (error) {
            console.debug('[S&S] Date format template compilation failed:', error);
            // Notify user about the error
            this.notifyTemplateError(template, error instanceof Error ? error : new Error(String(error)), formatName);
            // Fallback to basic format
            return this.getBasicFormat(date);
        }
    }
    /**
     * Format a date using a named format from calendar dateFormats
     *
     * Automatically selects intercalary-specific format variants for intercalary dates:
     * - For intercalary dates, tries `${formatName}-intercalary` first
     * - Falls back to regular `${formatName}` if intercalary variant doesn't exist
     * - Regular dates always use the standard format
     *
     * @example
     * ```typescript
     * // Calendar dateFormats:
     * {
     *   "short": "{{day}} {{month}} {{year}}",
     *   "short-intercalary": "{{intercalary}}, {{year}}"
     * }
     *
     * // Regular date (15th of January)
     * formatter.formatNamed(regularDate, 'short')
     * // Returns: "15 January 2024"
     *
     * // Intercalary date (Midwinter Festival)
     * formatter.formatNamed(intercalaryDate, 'short')
     * // Returns: "Midwinter Festival, 2024" (uses short-intercalary)
     * ```
     */
    formatNamed(date, formatName, variant, visited = new Set()) {
        // Input validation
        if (!formatName) {
            return this.getBasicFormat(date);
        }
        // Prevent circular references - check before adding to visited
        if (visited.has(formatName)) {
            console.debug(`[S&S] Circular reference detected in format '${formatName}'`);
            return this.getBasicFormat(date);
        }
        const dateFormats = this.calendar.dateFormats;
        if (!dateFormats) {
            return this.getBasicFormat(date);
        }
        // Check for intercalary-specific format first if this is an intercalary date
        // Note: Empty string is still considered intercalary, null/undefined is not
        if (date.intercalary !== null && date.intercalary !== undefined) {
            const intercalaryFormatName = `${formatName}-intercalary`;
            // Avoid infinite recursion when an intercalary format references its base format
            if (!visited.has(intercalaryFormatName)) {
                const intercalaryFormat = dateFormats[intercalaryFormatName];
                if (intercalaryFormat) {
                    // Handle intercalary format variants (format as object)
                    if (typeof intercalaryFormat === 'object' && !Array.isArray(intercalaryFormat)) {
                        if (variant && intercalaryFormat[variant]) {
                            const formatString = intercalaryFormat[variant];
                            const formatDisplayName = `${intercalaryFormatName}:${variant}`;
                            const newVisited = new Set(visited);
                            newVisited.add(intercalaryFormatName);
                            return this.formatWithContext(date, formatString, formatDisplayName, newVisited);
                        }
                        else {
                            // Try 'default' or first available for intercalary format
                            const defaultFormat = intercalaryFormat.default || Object.values(intercalaryFormat)[0];
                            if (defaultFormat) {
                                const newVisited = new Set(visited);
                                newVisited.add(intercalaryFormatName);
                                return this.formatWithContext(date, defaultFormat, intercalaryFormatName, newVisited);
                            }
                        }
                    }
                    else if (typeof intercalaryFormat === 'string') {
                        // Simple string intercalary format
                        const newVisited = new Set(visited);
                        newVisited.add(intercalaryFormatName);
                        return this.formatWithContext(date, intercalaryFormat, intercalaryFormatName, newVisited);
                    }
                }
            }
        }
        // Fall back to regular format lookup if no intercalary format found
        const format = dateFormats[formatName];
        if (!format) {
            return this.getBasicFormat(date);
        }
        // Get the actual format string to process
        let formatString;
        let formatDisplayName;
        // Handle format variants (format as object)
        if (typeof format === 'object' && !Array.isArray(format)) {
            if (variant && format[variant]) {
                formatString = format[variant];
                formatDisplayName = `${formatName}:${variant}`;
            }
            else {
                // If no variant specified, try 'default' or first available
                const defaultFormat = format.default || Object.values(format)[0];
                if (defaultFormat) {
                    formatString = defaultFormat;
                    formatDisplayName = formatName;
                }
                else {
                    return this.getBasicFormat(date);
                }
            }
        }
        else if (typeof format === 'string') {
            formatString = format;
            formatDisplayName = formatName;
        }
        else {
            return this.getBasicFormat(date);
        }
        // Add current format to visited set before processing template to prevent circular references
        const newVisited = new Set(visited);
        newVisited.add(formatName);
        // Process the format with updated visited set
        return this.formatWithContext(date, formatString, formatDisplayName, newVisited);
    }
    /**
     * Format a date using widget-specific format from calendar dateFormats
     *
     * Automatically selects intercalary-specific widget format variants for intercalary dates:
     * - For intercalary dates, tries `${widgetType}-intercalary` first
     * - Falls back to regular `${widgetType}` if intercalary variant doesn't exist
     * - Regular dates always use the standard widget format
     *
     * @example
     * ```typescript
     * // Calendar dateFormats.widgets:
     * {
     *   "mini": "{{day}} {{month abbr}}",
     *   "mini-intercalary": "{{intercalary}}"
     * }
     *
     * // Regular date (15th of January)
     * formatter.formatWidget(regularDate, 'mini')
     * // Returns: "15 Jan"
     *
     * // Intercalary date (Midwinter Festival)
     * formatter.formatWidget(intercalaryDate, 'mini')
     * // Returns: "Midwinter Festival" (uses mini-intercalary)
     * ```
     */
    formatWidget(date, widgetType) {
        const dateFormats = this.calendar.dateFormats;
        if (!dateFormats?.widgets) {
            return this.getBasicFormat(date);
        }
        // Check for intercalary-specific widget format first if this is an intercalary date
        // Note: Empty string is still considered intercalary, null/undefined is not
        if (date.intercalary !== null && date.intercalary !== undefined) {
            const intercalaryWidgetType = `${widgetType}-intercalary`;
            const intercalaryWidgetFormat = dateFormats.widgets[intercalaryWidgetType];
            if (intercalaryWidgetFormat) {
                return this.formatWithContext(date, intercalaryWidgetFormat, `widgets.${intercalaryWidgetType}`);
            }
        }
        // Fall back to regular widget format if no intercalary format found
        const widgetFormat = dateFormats.widgets[widgetType];
        if (!widgetFormat) {
            return this.getBasicFormat(date);
        }
        return this.formatWithContext(date, widgetFormat, `widgets.${widgetType}`);
    }
    /**
     * Format named with circular reference protection
     */
    formatNamedRecursive(date, formatName, visited) {
        // Use the consolidated formatNamed method which handles circular reference detection
        return this.formatNamed(date, formatName, undefined, visited);
    }
    /**
     * Prepare template context with date data
     */
    prepareTemplateContext(date, visited) {
        return {
            year: date.year,
            month: date.month,
            day: date.day,
            weekday: date.weekday,
            hour: date.time?.hour,
            minute: date.time?.minute,
            second: date.time?.second,
            dayOfYear: this.calculateDayOfYear(date),
            _calendarId: this.calendar.id, // Add calendar ID to context for helper access
            _visitedFormats: visited || new Set(), // Add visited formats for circular reference detection
        };
    }
    /**
     * Calculate day of year for stardate and other calculations
     */
    calculateDayOfYear(date) {
        // Bounds checking for month value - only warn for severely out-of-range values
        // Built-in calendars (like Traveller Imperial with 1 month) should not trigger warnings
        if (date.month < 1 ||
            (this.calendar.months.length > 0 && date.month > this.calendar.months.length)) {
            // Only log as debug for legitimate edge cases, no user-visible warnings
            console.debug(`[S&S] Month value ${date.month} outside calendar range (1-${this.calendar.months.length}), using start of year fallback`);
            // Return 1 to indicate start of year, which is more meaningful than raw day value
            // This prevents confusing calculations in stardate helpers and other features
            return 1;
        }
        let dayOfYear = 0;
        // Add days from completed months
        for (let i = 0; i < date.month - 1; i++) {
            const month = this.calendar.months[i];
            if (month) {
                dayOfYear += month.days;
            }
        }
        // Add current day
        dayOfYear += date.day;
        return dayOfYear;
    }
    /**
     * Fallback basic format when template compilation fails
     */
    getBasicFormat(date) {
        // Handle intercalary days first - they should display the intercalary name, not regular date format
        // Note: Empty string is still considered intercalary, null/undefined is not
        if (date.intercalary !== null && date.intercalary !== undefined) {
            return date.intercalary;
        }
        // For regular dates, use the standard format
        const monthName = this.getMonthName(date.month);
        const weekdayName = this.getWeekdayName(date.weekday);
        const dayOrdinal = this.addOrdinalSuffix(date.day);
        const yearString = `${this.calendar.year?.prefix || ''}${date.year}${this.calendar.year?.suffix || ''}`.trim();
        return `${weekdayName}, ${dayOrdinal} ${monthName} ${yearString}`;
    }
    /**
     * Register custom Handlebars helpers for date formatting
     */
    registerCustomHelpers() {
        // Day helper - supports ordinal and pad formats
        Handlebars.registerHelper('ss-day', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let dayValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.day;
            // Handle undefined/null values gracefully
            if (dayValue === undefined || dayValue === null) {
                dayValue = 1;
            }
            const format = options?.hash?.format;
            switch (format) {
                case 'ordinal':
                    return DateFormatter.addOrdinalSuffix(dayValue);
                case 'pad':
                    return dayValue.toString().padStart(2, '0');
                default:
                    return dayValue.toString();
            }
        });
        // Month helper - supports name, abbr, and pad formats
        Handlebars.registerHelper('ss-month', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let monthValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.month;
            // Handle undefined/null values gracefully
            if (monthValue === undefined || monthValue === null) {
                monthValue = 1;
            }
            const format = options?.hash?.format;
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            switch (format) {
                case 'name':
                    if (formatter) {
                        return formatter.getMonthName(monthValue);
                    }
                    else {
                        // Fallback to standard month names
                        const fallbackMonth = DateFormatter.fallbackMonths[monthValue - 1];
                        return fallbackMonth ? fallbackMonth.name : `Month ${monthValue}`;
                    }
                case 'abbr':
                    if (formatter) {
                        return formatter.getMonthAbbreviation(monthValue);
                    }
                    else {
                        // Fallback to standard month abbreviations
                        const fallbackMonth = DateFormatter.fallbackMonths[monthValue - 1];
                        return fallbackMonth ? fallbackMonth.abbreviation : `M${monthValue}`;
                    }
                case 'pad':
                    return monthValue.toString().padStart(2, '0');
                default:
                    return monthValue.toString();
            }
        });
        // Weekday helper - supports name and abbr formats
        Handlebars.registerHelper('ss-weekday', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let weekdayValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.weekday;
            // Handle undefined/null values gracefully
            if (weekdayValue === undefined || weekdayValue === null) {
                weekdayValue = 0;
            }
            const format = options?.hash?.format;
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            switch (format) {
                case 'name':
                    if (formatter) {
                        return formatter.getWeekdayName(weekdayValue);
                    }
                    else {
                        // Fallback to standard weekday names
                        const fallbackWeekday = DateFormatter.fallbackWeekdays[weekdayValue];
                        return fallbackWeekday ? fallbackWeekday.name : `Day ${weekdayValue}`;
                    }
                case 'abbr':
                    if (formatter) {
                        return formatter.getWeekdayAbbreviation(weekdayValue);
                    }
                    else {
                        // Fallback to standard weekday abbreviations
                        const fallbackWeekday = DateFormatter.fallbackWeekdays[weekdayValue];
                        return fallbackWeekday ? fallbackWeekday.abbreviation : `D${weekdayValue}`;
                    }
                default:
                    return weekdayValue.toString();
            }
        });
        // Format embedding helper - use "{{ss-dateFmt \"name\"}}" syntax
        // Note: This helper is mainly for documentation. The actual format embedding
        // is handled by preprocessing in the format() method to avoid circular issues.
        Handlebars.registerHelper('ss-dateFmt', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // Get format name from first argument
            const formatName = args.length > 1 ? args[0] : null;
            if (!formatName) {
                return '[ss-dateFmt: No format name provided]';
            }
            // Get the calendar ID and formatter from context
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            if (!formatter) {
                return `[ss-dateFmt: No formatter available for ${formatName}]`;
            }
            // Get current date context
            const context = options?.data?.root;
            const dateData = {
                year: context?.year || 2024,
                month: context?.month || 1,
                day: context?.day || 1,
                weekday: context?.weekday || 0,
                intercalary: context?.intercalary,
                time: context?.time,
            };
            // Check if the format exists - if not, fall back to basic format like the old system
            if (!formatter.calendar.dateFormats || !formatter.calendar.dateFormats[formatName]) {
                return formatter.getBasicFormat(dateData);
            }
            // Check for circular references
            const visited = context?._visitedFormats || new Set();
            if (visited.has(formatName)) {
                return formatter.getBasicFormat(dateData);
            }
            // Pass the current visited set to formatNamed, which will handle adding
            // the current format to visited when processing its template content
            try {
                // Create a CalendarDate object for the formatNamed call
                const calendarDate = new CalendarDate(dateData, formatter.calendar);
                return formatter.formatNamed(calendarDate, formatName, undefined, visited);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                return `[ss-dateFmt: Error formatting '${formatName}': ${errorMessage}]`;
            }
        });
        // Mathematical operations helper
        Handlebars.registerHelper('ss-math', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise try from context
            const value = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.value;
            const operation = options?.hash?.op;
            const operand = options?.hash?.value;
            if (typeof operand !== 'number') {
                return value;
            }
            switch (operation) {
                case 'add':
                    return value + operand;
                case 'subtract':
                    return value - operand;
                case 'multiply':
                    return value * operand;
                case 'divide':
                    return operand !== 0 ? value / operand : value;
                case 'modulo':
                    return operand !== 0 ? value % operand : value;
                default:
                    return value;
            }
        });
        // Hour helper - supports pad format
        Handlebars.registerHelper('ss-hour', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let hourValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.hour;
            // Handle undefined/null values gracefully - default to 0 for proper time formatting
            if (hourValue === undefined || hourValue === null) {
                hourValue = 0;
            }
            const format = options?.hash?.format;
            switch (format) {
                case 'pad':
                    return hourValue.toString().padStart(2, '0');
                default:
                    return hourValue.toString();
            }
        });
        // Minute helper - supports pad format
        Handlebars.registerHelper('ss-minute', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let minuteValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.minute;
            // Handle undefined/null values gracefully - default to 0 for proper time formatting
            if (minuteValue === undefined || minuteValue === null) {
                minuteValue = 0;
            }
            const format = options?.hash?.format;
            switch (format) {
                case 'pad':
                    return minuteValue.toString().padStart(2, '0');
                default:
                    return minuteValue.toString();
            }
        });
        // Second helper - supports pad format
        Handlebars.registerHelper('ss-second', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If value is provided as first argument (and not undefined/null), use it; otherwise use context
            let secondValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.second;
            // Handle undefined/null values gracefully - default to 0 for proper time formatting
            if (secondValue === undefined || secondValue === null) {
                secondValue = 0;
            }
            const format = options?.hash?.format;
            switch (format) {
                case 'pad':
                    return secondValue.toString().padStart(2, '0');
                default:
                    return secondValue.toString();
            }
        });
        // Week helper - supports calculating week within month for Roshar-style calendars
        Handlebars.registerHelper('ss-week', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If day is provided as first argument (and not undefined/null), use it; otherwise use context
            let dayValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.day;
            // Handle undefined/null values gracefully
            if (dayValue === undefined || dayValue === null) {
                dayValue = 1;
            }
            const format = options?.hash?.format;
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            // Get daysPerWeek from calendar weekdays array, with fallback to 7
            let daysPerWeek = 7;
            if (formatter && formatter.calendar.weekdays) {
                daysPerWeek = formatter.calendar.weekdays.length;
            }
            // Allow override via hash options for special cases
            if (options?.hash?.daysPerWeek) {
                daysPerWeek = options.hash.daysPerWeek;
            }
            // Calculate week within month (1-based)
            const weekValue = Math.ceil(dayValue / daysPerWeek);
            switch (format) {
                case 'pad':
                    return weekValue.toString().padStart(2, '0');
                case 'ordinal':
                    return DateFormatter.addOrdinalSuffix(weekValue);
                default:
                    return weekValue.toString();
            }
        });
        // Day-in-week helper - calculates which day of the week (1-based)
        Handlebars.registerHelper('ss-day-in-week', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If day is provided as first argument (and not undefined/null), use it; otherwise use context
            let dayValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.day;
            // Handle undefined/null values gracefully
            if (dayValue === undefined || dayValue === null) {
                dayValue = 1;
            }
            const format = options?.hash?.format;
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            // Get daysPerWeek from calendar weekdays array, with fallback to 7
            let daysPerWeek = 7;
            if (formatter && formatter.calendar.weekdays) {
                daysPerWeek = formatter.calendar.weekdays.length;
            }
            // Allow override via hash options for special cases
            if (options?.hash?.daysPerWeek) {
                daysPerWeek = options.hash.daysPerWeek;
            }
            // Calculate day within week (1-based): ((day - 1) % daysPerWeek) + 1
            const dayInWeekValue = ((dayValue - 1) % daysPerWeek) + 1;
            switch (format) {
                case 'pad':
                    return dayInWeekValue.toString().padStart(2, '0');
                default:
                    return dayInWeekValue.toString();
            }
        });
        // Stardate calculation helper for sci-fi calendars
        Handlebars.registerHelper('ss-stardate', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // If year is provided as first argument (and not undefined/null), use it; otherwise use context
            let yearValue = args.length > 1 && args[0] !== undefined && args[0] !== null
                ? args[0]
                : options?.data?.root?.year;
            // Handle undefined/null values gracefully
            if (yearValue === undefined || yearValue === null) {
                yearValue = 2000; // Default fallback year
            }
            const prefix = options?.hash?.prefix || '0';
            const baseYear = options?.hash?.baseYear || yearValue;
            const dayOfYear = options?.hash?.dayOfYear || 1;
            const precision = options?.hash?.precision || 1;
            // Calculate stardate: prefix + (year - baseYear) + dayOfYear
            // Format: XXYYYY.P where XX is era prefix, YYYY is year offset + day, P is precision
            const yearOffset = yearValue - baseYear;
            const stardatePrefix = parseInt(prefix) + yearOffset;
            const paddedDayOfYear = dayOfYear.toString().padStart(3, '0');
            return `${stardatePrefix}${paddedDayOfYear}.${precision > 0 ? '0'.repeat(precision) : ''}`.replace(/\.$/, '.0');
        });
        // Time display helper - supports canonical hours with exact time fallback
        Handlebars.registerHelper('ss-time-display', function (...args) {
            // Handlebars passes options as the last argument
            const options = args[args.length - 1];
            // Get the calendar ID and formatter from context
            const calendarId = options?.data?.root?._calendarId;
            const formatter = calendarId ? DateFormatter.helperRegistry.get(calendarId) : null;
            if (!formatter) {
                return '[ss-time-display: No formatter available]';
            }
            // Get current time context
            const context = options?.data?.root;
            const hour = context?.hour ?? 0;
            const minute = context?.minute ?? 0;
            // Get display mode from options or default to auto
            const mode = options?.hash?.mode || 'canonical-or-exact';
            // Check for canonical hours
            const canonicalHours = formatter.calendar.canonicalHours;
            if (mode === 'exact' || !canonicalHours || canonicalHours.length === 0) {
                // Force exact time or no canonical hours available
                return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            }
            if (mode === 'canonical-or-exact' || mode === 'canonical') {
                // Look for matching canonical hour
                const canonicalHour = DateFormatter.findCanonicalHour(canonicalHours, hour, minute, formatter.calendar);
                if (canonicalHour) {
                    return canonicalHour.name;
                }
                // No canonical hour found
                if (mode === 'canonical') {
                    // Hide time when canonical mode is forced but no canonical hour available
                    return '';
                }
                // Fallback to exact time for canonical-or-exact mode
                return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            }
            // Default fallback
            return `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
        });
    }
    /**
     * Add ordinal suffix to a number (1st, 2nd, 3rd, etc.)
     */
    addOrdinalSuffix(day) {
        return DateFormatter.addOrdinalSuffix(day);
    }
    /**
     * Static version of addOrdinalSuffix for use in helpers
     */
    static addOrdinalSuffix(day) {
        if (day >= 11 && day <= 13) {
            return `${day}th`;
        }
        const lastDigit = day % 10;
        switch (lastDigit) {
            case 1:
                return `${day}st`;
            case 2:
                return `${day}nd`;
            case 3:
                return `${day}rd`;
            default:
                return `${day}th`;
        }
    }
    /**
     * Find canonical hour that matches the given time
     */
    static findCanonicalHour(canonicalHours, hour, minute, calendar) {
        if (!canonicalHours || canonicalHours.length === 0) {
            return null;
        }
        const minutesInHour = calendar.time?.minutesInHour ?? 60;
        for (const canonicalHour of canonicalHours) {
            const startHour = canonicalHour.startHour;
            const endHour = canonicalHour.endHour;
            const startMinute = canonicalHour.startMinute ?? 0;
            const endMinute = canonicalHour.endMinute ?? 0;
            // Handle same-day time ranges (start < end)
            if (startHour < endHour || (startHour === endHour && startMinute < endMinute)) {
                if (DateFormatter.isTimeInRange(hour, minute, startHour, startMinute, endHour, endMinute, minutesInHour)) {
                    return canonicalHour;
                }
            }
            // Handle midnight wraparound (start > end, e.g., 23:00 to 02:00)
            else if (startHour > endHour || (startHour === endHour && startMinute > endMinute)) {
                // Time is after start time OR before end time
                if (DateFormatter.isTimeAfterOrEqual(hour, minute, startHour, startMinute, minutesInHour) ||
                    DateFormatter.isTimeBeforeOrEqual(hour, minute, endHour, endMinute, minutesInHour)) {
                    return canonicalHour;
                }
            }
        }
        return null;
    }
    /**
     * Check if time is within a range (inclusive start, exclusive end)
     */
    static isTimeInRange(hour, minute, startHour, startMinute, endHour, endMinute, minutesInHour) {
        const timeInMinutes = hour * minutesInHour + minute;
        const startInMinutes = startHour * minutesInHour + startMinute;
        const endInMinutes = endHour * minutesInHour + endMinute;
        return timeInMinutes >= startInMinutes && timeInMinutes < endInMinutes;
    }
    /**
     * Check if time is after or equal to reference time
     */
    static isTimeAfterOrEqual(hour, minute, refHour, refMinute, minutesInHour) {
        const timeInMinutes = hour * minutesInHour + minute;
        const refInMinutes = refHour * minutesInHour + refMinute;
        return timeInMinutes >= refInMinutes;
    }
    /**
     * Check if time is before or equal to reference time
     */
    static isTimeBeforeOrEqual(hour, minute, refHour, refMinute, minutesInHour) {
        const timeInMinutes = hour * minutesInHour + minute;
        const refInMinutes = refHour * minutesInHour + refMinute;
        return timeInMinutes <= refInMinutes;
    }
    /**
     * Get month name from calendar definition
     */
    getMonthName(monthIndex) {
        const month = this.calendar.months[monthIndex - 1];
        const name = month?.name;
        // Ensure we return a string, not an object
        return typeof name === 'string' ? name : 'Unknown';
    }
    /**
     * Get month abbreviation from calendar definition
     */
    getMonthAbbreviation(monthIndex) {
        const month = this.calendar.months[monthIndex - 1];
        const abbr = month?.abbreviation;
        const name = month?.name;
        // Ensure we return a string, not an object
        if (typeof abbr === 'string') {
            return abbr;
        }
        if (typeof name === 'string') {
            return name.substring(0, 3);
        }
        return 'Unk';
    }
    /**
     * Get weekday name from calendar definition
     */
    getWeekdayName(weekdayIndex) {
        const weekday = this.calendar.weekdays[weekdayIndex];
        const name = weekday?.name;
        // Ensure we return a string, not an object
        return typeof name === 'string' ? name : 'Unknown';
    }
    /**
     * Get weekday abbreviation from calendar definition
     */
    getWeekdayAbbreviation(weekdayIndex) {
        const weekday = this.calendar.weekdays[weekdayIndex];
        const abbr = weekday?.abbreviation;
        const name = weekday?.name;
        // Ensure we return a string, not an object
        if (typeof abbr === 'string') {
            return abbr;
        }
        if (typeof name === 'string') {
            return name.substring(0, 3);
        }
        return 'Unk';
    }
    /**
     * Validate template output to detect malformed templates that produce invalid results
     */
    isInvalidTemplateOutput(result, template) {
        // If result is empty, it's likely an invalid template
        if (!result || result.trim().length === 0) {
            return true;
        }
        // If template contains helpers but result has too many empty values, it's likely malformed
        const hasHelpers = template.includes('{{ss-');
        if (!hasHelpers) {
            // No helpers - check if template has variables but result is empty/minimal
            const hasVariables = template.includes('{{');
            if (hasVariables && result.trim().length === 0) {
                return true; // Template has variables but no output
            }
            return false; // No helpers, output is valid
        }
        // Check for patterns that suggest malformed helper output
        const emptyHelperPatterns = [
            /:\s*:/, // :: pattern (empty hour:minute)
            /^:.*:$/, // :something: pattern
            /^,\s*,/, // empty comma-separated values
            /^\s*,.*,\s*$/, // mostly empty comma-separated
        ];
        // Check if result matches suspicious patterns
        for (const pattern of emptyHelperPatterns) {
            if (pattern.test(result.trim())) {
                return true;
            }
        }
        // Check if result is suspiciously short for a template with multiple helpers
        const helperCount = (template.match(/\{\{ss-/g) || []).length;
        if (helperCount >= 3 && result.trim().length < helperCount * 2) {
            return true; // Too short for the number of helpers
        }
        return false;
    }
}
DateFormatter.helpersRegistered = false;
DateFormatter.notifiedErrors = new Set(); // Throttle repeated notifications
DateFormatter.helperRegistry = new Map(); // Registry for calendar access
// Fallback month/weekday names for when no calendar context is available
DateFormatter.fallbackMonths = [
    { name: 'January', abbreviation: 'Jan' },
    { name: 'February', abbreviation: 'Feb' },
    { name: 'March', abbreviation: 'Mar' },
    { name: 'April', abbreviation: 'Apr' },
    { name: 'May', abbreviation: 'May' },
    { name: 'June', abbreviation: 'Jun' },
    { name: 'July', abbreviation: 'Jul' },
    { name: 'August', abbreviation: 'Aug' },
    { name: 'September', abbreviation: 'Sep' },
    { name: 'October', abbreviation: 'Oct' },
    { name: 'November', abbreviation: 'Nov' },
    { name: 'December', abbreviation: 'Dec' },
];
DateFormatter.fallbackWeekdays = [
    { name: 'Sunday', abbreviation: 'Sun' },
    { name: 'Monday', abbreviation: 'Mon' },
    { name: 'Tuesday', abbreviation: 'Tue' },
    { name: 'Wednesday', abbreviation: 'Wed' },
    { name: 'Thursday', abbreviation: 'Thu' },
    { name: 'Friday', abbreviation: 'Fri' },
    { name: 'Saturday', abbreviation: 'Sat' },
];

/**
 * Calendar date representation and formatting for Seasons & Stars
 */
class CalendarDate {
    constructor(data, calendar) {
        try {
            if (!data || typeof data !== 'object') {
                throw new Error('Invalid calendar date data provided');
            }
            if (!calendar || typeof calendar !== 'object') {
                throw new Error('Invalid calendar provided');
            }
            this.year = data.year;
            this.month = data.month;
            this.day = data.day;
            this.weekday = data.weekday;
            this.intercalary = data.intercalary;
            this.time = data.time;
            this.calendar = calendar;
            this.formatter = new DateFormatter(calendar);
        }
        catch (error) {
            console.debug('[S&S] Error creating CalendarDate:', error);
            throw error;
        }
    }
    /**
     * Format the date for display using the new template-based system
     */
    format(options = {}) {
        // Try to use calendar's dateFormats first
        const dateFormats = this.calendar.dateFormats;
        // Check for predefined formats in calendar
        if (dateFormats) {
            const formatName = this.getFormatNameFromOptions(options);
            if (formatName && dateFormats[formatName]) {
                return this.formatter.formatNamed(this, formatName);
            }
        }
        // Fallback to building a template based on options
        const template = this.buildTemplateFromOptions(options);
        return this.formatter.format(this, template);
    }
    /**
     * Get a format name from calendar dateFormats based on options
     */
    getFormatNameFromOptions(options) {
        const { includeTime, format } = options;
        // Look for common format names based on options
        const possibleNames = [];
        if (format === 'short') {
            possibleNames.push('short', 'brief');
        }
        else if (format === 'long') {
            possibleNames.push('long', 'full', 'detailed');
        }
        else if (format === 'numeric') {
            possibleNames.push('numeric', 'iso', 'number');
        }
        if (includeTime) {
            // Add specific time variants first (e.g., shortTime, longTime)
            const timeVariants = possibleNames.map(name => `${name}Time`);
            // Add generic time formats last
            possibleNames.unshift(...timeVariants, 'datetime', 'timestamp');
        }
        // Check if any of these formats exist in calendar
        const dateFormats = this.calendar.dateFormats;
        if (dateFormats) {
            for (const name of possibleNames) {
                if (dateFormats[name]) {
                    return name;
                }
            }
        }
        return null;
    }
    /**
     * Build a template string based on DateFormatOptions
     */
    buildTemplateFromOptions(options) {
        const { includeTime = false, includeWeekday = true, includeYear = true, format = 'long', } = options;
        const parts = [];
        // Handle intercalary days
        if (this.intercalary) {
            return this.intercalary;
        }
        // Add weekday if requested
        if (includeWeekday) {
            if (format === 'short') {
                parts.push('{{ss-weekday format="abbr"}}');
            }
            else {
                parts.push('{{ss-weekday format="name"}}');
            }
        }
        // Add day and month
        if (format === 'numeric') {
            parts.push('{{ss-month}}/{{ss-day}}');
        }
        else if (format === 'short') {
            parts.push('{{ss-day}} {{ss-month format="abbr"}}');
        }
        else {
            parts.push('{{ss-day format="ordinal"}} {{ss-month format="name"}}');
        }
        // Add year if requested
        if (includeYear) {
            parts.push('{{year}}');
        }
        // Add time if requested
        if (includeTime && this.time) {
            parts.push('{{ss-hour format="pad"}}:{{ss-minute format="pad"}}:{{ss-second format="pad"}}');
        }
        return parts.join(', ');
    }
    /**
     * Get a short format string (for UI display) - tries widget.mini format first
     */
    toShortString() {
        // Try widget.mini format first
        const dateFormats = this.calendar.dateFormats;
        if (dateFormats?.widgets?.mini) {
            return this.formatter.formatWidget(this, 'mini');
        }
        // Fallback to basic string formatting for calendars without dateFormats
        if (!dateFormats) {
            // Handle intercalary days first
            if (this.intercalary) {
                return this.intercalary;
            }
            return `${this.day} ${this.getMonthName('short')} ${this.getYearString()}`;
        }
        // Try options-based format but fall back to basic if it fails
        try {
            return this.format({
                includeTime: false,
                includeWeekday: false,
                format: 'short',
            });
        }
        catch {
            // Handle intercalary days in error fallback
            if (this.intercalary) {
                return this.intercalary;
            }
            return `${this.day} ${this.getMonthName('short')} ${this.getYearString()}`;
        }
    }
    /**
     * Get a full format string (for detailed display) - tries widget.main format first
     */
    toLongString() {
        // Try widget.main format first
        const dateFormats = this.calendar.dateFormats;
        if (dateFormats?.widgets?.main) {
            return this.formatter.formatWidget(this, 'main');
        }
        // Fallback to basic string formatting for calendars without dateFormats
        if (!dateFormats) {
            // Handle intercalary days first
            if (this.intercalary) {
                const timeString = this.time ? ` ${this.getTimeString()}` : '';
                return `${this.intercalary}${timeString}`;
            }
            const weekdayName = this.getWeekdayName('long');
            const monthName = this.getMonthName('long');
            const dayOrdinal = this.getDayString('long');
            const yearString = this.getYearString();
            const timeString = this.time ? ` ${this.getTimeString()}` : '';
            return `${weekdayName}, ${dayOrdinal} ${monthName} ${yearString}${timeString}`;
        }
        // Try options-based format but fall back to basic if it fails
        try {
            return this.format({
                includeTime: true,
                includeWeekday: true,
                includeYear: true,
                format: 'long',
            });
        }
        catch {
            // Handle intercalary days in error fallback
            if (this.intercalary) {
                const timeString = this.time ? ` ${this.getTimeString()}` : '';
                return `${this.intercalary}${timeString}`;
            }
            const weekdayName = this.getWeekdayName('long');
            const monthName = this.getMonthName('long');
            const dayOrdinal = this.getDayString('long');
            const yearString = this.getYearString();
            const timeString = this.time ? ` ${this.getTimeString()}` : '';
            return `${weekdayName}, ${dayOrdinal} ${monthName} ${yearString}${timeString}`;
        }
    }
    /**
     * Get just the date portion (no time) - prefers named formats
     */
    toDateString() {
        // Try named 'date' format first
        const dateFormats = this.calendar.dateFormats;
        if (dateFormats?.date) {
            return this.formatter.formatNamed(this, 'date');
        }
        // Fallback to basic string formatting for calendars without dateFormats
        if (!dateFormats) {
            const weekdayName = this.getWeekdayName('long');
            const monthName = this.getMonthName('long');
            const dayOrdinal = this.getDayString('long');
            const yearString = this.getYearString();
            return `${weekdayName}, ${dayOrdinal} ${monthName} ${yearString}`;
        }
        // Try options-based format but fall back to basic if it fails
        try {
            return this.format({
                includeTime: false,
                includeWeekday: true,
                includeYear: true,
                format: 'long',
            });
        }
        catch (error) {
            console.debug('[S&S] Error formatting date string:', error);
            const weekdayName = this.getWeekdayName('long');
            const monthName = this.getMonthName('long');
            const dayOrdinal = this.getDayString('long');
            const yearString = this.getYearString();
            return `${weekdayName}, ${dayOrdinal} ${monthName} ${yearString}`;
        }
    }
    /**
     * Get just the time portion - prefers named time format
     */
    toTimeString() {
        if (!this.time)
            return '';
        // Try named 'time' format first
        const dateFormats = this.calendar.dateFormats;
        if (dateFormats?.time) {
            return this.formatter.formatNamed(this, 'time');
        }
        // Fallback to basic string formatting for calendars without dateFormats
        if (!dateFormats) {
            return this.getTimeString();
        }
        // Fallback to template-based time format
        return this.formatter.format(this, '{{ss-hour format="pad"}}:{{ss-minute format="pad"}}:{{ss-second format="pad"}}');
    }
    /**
     * Get the weekday name
     */
    getWeekdayName(format) {
        try {
            const weekday = this.calendar.weekdays?.[this.weekday];
            if (!weekday) {
                // Invalid weekday index, using fallback
                return 'Unknown';
            }
            if (format === 'short' && weekday.abbreviation) {
                return weekday.abbreviation;
            }
            return weekday.name || 'Unknown';
        }
        catch (error) {
            console.debug('[S&S] Error getting weekday name:', error);
            return 'Unknown';
        }
    }
    /**
     * Get the month name
     */
    getMonthName(format) {
        try {
            const month = this.calendar.months?.[this.month - 1];
            if (!month) {
                // Invalid month index, using fallback
                return 'Unknown';
            }
            if (format === 'short' && month.abbreviation) {
                return month.abbreviation;
            }
            return month.name || 'Unknown';
        }
        catch (error) {
            console.debug('[S&S] Error getting month name:', error);
            return 'Unknown';
        }
    }
    /**
     * Get the day string with appropriate suffix
     */
    getDayString(format) {
        try {
            if (typeof this.day !== 'number' || this.day < 1) {
                // Invalid day value, using fallback
                return '1';
            }
            if (format === 'numeric') {
                return this.day.toString();
            }
            // Add ordinal suffix for long format
            if (format === 'long') {
                return this.addOrdinalSuffix(this.day);
            }
            return this.day.toString();
        }
        catch {
            return '1';
        }
    }
    /**
     * Get the year string with prefix/suffix
     */
    getYearString() {
        try {
            if (typeof this.year !== 'number') {
                console.debug(`[S&S] Invalid year value: ${this.year}`);
                return '1';
            }
            const { prefix = '', suffix = '' } = this.calendar.year || {};
            return `${prefix}${this.year}${suffix}`.trim();
        }
        catch {
            return this.year?.toString() || '1';
        }
    }
    /**
     * Get the time string
     */
    getTimeString() {
        try {
            if (!this.time)
                return '';
            const { hour, minute, second } = this.time;
            // Validate time components
            if (typeof hour !== 'number' || typeof minute !== 'number' || typeof second !== 'number') {
                console.debug(`[S&S] Invalid time components:`, { hour, minute, second });
                return '00:00:00';
            }
            // Use 24-hour format by default
            const hourStr = CalendarTimeUtils.formatTimeComponent(hour);
            const minuteStr = CalendarTimeUtils.formatTimeComponent(minute);
            const secondStr = CalendarTimeUtils.formatTimeComponent(second);
            return `${hourStr}:${minuteStr}:${secondStr}`;
        }
        catch {
            return '00:00:00';
        }
    }
    /**
     * Add ordinal suffix to a number (1st, 2nd, 3rd, etc.)
     */
    addOrdinalSuffix(num) {
        try {
            if (typeof num !== 'number' || num < 1) {
                console.debug(`[S&S] Invalid number for ordinal suffix: ${num}`);
                return '1st';
            }
            return CalendarTimeUtils.addOrdinalSuffix(num);
        }
        catch (error) {
            console.debug('[S&S] Error adding ordinal suffix:', error);
            return `${num || 1}th`;
        }
    }
    /**
     * Clone this date with optional modifications
     */
    clone(modifications = {}) {
        return new CalendarDate({
            year: modifications.year ?? this.year,
            month: modifications.month ?? this.month,
            day: modifications.day ?? this.day,
            weekday: modifications.weekday ?? this.weekday,
            intercalary: modifications.intercalary ?? this.intercalary,
            time: modifications.time ?? (this.time ? { ...this.time } : undefined),
        }, this.calendar);
    }
    /**
     * Compare this date with another date
     */
    compareTo(other) {
        try {
            if (!other || typeof other !== 'object') {
                console.debug('[S&S] Invalid date data provided for comparison:', other);
                return 0;
            }
            if (this.year !== other.year)
                return this.year - other.year;
            if (this.month !== other.month)
                return this.month - other.month;
            if (this.day !== other.day)
                return this.day - other.day;
            // Compare time if both have it
            if (this.time && other.time) {
                if (this.time.hour !== other.time.hour)
                    return this.time.hour - other.time.hour;
                if (this.time.minute !== other.time.minute)
                    return this.time.minute - other.time.minute;
                if (this.time.second !== other.time.second)
                    return this.time.second - other.time.second;
            }
            return 0;
        }
        catch (error) {
            console.debug('[S&S] Error comparing dates:', error);
            return 0;
        }
    }
    /**
     * Check if this date is equal to another date
     */
    equals(other) {
        return this.compareTo(other) === 0;
    }
    /**
     * Check if this date is before another date
     */
    isBefore(other) {
        return this.compareTo(other) < 0;
    }
    /**
     * Check if this date is after another date
     */
    isAfter(other) {
        return this.compareTo(other) > 0;
    }
    /**
     * Get a plain object representation
     */
    toObject() {
        return {
            year: this.year,
            month: this.month,
            day: this.day,
            weekday: this.weekday,
            intercalary: this.intercalary,
            time: this.time ? { ...this.time } : undefined,
        };
    }
    /**
     * Check if this intercalary day counts for weekdays
     * Returns true for non-intercalary days or intercalary days with countsForWeekdays: true
     */
    countsForWeekdays() {
        if (!this.intercalary) {
            return true; // Regular days always count for weekdays
        }
        try {
            const intercalaryDef = this.calendar.intercalary?.find(i => i.name === this.intercalary);
            if (!intercalaryDef) {
                console.debug(`[S&S] Intercalary definition not found: ${this.intercalary}`);
                return true; // Default to true if definition not found
            }
            // Default to true if countsForWeekdays is not specified (backward compatibility)
            return intercalaryDef.countsForWeekdays ?? true;
        }
        catch {
            return true; // Default to true on error
        }
    }
    /**
     * Create a CalendarDate from a plain object
     */
    static fromObject(data, calendar) {
        return new CalendarDate(data, calendar);
    }
}

/**
 * System Compatibility Manager for Seasons & Stars
 *
 * Provides extensible compatibility layer for different game systems that may
 * calculate dates/weekdays differently than the standard fantasy calendar math.
 *
 * Supports both calendar-defined compatibility (in JSON) and hook-based runtime
 * registration for external modules.
 */
/**
 * Manages system compatibility adjustments for calendar calculations
 */
class CompatibilityManager {
    constructor() {
        this.hookRegistry = new Map();
        this.timeSourceRegistry = new Map();
        this.dataProviderRegistry = new Map();
        this.initializeHookSystem();
        this.initializeGenericHooks();
        this.initializeSystemSpecificHooks();
        this.initializeSystemDetection();
    }
    /**
     * Initialize hook system for external module registration
     */
    initializeHookSystem() {
        // Create registry interface for hook callbacks
        const registry = {
            register: (systemId, calendarId, adjustment) => {
                const key = `${systemId}:${calendarId}`;
                this.hookRegistry.set(key, adjustment);
                Logger.debug(`Registered compatibility: ${systemId} + ${calendarId}`, adjustment);
            },
            get: (systemId, calendarId) => {
                const key = `${systemId}:${calendarId}`;
                return this.hookRegistry.get(key) || null;
            },
            has: (systemId, calendarId) => {
                const key = `${systemId}:${calendarId}`;
                return this.hookRegistry.has(key);
            },
            list: () => {
                const result = [];
                for (const [key, adjustment] of this.hookRegistry.entries()) {
                    const [systemId, calendarId] = key.split(':');
                    result.push({ systemId, calendarId, adjustment });
                }
                return result;
            },
        };
        // Emit hook to allow external modules to register compatibility
        Hooks.callAll('seasons-stars:registerCompatibility', registry);
    }
    /**
     * Initialize generic hooks for backward compatibility
     */
    initializeGenericHooks() {
        // Reserved for future generic hooks if needed
    }
    /**
     * Initialize system-specific hooks for compatibility registration
     */
    initializeSystemSpecificHooks() {
        // System-specific hooks are now minimal since we use direct registration
        // Only keeping compatibility hooks for potential future use
    }
    /**
     * Initialize system detection to emit appropriate system-specific hooks
     */
    initializeSystemDetection() {
        // Wait for Foundry to be ready so game.system is available
        Hooks.once('ready', () => {
            const currentSystem = game.system?.id;
            if (currentSystem) {
                Logger.debug(`Detected system: ${currentSystem}, triggering system-specific hooks`);
                // Trigger system-specific hook initialization for detected system
                // Pass the compatibility manager instance for direct registration
                Hooks.callAll(`seasons-stars:${currentSystem}:systemDetected`, this);
            }
        });
    }
    /**
     * Get compatibility adjustment for current system and calendar
     */
    getCompatibilityAdjustment(calendar, systemId) {
        const currentSystemId = systemId || (typeof game !== 'undefined' && game?.system?.id);
        if (!currentSystemId || !calendar)
            return null;
        // 1. Check calendar-defined compatibility first
        const calendarCompat = calendar.compatibility?.[currentSystemId];
        if (calendarCompat) {
            return {
                ...calendarCompat,
                provider: 'calendar-defined',
            };
        }
        // 2. Check hook-registered compatibility
        const key = `${currentSystemId}:${calendar.id}`;
        const hookCompat = this.hookRegistry.get(key);
        if (hookCompat) {
            return {
                ...hookCompat,
                provider: hookCompat.provider || 'hook-registered',
            };
        }
        return null;
    }
    /**
     * Apply weekday compatibility adjustment
     */
    applyWeekdayAdjustment(weekday, calendar, systemId) {
        const adjustment = this.getCompatibilityAdjustment(calendar, systemId);
        if (adjustment?.weekdayOffset) {
            const weekdayCount = calendar.weekdays?.length || 7;
            let adjustedWeekday = (weekday + adjustment.weekdayOffset) % weekdayCount;
            // Handle negative results
            if (adjustedWeekday < 0) {
                adjustedWeekday += weekdayCount;
            }
            return adjustedWeekday;
        }
        return weekday;
    }
    /**
     * Apply date formatting adjustments
     */
    applyDateFormatAdjustment(date, calendar, systemId) {
        const adjustment = this.getCompatibilityAdjustment(calendar, systemId);
        if (adjustment?.dateFormatting) {
            const formatting = adjustment.dateFormatting;
            return {
                ...date,
                month: formatting.monthOffset ? date.month + formatting.monthOffset : date.month,
                day: formatting.dayOffset ? date.day + formatting.dayOffset : date.day,
            };
        }
        return date;
    }
    /**
     * Get debug information about active compatibility adjustments
     */
    getDebugInfo(calendar, systemId) {
        const currentSystemId = systemId || game.system?.id;
        const adjustment = this.getCompatibilityAdjustment(calendar, currentSystemId);
        if (!adjustment) {
            return `No compatibility adjustments for ${currentSystemId} + ${calendar?.id || 'unknown'}`;
        }
        const parts = [];
        if (adjustment.weekdayOffset) {
            parts.push(`weekday offset: +${adjustment.weekdayOffset}`);
        }
        if (adjustment.dateFormatting) {
            parts.push('date formatting adjustments');
        }
        return `${currentSystemId} + ${calendar.id}: ${parts.join(', ')} (${adjustment.provider})`;
    }
    /**
     * Register a time source for a specific system (direct registration)
     */
    registerTimeSource(systemId, sourceFunction) {
        this.timeSourceRegistry.set(systemId, sourceFunction);
        Logger.debug(`Registered time source for system: ${systemId}`);
    }
    /**
     * Get external time source value by system ID
     */
    getExternalTimeSource(systemId) {
        const timeSourceFunction = this.timeSourceRegistry.get(systemId);
        if (timeSourceFunction) {
            try {
                return timeSourceFunction();
            }
            catch (error) {
                Logger.warn(`Error getting time from source ${systemId}:`, error);
                return null;
            }
        }
        return null;
    }
    /**
     * Get all available external time sources
     */
    getAvailableTimeSources() {
        return Array.from(this.timeSourceRegistry.keys());
    }
    /**
     * Register a data provider for a specific system and key
     */
    registerDataProvider(systemId, key, provider) {
        if (!this.dataProviderRegistry.has(systemId)) {
            this.dataProviderRegistry.set(systemId, new Map());
        }
        this.dataProviderRegistry.get(systemId).set(key, provider);
        Logger.debug(`Registered data provider: ${systemId}.${key}`);
    }
    /**
     * Get system-specific data by calling the registered provider
     */
    getSystemData(systemId, key) {
        const systemProviders = this.dataProviderRegistry.get(systemId);
        if (!systemProviders) {
            return null;
        }
        const provider = systemProviders.get(key);
        if (!provider) {
            return null;
        }
        try {
            return provider();
        }
        catch (error) {
            Logger.warn(`Error getting system data ${systemId}.${key}:`, error);
            return null;
        }
    }
    /**
     * Check if a data provider exists for a system and key
     */
    hasDataProvider(systemId, key) {
        const systemProviders = this.dataProviderRegistry.get(systemId);
        return systemProviders?.has(key) || false;
    }
    /**
     * Get all available data providers for a system
     */
    getAvailableDataProviders(systemId) {
        const systemProviders = this.dataProviderRegistry.get(systemId);
        return systemProviders ? Array.from(systemProviders.keys()) : [];
    }
    /**
     * List all available compatibility adjustments for debugging
     */
    debugListAll() {
        Logger.debug('All registered compatibility adjustments:');
        // Hook-registered compatibility
        for (const [key, adjustment] of this.hookRegistry.entries()) {
            Logger.debug(`  Hook: ${key}`, adjustment);
        }
        // Registered time sources
        Logger.debug('Registered time sources:');
        for (const sourceId of this.timeSourceRegistry.keys()) {
            Logger.debug(`  Time source: ${sourceId}`);
        }
        // Registered data providers
        Logger.debug('Registered data providers:');
        for (const [systemId, providers] of this.dataProviderRegistry.entries()) {
            for (const key of providers.keys()) {
                Logger.debug(`  Data provider: ${systemId}.${key}`);
            }
        }
        // Note: Calendar-defined compatibility is checked dynamically per calendar
        Logger.debug('  Calendar-defined compatibility is checked per calendar load');
    }
}
// Global instance
const compatibilityManager = new CompatibilityManager();

const GREGORIAN_DEFAULTS = {
    "year": {
        "epoch": 0,
        "currentYear": 2024,
        "prefix": "",
        "suffix": " CE",
        "startDay": 6
    },
    "leapYear": {
        "rule": "gregorian",
        "month": "February",
        "extraDays": 1
    },
    "months": [
        {
            "name": "January",
            "abbreviation": "Jan",
            "days": 31,
            "description": "The coldest month of winter in the northern hemisphere"
        },
        {
            "name": "February",
            "abbreviation": "Feb",
            "days": 28,
            "description": "The shortest month, known for love and renewal"
        },
        {
            "name": "March",
            "abbreviation": "Mar",
            "days": 31,
            "description": "Spring begins, named after Mars, god of war"
        },
        {
            "name": "April",
            "abbreviation": "Apr",
            "days": 30,
            "description": "Month of opening buds and fresh growth"
        },
        {
            "name": "May",
            "abbreviation": "May",
            "days": 31,
            "description": "Month of flowers, named after Maia, goddess of growth"
        },
        {
            "name": "June",
            "abbreviation": "Jun",
            "days": 30,
            "description": "Beginning of summer, named after Juno, goddess of marriage"
        },
        {
            "name": "July",
            "abbreviation": "Jul",
            "days": 31,
            "description": "Named after Julius Caesar, peak of summer"
        },
        {
            "name": "August",
            "abbreviation": "Aug",
            "days": 31,
            "description": "Named after Augustus Caesar, late summer heat"
        },
        {
            "name": "September",
            "abbreviation": "Sep",
            "days": 30,
            "description": "The seventh month of the old Roman calendar"
        },
        {
            "name": "October",
            "abbreviation": "Oct",
            "days": 31,
            "description": "The eighth month of the old Roman calendar, autumn arrives"
        },
        {
            "name": "November",
            "abbreviation": "Nov",
            "days": 30,
            "description": "The ninth month of the old Roman calendar, late autumn"
        },
        {
            "name": "December",
            "abbreviation": "Dec",
            "days": 31,
            "description": "The tenth month of the old Roman calendar, winter solstice"
        }
    ],
    "weekdays": [
        {
            "name": "Sunday",
            "abbreviation": "Sun",
            "description": "Day of rest and worship in many cultures"
        },
        {
            "name": "Monday",
            "abbreviation": "Mon",
            "description": "Beginning of the work week"
        },
        {
            "name": "Tuesday",
            "abbreviation": "Tue",
            "description": "Named after Tyr, Norse god of war"
        },
        {
            "name": "Wednesday",
            "abbreviation": "Wed",
            "description": "Named after Woden (Odin), chief Norse god"
        },
        {
            "name": "Thursday",
            "abbreviation": "Thu",
            "description": "Named after Thor, Norse god of thunder"
        },
        {
            "name": "Friday",
            "abbreviation": "Fri",
            "description": "Named after Frigg, Norse goddess of love"
        },
        {
            "name": "Saturday",
            "abbreviation": "Sat",
            "description": "Named after Saturn, Roman god of agriculture"
        }
    ],
    "intercalary": [],
    "time": {
        "hoursInDay": 24,
        "minutesInHour": 60,
        "secondsInMinute": 60
    }};

/**
 * Core calendar calculation engine for Seasons & Stars
 */
class CalendarEngine {
    constructor(calendar) {
        this.calculationCache = new Map();
        this.calendar = CalendarEngine.applyGregorianDefaults(calendar);
        this.precomputeYearData();
    }
    static applyGregorianDefaults(calendar) {
        const defaults = GREGORIAN_DEFAULTS;
        const mergedLeapYear = calendar.leapYear === undefined
            ? defaults.leapYear
            : calendar.leapYear.rule === 'none'
                ? { rule: 'none' }
                : { ...defaults.leapYear, ...calendar.leapYear };
        const merged = {
            ...calendar,
            year: calendar.year === undefined ? defaults.year : { ...defaults.year, ...calendar.year },
            leapYear: mergedLeapYear,
            time: calendar.time === undefined ? defaults.time : { ...defaults.time, ...calendar.time },
            months: calendar.months ?? defaults.months,
            weekdays: calendar.weekdays ?? defaults.weekdays,
            intercalary: calendar.intercalary ?? defaults.intercalary,
        };
        if (!calendar.year)
            Logger.warn(`Calendar ${calendar.id} missing year data; using Gregorian defaults`);
        if (!calendar.leapYear)
            Logger.warn(`Calendar ${calendar.id} missing leapYear data; using Gregorian defaults`);
        if (!calendar.months)
            Logger.warn(`Calendar ${calendar.id} missing months data; using Gregorian defaults`);
        if (!calendar.weekdays)
            Logger.warn(`Calendar ${calendar.id} missing weekdays data; using Gregorian defaults`);
        if (!calendar.intercalary)
            Logger.warn(`Calendar ${calendar.id} missing intercalary data; using Gregorian defaults`);
        if (!calendar.time)
            Logger.warn(`Calendar ${calendar.id} missing time data; using Gregorian defaults`);
        return merged;
    }
    /**
     * Convert Foundry world time (seconds) to calendar date
     * Now supports both epoch-based and real-time-based interpretation
     */
    worldTimeToDate(worldTime, worldCreationTimestamp) {
        const adjustedWorldTime = this.adjustWorldTimeForInterpretation(worldTime);
        const totalSeconds = Math.floor(adjustedWorldTime);
        const secondsPerDay = CalendarTimeUtils.getSecondsPerDay(this.calendar);
        const totalDays = Math.floor(totalSeconds / secondsPerDay);
        let secondsInDay = totalSeconds % secondsPerDay;
        // Handle negative seconds in day (can happen with real-time interpretation)
        if (secondsInDay < 0) {
            secondsInDay += secondsPerDay;
        }
        // Calculate time of day
        const secondsPerHour = CalendarTimeUtils.getSecondsPerHour(this.calendar);
        let hour = Math.floor(secondsInDay / secondsPerHour);
        let minute = Math.floor((secondsInDay % secondsPerHour) / this.calendar.time.secondsInMinute);
        let second = secondsInDay % this.calendar.time.secondsInMinute;
        // Normalize -0 to +0 for JavaScript precision issues
        let normalizedHour = hour === 0 ? 0 : hour;
        let normalizedMinute = minute === 0 ? 0 : minute;
        let normalizedSecond = second === 0 ? 0 : second;
        // Convert days to calendar date
        const dateInfo = this.daysToDate(totalDays);
        // Adjust date calculation for system-specific integration
        let adjustedYear = dateInfo.year;
        let adjustedMonth = dateInfo.month;
        let adjustedDay = dateInfo.day;
        let adjustedWeekday = dateInfo.weekday;
        if (worldCreationTimestamp !== undefined) {
            // Use PF2e-style calculation: real-world world creation date maps to calendar date
            const worldCreationDate = new Date(worldCreationTimestamp * 1000);
            // Handle invalid timestamps
            if (isNaN(worldCreationDate.getTime())) {
                // Return invalid date with NaN year
                adjustedYear = NaN;
                adjustedMonth = dateInfo.month;
                adjustedDay = dateInfo.day;
                adjustedWeekday = dateInfo.weekday;
            }
            else {
                const epochYear = this.calendar.year?.epoch || 0;
                // Calculate calendar year from real-world year + epoch offset
                const realWorldYear = worldCreationDate.getUTCFullYear();
                const calendarBaseYear = realWorldYear + epochYear;
                // Calculate the base date: world creation timestamp = calendar base year on exact creation date
                const baseCalendarDate = new CalendarDate({
                    year: calendarBaseYear,
                    month: worldCreationDate.getUTCMonth() + 1, // 1-based
                    day: worldCreationDate.getUTCDate(),
                    weekday: 0, // Will be calculated
                    time: {
                        hour: worldCreationDate.getUTCHours(),
                        minute: worldCreationDate.getUTCMinutes(),
                        second: worldCreationDate.getUTCSeconds(),
                    },
                }, this.calendar);
                // Calculate base world time using epoch-based calculation (no recursion)
                const baseTotalDays = this.dateToDays(baseCalendarDate);
                const baseTimeOfDay = (baseCalendarDate.time?.hour || 0) * secondsPerHour +
                    (baseCalendarDate.time?.minute || 0) * this.calendar.time.secondsInMinute +
                    (baseCalendarDate.time?.second || 0);
                const baseWorldTime = baseTotalDays * secondsPerDay + baseTimeOfDay;
                // Add the elapsed world time to get the final calendar date
                const totalWorldTime = baseWorldTime + worldTime;
                const finalTotalDays = Math.floor(totalWorldTime / secondsPerDay);
                const finalDateInfo = this.daysToDate(finalTotalDays);
                // Use the calculated date
                adjustedYear = finalDateInfo.year;
                adjustedMonth = finalDateInfo.month;
                adjustedDay = finalDateInfo.day;
                adjustedWeekday = finalDateInfo.weekday;
                // Recalculate seconds in day for the final date
                secondsInDay = Math.floor(totalWorldTime % secondsPerDay);
                if (secondsInDay < 0) {
                    secondsInDay += secondsPerDay;
                }
                // Recalculate time components from updated secondsInDay
                hour = Math.floor(secondsInDay / secondsPerHour);
                minute = Math.floor((secondsInDay % secondsPerHour) / this.calendar.time.secondsInMinute);
                second = secondsInDay % this.calendar.time.secondsInMinute;
                // Update normalized time values
                normalizedHour = hour === 0 ? 0 : hour;
                normalizedMinute = minute === 0 ? 0 : minute;
                normalizedSecond = second === 0 ? 0 : second;
            }
        }
        const dateData = {
            year: adjustedYear,
            month: adjustedMonth,
            day: adjustedDay,
            weekday: adjustedWeekday,
            intercalary: dateInfo.intercalary,
            time: { hour: normalizedHour, minute: normalizedMinute, second: normalizedSecond },
        };
        return new CalendarDate(dateData, this.calendar);
    }
    /**
     * Convert calendar date to Foundry world time (seconds)
     * Handles both interpretation modes
     */
    dateToWorldTime(date, worldCreationTimestamp) {
        // When world creation timestamp is provided, we need to reverse the world creation calculation
        const adjustedDate = date;
        if (worldCreationTimestamp !== undefined) {
            const worldCreationDate = new Date(worldCreationTimestamp * 1000);
            const epochYear = this.calendar.year?.epoch || 0;
            // Calculate the calendar base year from real-world year + epoch offset
            const realWorldYear = worldCreationDate.getUTCFullYear();
            const calendarBaseYear = realWorldYear + epochYear;
            // Calculate the base date: world creation timestamp = calendar base year on exact creation date/time
            const baseCalendarDate = new CalendarDate({
                year: calendarBaseYear,
                month: worldCreationDate.getUTCMonth() + 1, // 1-based
                day: worldCreationDate.getUTCDate(),
                weekday: 0, // Will be calculated
                time: {
                    hour: worldCreationDate.getUTCHours(),
                    minute: worldCreationDate.getUTCMinutes(),
                    second: worldCreationDate.getUTCSeconds(),
                },
            }, this.calendar);
            // Calculate the difference from the base date to input date
            const baseWorldTime = this.dateToDays(baseCalendarDate) * CalendarTimeUtils.getSecondsPerDay(this.calendar);
            const baseTimeOfDay = (baseCalendarDate.time?.hour || 0) * CalendarTimeUtils.getSecondsPerHour(this.calendar) +
                (baseCalendarDate.time?.minute || 0) * this.calendar.time.secondsInMinute +
                (baseCalendarDate.time?.second || 0);
            const totalBaseWorldTime = baseWorldTime + baseTimeOfDay;
            const inputWorldTime = this.dateToDays(date) * CalendarTimeUtils.getSecondsPerDay(this.calendar);
            const inputTimeOfDay = (date.time?.hour || 0) * CalendarTimeUtils.getSecondsPerHour(this.calendar) +
                (date.time?.minute || 0) * this.calendar.time.secondsInMinute +
                (date.time?.second || 0);
            const totalInputWorldTime = inputWorldTime + inputTimeOfDay;
            // The world time is the difference from the base
            return totalInputWorldTime - totalBaseWorldTime;
        }
        const totalDays = this.dateToDays(adjustedDate);
        const secondsPerDay = CalendarTimeUtils.getSecondsPerDay(this.calendar);
        let totalSeconds = totalDays * secondsPerDay;
        // Add time of day if provided
        if (adjustedDate.time) {
            const secondsPerHour = CalendarTimeUtils.getSecondsPerHour(this.calendar);
            totalSeconds += adjustedDate.time.hour * secondsPerHour;
            totalSeconds += adjustedDate.time.minute * this.calendar.time.secondsInMinute;
            totalSeconds += adjustedDate.time.second;
        }
        return this.adjustWorldTimeFromInterpretation(totalSeconds);
    }
    /**
     * Add days to a calendar date
     */
    addDays(date, days) {
        const totalDays = this.dateToDays(date) + days;
        const newDate = this.daysToDate(totalDays);
        // Preserve time if it exists
        if (date.time) {
            newDate.time = { ...date.time };
        }
        return newDate;
    }
    /**
     * Add months to a calendar date
     */
    addMonths(date, months) {
        const { month: targetMonth, year: targetYear } = CalendarTimeUtils.normalizeMonth(date.month + months, date.year, this.calendar);
        // Adjust day if target month is shorter
        const targetMonthDays = this.getMonthLength(targetMonth, targetYear);
        const targetDay = Math.min(date.day, targetMonthDays);
        const dateData = {
            year: targetYear,
            month: targetMonth,
            day: targetDay,
            weekday: this.calculateWeekday(targetYear, targetMonth, targetDay),
            time: date.time ? { ...date.time } : undefined,
        };
        return new CalendarDate(dateData, this.calendar);
    }
    /**
     * Add years to a calendar date
     */
    addYears(date, years) {
        const targetYear = date.year + years;
        // Handle leap year day adjustments
        const targetMonthDays = this.getMonthLength(date.month, targetYear);
        const targetDay = Math.min(date.day, targetMonthDays);
        const dateData = {
            year: targetYear,
            month: date.month,
            day: targetDay,
            weekday: this.calculateWeekday(targetYear, date.month, targetDay),
            time: date.time ? { ...date.time } : undefined,
        };
        return new CalendarDate(dateData, this.calendar);
    }
    /**
     * Add hours to a calendar date
     */
    addHours(date, hours) {
        const currentTime = date.time || { hour: 0, minute: 0, second: 0 };
        const totalHours = currentTime.hour + hours;
        const hoursPerDay = this.calendar.time.hoursInDay;
        let extraDays = Math.floor(totalHours / hoursPerDay);
        let newHour = totalHours % hoursPerDay;
        // Handle negative hours
        if (newHour < 0) {
            newHour += hoursPerDay;
            extraDays -= 1;
        }
        const baseData = {
            year: date.year,
            month: date.month,
            day: date.day,
            weekday: date.weekday,
            intercalary: date.intercalary,
            time: {
                hour: newHour,
                minute: currentTime.minute,
                second: currentTime.second,
            },
        };
        let result = new CalendarDate(baseData, this.calendar);
        // Add extra days if needed
        if (extraDays !== 0) {
            result = this.addDays(result, extraDays);
        }
        return result;
    }
    /**
     * Add minutes to a calendar date
     */
    addMinutes(date, minutes) {
        const currentTime = date.time || { hour: 0, minute: 0, second: 0 };
        const totalMinutes = currentTime.minute + minutes;
        const minutesPerHour = this.calendar.time.minutesInHour;
        let extraHours = Math.floor(totalMinutes / minutesPerHour);
        let newMinute = totalMinutes % minutesPerHour;
        // Handle negative minutes
        if (newMinute < 0) {
            newMinute += minutesPerHour;
            extraHours -= 1;
        }
        const baseData = {
            year: date.year,
            month: date.month,
            day: date.day,
            weekday: date.weekday,
            intercalary: date.intercalary,
            time: {
                hour: currentTime.hour,
                minute: newMinute,
                second: currentTime.second,
            },
        };
        let result = new CalendarDate(baseData, this.calendar);
        // Add extra hours if needed
        if (extraHours !== 0) {
            result = this.addHours(result, extraHours);
        }
        return result;
    }
    /**
     * Adjust worldTime based on calendar's interpretation mode
     */
    adjustWorldTimeForInterpretation(worldTime) {
        const worldTimeConfig = this.calendar.worldTime;
        if (!worldTimeConfig || worldTimeConfig.interpretation === 'epoch-based') {
            // Default behavior: worldTime represents seconds since calendar epoch
            return worldTime;
        }
        if (worldTimeConfig.interpretation === 'real-time-based') {
            // Real-time mode: worldTime=0 should map to currentYear, not epochYear
            const yearDifference = worldTimeConfig.currentYear - worldTimeConfig.epochYear;
            // Use accurate year lengths instead of 365.25 average
            let epochOffset = 0;
            const secondsPerDay = this.calendar.time.hoursInDay *
                this.calendar.time.minutesInHour *
                this.calendar.time.secondsInMinute;
            if (yearDifference > 0) {
                // Add up actual year lengths from epoch to current year
                for (let year = worldTimeConfig.epochYear; year < worldTimeConfig.currentYear; year++) {
                    const yearLengthDays = this.getYearLength(year);
                    epochOffset += yearLengthDays * secondsPerDay;
                }
            }
            else if (yearDifference < 0) {
                // Subtract actual year lengths from current year to epoch
                for (let year = worldTimeConfig.currentYear; year < worldTimeConfig.epochYear; year++) {
                    const yearLengthDays = this.getYearLength(year);
                    epochOffset -= yearLengthDays * secondsPerDay;
                }
            }
            return worldTime + epochOffset;
        }
        // Unknown interpretation mode: return worldTime unchanged (fallback behavior)
        return worldTime;
    }
    /**
     * Convert internal seconds back to worldTime based on interpretation mode
     */
    adjustWorldTimeFromInterpretation(internalSeconds) {
        const worldTimeConfig = this.calendar.worldTime;
        if (!worldTimeConfig || worldTimeConfig.interpretation === 'epoch-based') {
            return internalSeconds;
        }
        if (worldTimeConfig.interpretation === 'real-time-based') {
            const yearDifference = worldTimeConfig.currentYear - worldTimeConfig.epochYear;
            // Use accurate year lengths instead of 365.25 average
            let epochOffset = 0;
            const secondsPerDay = this.calendar.time.hoursInDay *
                this.calendar.time.minutesInHour *
                this.calendar.time.secondsInMinute;
            if (yearDifference > 0) {
                // Add up actual year lengths from epoch to current year
                for (let year = worldTimeConfig.epochYear; year < worldTimeConfig.currentYear; year++) {
                    const yearLengthDays = this.getYearLength(year);
                    epochOffset += yearLengthDays * secondsPerDay;
                }
            }
            else if (yearDifference < 0) {
                // Subtract actual year lengths from current year to epoch
                for (let year = worldTimeConfig.currentYear; year < worldTimeConfig.epochYear; year++) {
                    const yearLengthDays = this.getYearLength(year);
                    epochOffset -= yearLengthDays * secondsPerDay;
                }
            }
            return internalSeconds - epochOffset;
        }
        return internalSeconds;
    }
    /**
     * Convert days since epoch to calendar date
     */
    daysToDate(totalDays) {
        let year = this.calendar.year.epoch;
        let remainingDays = totalDays;
        // Find the correct year
        while (remainingDays >= this.getYearLength(year)) {
            remainingDays -= this.getYearLength(year);
            year++;
        }
        // Handle negative days (before epoch)
        while (remainingDays < 0) {
            year--;
            remainingDays += this.getYearLength(year);
        }
        // Find month and day within the year
        let month = 1;
        const monthLengths = this.getMonthLengths(year);
        const intercalaryDays = this.getIntercalaryDays(year);
        for (month = 1; month <= this.calendar.months.length; month++) {
            const currentMonthName = this.calendar.months[month - 1]?.name;
            // Check for intercalary days before this month
            const intercalaryBeforeMonth = currentMonthName
                ? intercalaryDays.filter(i => i.before === currentMonthName)
                : [];
            for (const intercalary of intercalaryBeforeMonth) {
                const intercalaryDayCount = intercalary.days || 1;
                if (remainingDays < intercalaryDayCount) {
                    // We're within this intercalary period - return intercalary date with no weekday calculation
                    const dateData = {
                        year,
                        month,
                        day: remainingDays + 1, // Intercalary day index (1-based)
                        weekday: 0, // Placeholder - intercalary days don't have weekdays
                        intercalary: intercalary.name,
                    };
                    return new CalendarDate(dateData, this.calendar);
                }
                remainingDays -= intercalaryDayCount;
            }
            const monthLength = monthLengths[month - 1];
            if (remainingDays < monthLength) {
                break;
            }
            remainingDays -= monthLength;
            // Check for intercalary days after this month
            const intercalaryAfterMonth = currentMonthName
                ? intercalaryDays.filter(i => i.after === currentMonthName)
                : [];
            for (const intercalary of intercalaryAfterMonth) {
                const intercalaryDayCount = intercalary.days || 1;
                if (remainingDays < intercalaryDayCount) {
                    // We're within this intercalary period - return intercalary date with no weekday calculation
                    const dateData = {
                        year,
                        month,
                        day: remainingDays + 1, // Intercalary day index (1-based)
                        weekday: 0, // Placeholder - intercalary days don't have weekdays
                        intercalary: intercalary.name,
                    };
                    return new CalendarDate(dateData, this.calendar);
                }
                remainingDays -= intercalaryDayCount;
            }
        }
        const day = remainingDays + 1;
        const dateData = {
            year,
            month,
            day,
            weekday: this.calculateWeekday(year, month, day),
        };
        return new CalendarDate(dateData, this.calendar);
    }
    /**
     * Convert calendar date to days since epoch
     */
    dateToDays(date) {
        let totalDays = 0;
        // Handle years before or after epoch
        if (date.year >= this.calendar.year.epoch) {
            // Add days for complete years after epoch
            for (let year = this.calendar.year.epoch; year < date.year; year++) {
                totalDays += this.getYearLength(year);
            }
        }
        else {
            // Subtract days for complete years before epoch
            for (let year = date.year; year < this.calendar.year.epoch; year++) {
                totalDays -= this.getYearLength(year);
            }
        }
        // Add days for complete months in the target year
        const monthLengths = this.getMonthLengths(date.year);
        const intercalaryDays = this.getIntercalaryDays(date.year);
        for (let month = 1; month < date.month; month++) {
            const currentMonthName = this.calendar.months[month - 1]?.name;
            // Add intercalary days before this month
            const intercalaryBeforeMonth = currentMonthName
                ? intercalaryDays.filter(i => i.before === currentMonthName)
                : [];
            totalDays += intercalaryBeforeMonth.reduce((sum, intercalary) => {
                return sum + (intercalary.days || 1);
            }, 0);
            totalDays += monthLengths[month - 1];
            // Add intercalary days after this month
            const intercalaryAfterMonth = currentMonthName
                ? intercalaryDays.filter(i => i.after === currentMonthName)
                : [];
            totalDays += intercalaryAfterMonth.reduce((sum, intercalary) => {
                return sum + (intercalary.days || 1);
            }, 0);
        }
        // Add intercalary days before the current month (only for regular dates)
        if (!date.intercalary) {
            const currentMonthName = this.calendar.months[date.month - 1]?.name;
            const intercalaryBeforeCurrentMonth = currentMonthName
                ? intercalaryDays.filter(i => i.before === currentMonthName)
                : [];
            totalDays += intercalaryBeforeCurrentMonth.reduce((sum, intercalary) => {
                return sum + (intercalary.days || 1);
            }, 0);
        }
        // Handle intercalary vs regular days
        if (date.intercalary) {
            // For intercalary dates, we need to handle year-boundary cases specially
            // Find the intercalary day definition to understand its placement
            const intercalaryDef = this.calendar.intercalary.find(i => i.name === date.intercalary);
            if (intercalaryDef) {
                if (intercalaryDef.after) {
                    // Handle "after" intercalary days (existing logic)
                    const afterMonthIndex = this.calendar.months.findIndex(m => m.name === intercalaryDef.after);
                    if (afterMonthIndex >= 0) {
                        const afterMonth = afterMonthIndex + 1; // Convert to 1-based
                        // Check if this is a year-boundary intercalary day
                        // (comes after last month of previous year)
                        const isYearBoundary = afterMonth === this.calendar.months.length && date.month === afterMonth;
                        if (isYearBoundary) {
                            // Year-boundary intercalary: should come immediately after the last month
                            // of the PREVIOUS year, not after a full additional year
                            // Subtract the full year we added above (since it belongs to previous year's end)
                            totalDays -= this.getYearLength(date.year);
                            // Add all days of the month it comes after (from previous year)
                            const previousYearMonthLengths = this.getMonthLengths(date.year - 1);
                            totalDays += previousYearMonthLengths[afterMonth - 1]; // Month from previous year
                            // Add the intercalary day position
                            totalDays += date.day - 1; // Position within the intercalary period (0-based)
                        }
                        else {
                            // Regular intercalary day after a month within a year
                            // First, add any intercalary days that come before the month it comes after
                            const currentMonthName = this.calendar.months[date.month - 1]?.name;
                            const intercalaryBeforeCurrentMonth = currentMonthName
                                ? intercalaryDays.filter(i => i.before === currentMonthName)
                                : [];
                            totalDays += intercalaryBeforeCurrentMonth.reduce((sum, intercalary) => {
                                return sum + (intercalary.days || 1);
                            }, 0);
                            totalDays += monthLengths[date.month - 1]; // All days of the month it comes after
                            totalDays += date.day - 1; // Position within the intercalary period (0-based)
                        }
                    }
                    else {
                        // Fallback: intercalary day with invalid "after" month
                        totalDays += date.day - 1; // Position within the intercalary period (0-based)
                    }
                }
                else if (intercalaryDef.before) {
                    // Handle "before" intercalary days (new logic)
                    const beforeMonthIndex = this.calendar.months.findIndex(m => m.name === intercalaryDef.before);
                    if (beforeMonthIndex >= 0) {
                        const beforeMonth = beforeMonthIndex + 1; // Convert to 1-based
                        // Check if this is a year-boundary intercalary day
                        // (comes before first month but is associated with current year)
                        const isYearBoundary = beforeMonth === 1 &&
                            date.month === beforeMonth &&
                            date.year > this.calendar.year.epoch;
                        if (isYearBoundary) {
                            // Year-boundary intercalary: should come immediately before the first month
                            // We don't need to add the full year since we're at the start
                            // Add the intercalary day position (no month days to add)
                            totalDays += date.day - 1; // Position within the intercalary period (0-based)
                        }
                        else {
                            // Regular intercalary day before a month within a year
                            // For "before" intercalary, we don't add the month's days since we come before it
                            totalDays += date.day - 1; // Position within the intercalary period (0-based)
                        }
                    }
                    else {
                        // Fallback: intercalary day with invalid "before" month
                        totalDays += date.day - 1; // Position within the intercalary period (0-based)
                    }
                }
            }
            else {
                // Fallback: intercalary day not found in calendar definition
                totalDays += date.day - 1; // Position within the intercalary period (0-based)
            }
        }
        else {
            // For regular dates, add days within the target month
            totalDays += date.day - 1;
        }
        return totalDays;
    }
    /**
     * Calculate weekday for a given date
     */
    calculateWeekday(year, month, day) {
        const tempDateData = { year, month, day, weekday: 0 };
        const tempDate = new CalendarDate(tempDateData, this.calendar);
        const weekdayContributingDays = this.dateToWeekdayDays(tempDate);
        const weekdayCount = this.calendar.weekdays.length;
        const epochWeekday = this.calendar.year.startDay;
        // Calculate weekday: (days since epoch + weekday of epoch date) % weekday count
        // Handle negative results for dates before epoch
        let weekday = (weekdayContributingDays + epochWeekday) % weekdayCount;
        if (weekday < 0) {
            weekday += weekdayCount;
        }
        // Apply system compatibility adjustments
        weekday = compatibilityManager.applyWeekdayAdjustment(weekday, this.calendar);
        return weekday;
    }
    /**
     * Convert calendar date to days since epoch, counting only weekday-contributing days
     */
    dateToWeekdayDays(date) {
        let totalDays = 0;
        // Handle years before or after epoch
        if (date.year >= this.calendar.year.epoch) {
            // Add days for complete years after epoch
            for (let year = this.calendar.year.epoch; year < date.year; year++) {
                totalDays += this.getYearWeekdayDays(year);
            }
        }
        else {
            // Subtract days for complete years before epoch
            for (let year = date.year; year < this.calendar.year.epoch; year++) {
                totalDays -= this.getYearWeekdayDays(year);
            }
        }
        // Add days for complete months in the target year
        const monthLengths = this.getMonthLengths(date.year);
        const intercalaryDays = this.getIntercalaryDays(date.year);
        for (let month = 1; month < date.month; month++) {
            const currentMonthName = this.calendar.months[month - 1]?.name;
            // Add only weekday-contributing intercalary days before this month
            const intercalaryBeforeMonth = currentMonthName
                ? intercalaryDays.filter(i => i.before === currentMonthName)
                : [];
            intercalaryBeforeMonth.forEach(intercalary => {
                const countsForWeekdays = intercalary.countsForWeekdays ?? true;
                if (countsForWeekdays) {
                    totalDays += intercalary.days || 1;
                }
            });
            totalDays += monthLengths[month - 1];
            // Add only weekday-contributing intercalary days after this month
            const intercalaryAfterMonth = currentMonthName
                ? intercalaryDays.filter(i => i.after === currentMonthName)
                : [];
            intercalaryAfterMonth.forEach(intercalary => {
                const countsForWeekdays = intercalary.countsForWeekdays ?? true;
                if (countsForWeekdays) {
                    totalDays += intercalary.days || 1;
                }
            });
        }
        // Add days in the target month
        totalDays += date.day - 1;
        // Handle intercalary days - they don't contribute to weekday counts
        if (date.intercalary) ;
        return totalDays;
    }
    /**
     * Get the number of weekday-contributing days in a year
     */
    getYearWeekdayDays(year) {
        const monthLengths = this.getMonthLengths(year);
        const intercalaryDays = this.getIntercalaryDays(year);
        let totalDays = monthLengths.reduce((sum, days) => sum + days, 0);
        // Add only weekday-contributing intercalary days
        intercalaryDays.forEach(intercalary => {
            const countsForWeekdays = intercalary.countsForWeekdays ?? true;
            if (countsForWeekdays) {
                totalDays += intercalary.days || 1;
            }
        });
        return totalDays;
    }
    /**
     * Get the length of a specific year in days
     */
    getYearLength(year) {
        const monthLengths = this.getMonthLengths(year);
        const baseLength = monthLengths.reduce((sum, length) => sum + length, 0);
        const intercalaryDays = this.getIntercalaryDays(year);
        // Sum up all intercalary days, using the days field (defaulting to 1 for backward compatibility)
        const totalIntercalaryDays = intercalaryDays.reduce((sum, intercalary) => {
            return sum + (intercalary.days || 1);
        }, 0);
        return baseLength + totalIntercalaryDays;
    }
    /**
     * Get month lengths for a specific year (accounting for leap years)
     */
    getMonthLengths(year) {
        const monthLengths = this.calendar.months.map(month => month.days);
        // Add leap year days if applicable
        if (this.isLeapYear(year) && this.calendar.leapYear?.month) {
            const leapMonthIndex = this.calendar.months.findIndex(month => month.name === this.calendar.leapYear.month);
            if (leapMonthIndex >= 0) {
                monthLengths[leapMonthIndex] += this.calendar.leapYear.extraDays || 1;
            }
        }
        return monthLengths;
    }
    /**
     * Get length of a specific month in a specific year
     */
    getMonthLength(month, year) {
        const monthLengths = this.getMonthLengths(year);
        return monthLengths[month - 1] || 0;
    }
    /**
     * Get intercalary days that come after a specific month
     */
    getIntercalaryDaysAfterMonth(year, month) {
        const intercalaryDays = this.getIntercalaryDays(year);
        const monthName = this.calendar.months[month - 1]?.name;
        if (!monthName)
            return [];
        return intercalaryDays.filter(intercalary => intercalary.after === monthName);
    }
    /**
     * Get intercalary days that come before a specific month
     */
    getIntercalaryDaysBeforeMonth(year, month) {
        const intercalaryDays = this.getIntercalaryDays(year);
        const monthName = this.calendar.months[month - 1]?.name;
        if (!monthName)
            return [];
        return intercalaryDays.filter(intercalary => intercalary.before === monthName);
    }
    /**
     * Get intercalary days for a specific year
     */
    getIntercalaryDays(year) {
        return this.calendar.intercalary.filter(intercalary => {
            if (intercalary.leapYearOnly) {
                return this.isLeapYear(year);
            }
            return true;
        });
    }
    /**
     * Check if a year is a leap year
     */
    isLeapYear(year) {
        const leapYear = this.calendar.leapYear;
        if (!leapYear)
            return false;
        const { rule, interval } = leapYear;
        switch (rule) {
            case 'none':
                return false;
            case 'gregorian':
                return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
            case 'custom':
                return interval ? year % interval === 0 : false;
            default:
                return false;
        }
    }
    /**
     * Precompute year data for performance
     */
    precomputeYearData() {
        const currentYear = this.calendar.year.currentYear;
        // Cache calculations for nearby years
        for (let year = currentYear - 10; year <= currentYear + 10; year++) {
            const cacheKey = `year-${year}`;
            if (!this.calculationCache.has(cacheKey)) {
                const calculation = {
                    totalDays: this.getYearLength(year),
                    weekdayIndex: 0, // Will be calculated when needed
                    yearLength: this.getYearLength(year),
                    monthLengths: this.getMonthLengths(year),
                    intercalaryDays: this.getIntercalaryDays(year),
                };
                this.calculationCache.set(cacheKey, calculation);
            }
        }
    }
    /**
     * Update the calendar configuration
     */
    updateCalendar(calendar) {
        this.calendar = calendar;
        this.calculationCache.clear();
        this.precomputeYearData();
    }
    /**
     * Get the current calendar configuration
     */
    getCalendar() {
        return { ...this.calendar };
    }
    /**
     * Get all moons for Simple Calendar bridge compatibility
     */
    getAllMoons(date) {
        const moons = this.calendar.moons || [];
        if (!date) {
            // Return raw moon definitions if no date provided (legacy behavior)
            return moons;
        }
        // Return calculated moon phases for the specified date
        return moons.map(moon => this.calculateMoonPhaseForDate(moon, date));
    }
    /**
     * Calculate moon phase information for a specific date
     */
    getMoonPhaseInfo(date, moonName) {
        const moons = this.calendar.moons;
        if (!moons || moons.length === 0) {
            return [];
        }
        const targetMoons = moonName ? moons.filter(m => m.name === moonName) : moons;
        return targetMoons.map(moon => this.calculateMoonPhaseForDate(moon, date));
    }
    /**
     * Calculate specific moon phase for a date
     */
    calculateMoonPhaseForDate(moon, date) {
        // Calculate days since reference new moon
        const referenceDate = new CalendarDate({
            year: moon.firstNewMoon.year,
            month: moon.firstNewMoon.month,
            day: moon.firstNewMoon.day,
            weekday: 0, // Will be calculated
        }, this.calendar);
        const daysSinceReference = this.dateToDays(date) - this.dateToDays(referenceDate);
        // Handle negative days (date before reference)
        const adjustedDays = daysSinceReference >= 0
            ? daysSinceReference
            : daysSinceReference +
                Math.ceil(Math.abs(daysSinceReference) / moon.cycleLength) * moon.cycleLength;
        // Calculate position in current cycle
        const dayInCycle = adjustedDays % moon.cycleLength;
        // Find current phase
        let currentPhaseIndex = 0;
        let daysIntoPhase = dayInCycle;
        for (let i = 0; i < moon.phases.length; i++) {
            if (daysIntoPhase < moon.phases[i].length) {
                currentPhaseIndex = i;
                break;
            }
            daysIntoPhase -= moon.phases[i].length;
        }
        const currentPhase = moon.phases[currentPhaseIndex];
        const daysUntilNext = currentPhase.length - daysIntoPhase;
        return {
            moon,
            phase: currentPhase,
            phaseIndex: currentPhaseIndex,
            dayInPhase: Math.floor(daysIntoPhase),
            daysUntilNext: Math.ceil(daysUntilNext),
        };
    }
    /**
     * Get current moon phases based on world time
     */
    getCurrentMoonPhases(worldTime) {
        const fallbackWorldTime = worldTime !== undefined
            ? worldTime
            : typeof game !== 'undefined' && game?.time?.worldTime
                ? game.time.worldTime
                : 0;
        const currentDate = this.worldTimeToDate(fallbackWorldTime);
        return this.getMoonPhaseInfo(currentDate);
    }
    /**
     * Calculate moon phase for a specific world time
     */
    getMoonPhaseAtWorldTime(worldTime, moonName) {
        const date = this.worldTimeToDate(worldTime);
        return this.getMoonPhaseInfo(date, moonName);
    }
}

/**
 * Time conversion and Foundry VTT integration for Seasons & Stars
 */
class TimeConverter {
    constructor(engine) {
        this.lastKnownTime = 0;
        this.lastKnownDate = null;
        this.engine = engine;
        this.registerFoundryHooks();
    }
    /**
     * Register hooks to sync with Foundry's time system
     */
    registerFoundryHooks() {
        // Hook into Foundry's world time updates
        Hooks.on('updateWorldTime', this.onWorldTimeUpdate.bind(this));
        // Hook into initial setup
        Hooks.on('ready', this.onFoundryReady.bind(this));
    }
    /**
     * Handle Foundry ready event
     */
    onFoundryReady() {
        // Initialize with current world time
        if (game.time?.worldTime !== undefined) {
            this.lastKnownTime = game.time.worldTime;
            // Check if this is a new world (worldTime = 0) and we're using Gregorian calendar
            if (this.lastKnownTime === 0 && this.engine.getCalendar().id === 'gregorian') {
                // Set to current real-world date for Gregorian calendar
                this.initializeWithRealWorldDate();
            }
            else {
                const dateResult = this.engine.worldTimeToDate(this.lastKnownTime);
                this.lastKnownDate =
                    dateResult instanceof CalendarDate
                        ? dateResult
                        : new CalendarDate(dateResult, this.engine.getCalendar());
            }
        }
    }
    /**
     * Initialize Gregorian calendar with current real-world date
     */
    async initializeWithRealWorldDate() {
        const now = new Date();
        const realWorldDateData = {
            year: now.getFullYear(),
            month: now.getMonth() + 1, // JavaScript months are 0-indexed
            day: now.getDate(),
            weekday: 0, // Will be calculated by the engine
            time: {
                hour: now.getHours(),
                minute: now.getMinutes(),
                second: now.getSeconds(),
            },
        };
        const realWorldDate = new CalendarDate(realWorldDateData, this.engine.getCalendar());
        Logger.debug('Initializing Gregorian calendar with current date:', realWorldDate);
        // Only set if user is GM (GMs control world time)
        if (game.user?.isGM) {
            try {
                await this.setCurrentDate(realWorldDate);
            }
            catch (error) {
                Logger.warn('Could not initialize with real-world date:', error);
                // Fallback to default behavior
                const dateResult = this.engine.worldTimeToDate(this.lastKnownTime);
                this.lastKnownDate =
                    dateResult instanceof CalendarDate
                        ? dateResult
                        : new CalendarDate(dateResult, this.engine.getCalendar());
            }
        }
        else {
            // For players, just use the default conversion
            const dateResult = this.engine.worldTimeToDate(this.lastKnownTime);
            this.lastKnownDate =
                dateResult instanceof CalendarDate
                    ? dateResult
                    : new CalendarDate(dateResult, this.engine.getCalendar());
        }
    }
    /**
     * Handle world time updates from Foundry
     */
    onWorldTimeUpdate(newTime, delta) {
        this.lastKnownTime = newTime;
        // Allow system-specific integrations to provide world creation timestamp
        let worldCreationTimestamp;
        try {
            const timestamp = compatibilityManager.getSystemData(game.system.id, 'worldCreationTimestamp');
            worldCreationTimestamp = timestamp ?? undefined;
        }
        catch (error) {
            Logger.warn(`Error getting world creation timestamp for ${game.system.id}:`, error);
            // Continue with undefined worldCreationTimestamp
        }
        const dateResult = this.engine.worldTimeToDate(newTime, worldCreationTimestamp);
        this.lastKnownDate =
            dateResult instanceof CalendarDate
                ? dateResult
                : new CalendarDate(dateResult, this.engine.getCalendar());
        // Emit custom hook for other modules
        Hooks.callAll('seasons-stars:dateChanged', {
            newDate: this.lastKnownDate,
            oldTime: newTime - delta,
            newTime: newTime,
            delta: delta,
        });
    }
    /**
     * Get the current calendar date based on Foundry world time
     */
    getCurrentDate() {
        const worldTime = game.time?.worldTime || 0;
        // Get world creation timestamp from system-specific integrations
        let worldCreationTimestamp;
        try {
            const timestamp = compatibilityManager.getSystemData(game.system.id, 'worldCreationTimestamp');
            worldCreationTimestamp = timestamp ?? undefined;
            if (worldCreationTimestamp) {
                Logger.debug(`Using world creation timestamp for ${game.system.id}: ${worldCreationTimestamp}`);
            }
        }
        catch (error) {
            Logger.warn(`Error getting world creation timestamp for ${game.system.id}:`, error);
            // Continue with undefined worldCreationTimestamp
        }
        const result = this.engine.worldTimeToDate(worldTime, worldCreationTimestamp);
        // If the engine returns a CalendarDate instance, use it directly
        if (result instanceof CalendarDate) {
            return result;
        }
        // Otherwise, create a new instance from the data
        return new CalendarDate(result, this.engine.getCalendar());
    }
    /**
     * Set the current date by updating Foundry world time
     */
    async setCurrentDate(date) {
        // Apply system-specific time offset when converting date to worldTime
        let systemTimeOffset;
        try {
            const transform = compatibilityManager.getSystemData(game.system.id, 'worldTimeTransform');
            if (transform) {
                // Get the system time offset for date conversion
                [, systemTimeOffset] = transform(0);
            }
        }
        catch (error) {
            Logger.warn(`Error getting ${game.system.id} system time offset for date setting:`, error);
        }
        const worldTime = this.engine.dateToWorldTime(date, systemTimeOffset);
        if (game.user?.isGM) {
            await game.time?.advance(worldTime - (game.time?.worldTime || 0));
        }
        else {
            ui.notifications?.warn('Only GMs can change the world time.');
        }
    }
    /**
     * Advance time by a number of days
     */
    async advanceDays(days) {
        const currentDate = this.getCurrentDate();
        const newDate = this.engine.addDays(currentDate, days);
        await this.setCurrentDate(newDate);
    }
    /**
     * Advance time by a number of hours
     */
    async advanceHours(hours) {
        const secondsPerHour = this.engine.getCalendar().time.minutesInHour * this.engine.getCalendar().time.secondsInMinute;
        const deltaSeconds = hours * secondsPerHour;
        if (game.user?.isGM) {
            await game.time?.advance(deltaSeconds);
        }
        else {
            ui.notifications?.warn('Only GMs can change the world time.');
        }
    }
    /**
     * Advance time by a number of minutes
     */
    async advanceMinutes(minutes) {
        const deltaSeconds = minutes * this.engine.getCalendar().time.secondsInMinute;
        if (game.user?.isGM) {
            await game.time?.advance(deltaSeconds);
        }
        else {
            ui.notifications?.warn('Only GMs can change the world time.');
        }
    }
    /**
     * Advance time by a number of seconds
     */
    async advanceSeconds(seconds) {
        if (game.user?.isGM) {
            await game.time?.advance(seconds);
        }
        else {
            ui.notifications?.warn('Only GMs can change the world time.');
        }
    }
    /**
     * Advance time by a number of weeks
     */
    async advanceWeeks(weeks) {
        const currentDate = this.getCurrentDate();
        const weekLength = this.engine.getCalendar().weekdays.length;
        const days = weeks * weekLength; // Convert weeks to days using dynamic week length
        const newDate = this.engine.addDays(currentDate, days);
        await this.setCurrentDate(newDate);
    }
    /**
     * Advance time by a number of months
     */
    async advanceMonths(months) {
        const currentDate = this.getCurrentDate();
        const newDate = this.engine.addMonths(currentDate, months);
        await this.setCurrentDate(newDate);
    }
    /**
     * Advance time by a number of years
     */
    async advanceYears(years) {
        const currentDate = this.getCurrentDate();
        const newDate = this.engine.addYears(currentDate, years);
        await this.setCurrentDate(newDate);
    }
    /**
     * Set a specific time of day while keeping the date
     */
    async setTimeOfDay(hour, minute = 0, second = 0) {
        const currentDate = this.getCurrentDate();
        const currentDateData = currentDate.toObject();
        // Update the time component
        currentDateData.time = { hour, minute, second };
        // Create new CalendarDate instance
        const calendar = this.engine.getCalendar();
        const newDate = new CalendarDate(currentDateData, calendar);
        await this.setCurrentDate(newDate);
    }
    /**
     * Get the time as a percentage of the day (0.0 to 1.0)
     */
    getDayProgress() {
        const currentDate = this.getCurrentDate();
        if (!currentDate.time) {
            return 0;
        }
        const calendar = this.engine.getCalendar();
        const totalSecondsInDay = calendar.time.hoursInDay * calendar.time.minutesInHour * calendar.time.secondsInMinute;
        const currentSecondsInDay = currentDate.time.hour * calendar.time.minutesInHour * calendar.time.secondsInMinute +
            currentDate.time.minute * calendar.time.secondsInMinute +
            currentDate.time.second;
        return currentSecondsInDay / totalSecondsInDay;
    }
    /**
     * Check if it's currently daytime (between dawn and dusk by default)
     */
    isDaytime(dawnHour = TIME_CONSTANTS.DEFAULT_DAWN_HOUR, duskHour = TIME_CONSTANTS.DEFAULT_DUSK_HOUR) {
        const currentDate = this.getCurrentDate();
        if (!currentDate.time) {
            return true; // Default to daytime if no time component
        }
        return currentDate.time.hour >= dawnHour && currentDate.time.hour < duskHour;
    }
    /**
     * Get the current season (0-3 for spring, summer, autumn, winter)
     * This is a simple implementation - can be enhanced later
     */
    getCurrentSeason() {
        const currentDate = this.getCurrentDate();
        const calendar = this.engine.getCalendar();
        // Simple approximation: divide year into 4 equal seasons
        const monthsPerSeason = calendar.months.length / 4;
        return Math.floor((currentDate.month - 1) / monthsPerSeason);
    }
    /**
     * Calculate the difference between two dates in days
     */
    daysBetween(date1, date2) {
        const time1 = this.engine.dateToWorldTime(date1);
        const time2 = this.engine.dateToWorldTime(date2);
        const secondsPerDay = this.engine.getCalendar().time.hoursInDay *
            this.engine.getCalendar().time.minutesInHour *
            this.engine.getCalendar().time.secondsInMinute;
        return Math.floor((time2 - time1) / secondsPerDay);
    }
    /**
     * Convert real-world time to game time based on time ratio
     */
    realTimeToGameTime(realSeconds, timeRatio = 1) {
        return realSeconds * timeRatio;
    }
    /**
     * Convert game time to real-world time based on time ratio
     */
    gameTimeToRealTime(gameSeconds, timeRatio = 1) {
        return gameSeconds / timeRatio;
    }
    /**
     * Schedule a callback for a specific calendar date
     */
    scheduleCallback(targetDate, callback) {
        const targetTime = this.engine.dateToWorldTime(targetDate);
        const currentTime = game.time?.worldTime || 0;
        if (targetTime <= currentTime) {
            // Target is in the past or now, execute immediately
            callback();
            return;
        }
        // Set up a one-time hook to watch for the target time
        const hookId = Hooks.on('updateWorldTime', (newTime) => {
            if (newTime >= targetTime) {
                callback();
                Hooks.off('updateWorldTime', hookId);
            }
        });
    }
    /**
     * Update the calendar engine (when calendar configuration changes)
     */
    updateEngine(engine) {
        this.engine = engine;
        // Recalculate current date with new calendar
        if (game.time?.worldTime !== undefined) {
            this.lastKnownTime = game.time.worldTime;
            const dateResult = this.engine.worldTimeToDate(this.lastKnownTime);
            this.lastKnownDate =
                dateResult instanceof CalendarDate
                    ? dateResult
                    : new CalendarDate(dateResult, this.engine.getCalendar());
        }
    }
    /**
     * Get debug information about time conversion
     */
    getDebugInfo() {
        const currentDate = this.getCurrentDate();
        const worldTime = game.time?.worldTime || 0;
        return {
            worldTime,
            calendarDate: currentDate,
            formattedDate: currentDate.toLongString(),
            dayProgress: this.getDayProgress(),
            isDaytime: this.isDaytime(),
            season: this.getCurrentSeason(),
            lastKnownTime: this.lastKnownTime,
            lastKnownDate: this.lastKnownDate,
        };
    }
}

/**
 * Calendar JSON format validation for Seasons & Stars using JSON schemas
 */
// Lazy-loaded AJV instances to avoid module resolution issues
let ajvInstance = null;
let validateCalendar = null;
let validateVariants = null;
let validateCollection = null;
async function getAjvValidators() {
    if (!ajvInstance) {
        // Dynamic import to handle different AJV versions
        const Ajv = (await Promise.resolve().then(function () { return ajv$2; })).default;
        ajvInstance = new Ajv({ allErrors: true, verbose: true });
        try {
            const addFormats = (await Promise.resolve().then(function () { return index$1; })).default;
            addFormats(ajvInstance);
        }
        catch {
            // ajv-formats is optional
            console.warn('ajv-formats not available, some validations may be limited');
        }
        // Load schemas based on environment
        let calendarSchema, variantsSchema, collectionSchema;
        if (typeof window !== 'undefined' &&
            typeof game !== 'undefined' &&
            game.modules?.get('seasons-and-stars')) {
            // Browser environment with FoundryVTT - use module paths
            const moduleId = 'seasons-and-stars';
            const basePath = `modules/${moduleId}/schemas`;
            [calendarSchema, variantsSchema, collectionSchema] = await Promise.all([
                fetch(`${basePath}/calendar-v1.0.0.json`).then(r => r.json()),
                fetch(`${basePath}/calendar-variants-v1.0.0.json`).then(r => r.json()),
                fetch(`${basePath}/calendar-collection-v1.0.0.json`).then(r => r.json()),
            ]);
        }
        else {
            // Node.js environment or test environment - use filesystem
            const fs = await import('fs');
            const path = await import('path');
            // Find the project root by looking for shared/schemas directory
            let currentDir = process.cwd();
            while (!fs.existsSync(path.join(currentDir, 'shared', 'schemas'))) {
                const parentDir = path.dirname(currentDir);
                if (parentDir === currentDir) {
                    throw new Error('Could not find project root (shared/schemas not found)');
                }
                currentDir = parentDir;
            }
            const schemasDir = path.join(currentDir, 'shared', 'schemas');
            [calendarSchema, variantsSchema, collectionSchema] = await Promise.all([
                JSON.parse(fs.readFileSync(path.join(schemasDir, 'calendar-v1.0.0.json'), 'utf8')),
                JSON.parse(fs.readFileSync(path.join(schemasDir, 'calendar-variants-v1.0.0.json'), 'utf8')),
                JSON.parse(fs.readFileSync(path.join(schemasDir, 'calendar-collection-v1.0.0.json'), 'utf8')),
            ]);
        }
        // Compile schemas
        validateCalendar = ajvInstance.compile(calendarSchema);
        validateVariants = ajvInstance.compile(variantsSchema);
        validateCollection = ajvInstance.compile(collectionSchema);
    }
    return { validateCalendar, validateVariants, validateCollection };
}
class CalendarValidator {
    /**
     * Validate a complete calendar configuration using JSON schema
     */
    static async validate(calendar) {
        const result = {
            isValid: true,
            errors: [],
            warnings: [],
        };
        // Check if input is an object
        if (!calendar || typeof calendar !== 'object') {
            result.errors.push('Calendar must be a valid object');
            result.isValid = false;
            return result;
        }
        try {
            // Get validators
            const validators = await getAjvValidators();
            // Determine schema type based on structure
            let validator;
            let schemaType;
            if (calendar.baseCalendar && calendar.variants) {
                // External variants file
                validator = validators.validateVariants;
                schemaType = 'variants';
            }
            else if (calendar.calendars && Array.isArray(calendar.calendars)) {
                // Collection index file
                validator = validators.validateCollection;
                schemaType = 'collection';
            }
            else {
                // Regular calendar file
                validator = validators.validateCalendar;
                schemaType = 'calendar';
            }
            // Run JSON schema validation
            const isValid = validator(calendar);
            if (!isValid && validator.errors) {
                // Convert AJV errors to our format
                for (const error of validator.errors) {
                    const path = error.instancePath ? error.instancePath : 'root';
                    const message = error.message || 'Validation error';
                    result.errors.push(`${path}: ${message}`);
                }
            }
            // Add additional custom validations for calendar files
            if (schemaType === 'calendar') {
                this.validateCalendarSpecific(calendar, result);
            }
            else if (schemaType === 'variants') {
                this.validateVariantsSpecific(calendar, result);
            }
            // Add warnings for date formats
            this.validateDateFormats(calendar, result);
            result.isValid = result.errors.length === 0;
            return result;
        }
        catch (error) {
            // Fallback to non-schema validation if AJV fails
            console.warn('Schema validation failed, falling back to legacy validation:', error);
            return this.validateLegacy(calendar);
        }
    }
    /**
     * Fallback validation method that doesn't use JSON schemas
     */
    static validateLegacy(calendar) {
        const result = {
            isValid: true,
            errors: [],
            warnings: [],
        };
        // Basic structural validation
        if (!calendar.id || typeof calendar.id !== 'string') {
            result.errors.push('Calendar must have a valid id string');
        }
        if (calendar.baseCalendar && calendar.variants) {
            // Variants file validation
            if (typeof calendar.baseCalendar !== 'string') {
                result.errors.push('baseCalendar must be a string');
            }
            if (!calendar.variants || typeof calendar.variants !== 'object') {
                result.errors.push('variants must be an object');
            }
        }
        else {
            // Regular calendar validation
            if (!calendar.translations || typeof calendar.translations !== 'object') {
                result.errors.push('Calendar must have translations object');
            }
            if (!Array.isArray(calendar.months)) {
                result.errors.push('Calendar must have months array');
            }
            if (!Array.isArray(calendar.weekdays)) {
                result.errors.push('Calendar must have weekdays array');
            }
        }
        this.validateDateFormats(calendar, result);
        this.validateCrossReferences(calendar, result);
        result.isValid = result.errors.length === 0;
        return result;
    }
    /**
     * Additional calendar-specific validations not covered by JSON schema
     */
    static validateCalendarSpecific(calendar, result) {
        // Cross-reference validations for calendar files
        this.validateCrossReferences(calendar, result);
    }
    /**
     * Additional variants-specific validations not covered by JSON schema
     */
    static validateVariantsSpecific(_calendar, _result) {
        // Add any variants-specific cross-reference validations here
        // Currently, the JSON schema handles most validation
    }
    // Note: Most validation is now handled by JSON schemas above
    /**
     * Validate date formats and enforce reasonable limits
     *
     * Design Decision: Limit date formats to prevent memory issues
     *
     * Rationale:
     * - Real-world calendars use 10-25 date formats maximum
     * - Template cache in DateFormatter has no runtime limits for performance
     * - Better to prevent excessive formats at source than manage complex cache eviction
     * - Foundry sessions last 2-4 hours then browser refresh clears cache anyway
     */
    static validateDateFormats(calendar, result) {
        if (!calendar.dateFormats || typeof calendar.dateFormats !== 'object') {
            return; // dateFormats is optional
        }
        const dateFormats = calendar.dateFormats;
        let totalFormatCount = 0;
        const maxFormats = 100; // Generous limit - real calendars use ~25 max
        // Count top-level formats
        for (const [key, value] of Object.entries(dateFormats)) {
            if (key === 'widgets') {
                // Handle widgets separately
                if (typeof value === 'object' && value !== null) {
                    const widgetCount = Object.keys(value).length;
                    totalFormatCount += widgetCount;
                    if (widgetCount > 20) {
                        result.warnings.push(`Widget formats (${widgetCount}) should be limited for performance (recommended max: 20)`);
                    }
                }
            }
            else if (typeof value === 'string') {
                // Simple format
                totalFormatCount += 1;
            }
            else if (typeof value === 'object' && value !== null) {
                // Variant format object
                const variantCount = Object.keys(value).length;
                totalFormatCount += variantCount;
                if (variantCount > 30) {
                    result.warnings.push(`Format variants for '${key}' (${variantCount}) should be limited for performance (recommended max: 30)`);
                }
            }
        }
        // Check total count
        if (totalFormatCount > maxFormats) {
            result.warnings.push(`Total date formats (${totalFormatCount}) exceeds recommended limit (${maxFormats}). ` +
                `Consider reducing formats to prevent potential memory issues. ` +
                `Real-world calendars typically use 10-25 formats.`);
        }
        else if (totalFormatCount > 50) {
            result.warnings.push(`High number of date formats (${totalFormatCount}). ` +
                `Consider if all formats are necessary for optimal performance.`);
        }
        // Log for debugging/monitoring - only warn for excessive format counts
        if (totalFormatCount > 100) {
            result.warnings.push(`Calendar defines ${totalFormatCount} date formats (consider reducing for performance)`);
        }
    }
    // Note: Constraints are now validated by JSON schemas
    /**
     * Validate cross-references between fields
     */
    static validateCrossReferences(calendar, result) {
        // Check for unique month names
        if (Array.isArray(calendar.months)) {
            const monthNames = calendar.months.map((m) => m.name).filter(Boolean);
            const uniqueNames = new Set(monthNames);
            if (monthNames.length !== uniqueNames.size) {
                result.errors.push('Month names must be unique');
            }
        }
        // Check for unique weekday names
        if (Array.isArray(calendar.weekdays)) {
            const weekdayNames = calendar.weekdays.map((w) => w.name).filter(Boolean);
            const uniqueNames = new Set(weekdayNames);
            if (weekdayNames.length !== uniqueNames.size) {
                result.errors.push('Weekday names must be unique');
            }
        }
        // Validate leap year month reference
        if (calendar.leapYear?.month && Array.isArray(calendar.months)) {
            const monthExists = calendar.months.some((m) => m.name === calendar.leapYear.month);
            if (!monthExists) {
                result.errors.push(`Leap year month '${calendar.leapYear.month}' does not exist in months list`);
            }
        }
        // Validate intercalary day references
        if (Array.isArray(calendar.intercalary) && Array.isArray(calendar.months)) {
            calendar.intercalary.forEach((intercalary, index) => {
                if (intercalary.after) {
                    const monthExists = calendar.months.some((m) => m.name === intercalary.after);
                    if (!monthExists) {
                        result.errors.push(`Intercalary day ${index + 1} references non-existent month '${intercalary.after}'`);
                    }
                }
            });
        }
    }
    /**
     * Validate calendar and provide helpful error messages (synchronous version)
     */
    static validateWithHelp(calendar) {
        // Use legacy validation for synchronous operation
        const result = this.validateLegacy(calendar);
        // Only warn for potential problems, not normal configurations
        // These are optional fields with sensible defaults and shouldn't trigger warnings
        // Only warn for critical missing fields that could cause functionality issues
        // Month abbreviations are optional and have automatic fallbacks
        return result;
    }
    /**
     * Quick validation for just checking if calendar is loadable
     */
    static isValid(calendar) {
        return this.validateWithHelp(calendar).isValid;
    }
    /**
     * Get a list of validation errors as strings
     */
    static getErrors(calendar) {
        return this.validateWithHelp(calendar).errors;
    }
}

/**
 * Calendar localization utilities for Seasons & Stars
 */
class CalendarLocalization {
    /**
     * Get the current language code from Foundry
     */
    static getCurrentLanguage() {
        // Default to English if no game object available (testing)
        if (typeof game === 'undefined')
            return 'en';
        // Use Foundry's language setting
        return game.i18n?.lang || 'en';
    }
    /**
     * Get translated calendar label
     */
    static getCalendarLabel(calendar) {
        const lang = this.getCurrentLanguage();
        // Try current language first
        if (calendar.translations[lang]?.label) {
            return calendar.translations[lang].label;
        }
        // Fall back to English
        if (calendar.translations.en?.label) {
            return calendar.translations.en.label;
        }
        // Last resort: use calendar ID
        return calendar.id;
    }
    /**
     * Get translated calendar description
     */
    static getCalendarDescription(calendar) {
        const lang = this.getCurrentLanguage();
        // Try current language first
        if (calendar.translations[lang]?.description) {
            return calendar.translations[lang].description;
        }
        // Fall back to English
        return calendar.translations.en?.description;
    }
    /**
     * Get translated calendar setting
     */
    static getCalendarSetting(calendar) {
        const lang = this.getCurrentLanguage();
        // Try current language first
        if (calendar.translations[lang]?.setting) {
            return calendar.translations[lang].setting;
        }
        // Fall back to English
        return calendar.translations.en?.setting;
    }
    /**
     * Get translated month description
     */
    static getMonthDescription(month) {
        const lang = this.getCurrentLanguage();
        // Try translated description first
        if (month.translations?.[lang]?.description) {
            return month.translations[lang].description;
        }
        // Fall back to English translation
        if (month.translations?.en?.description) {
            return month.translations.en.description;
        }
        // Fall back to base description
        return month.description;
    }
    /**
     * Get translated weekday description
     */
    static getWeekdayDescription(weekday) {
        const lang = this.getCurrentLanguage();
        // Try translated description first
        if (weekday.translations?.[lang]?.description) {
            return weekday.translations[lang].description;
        }
        // Fall back to English translation
        if (weekday.translations?.en?.description) {
            return weekday.translations.en.description;
        }
        // Fall back to base description
        return weekday.description;
    }
    /**
     * Get translated intercalary description
     */
    static getIntercalaryDescription(intercalary) {
        const lang = this.getCurrentLanguage();
        // Try translated description first
        if (intercalary.translations?.[lang]?.description) {
            return intercalary.translations[lang].description;
        }
        // Fall back to English translation
        if (intercalary.translations?.en?.description) {
            return intercalary.translations.en.description;
        }
        // Fall back to base description
        return intercalary.description;
    }
    /**
     * Get all available languages for a calendar
     */
    static getAvailableLanguages(calendar) {
        return Object.keys(calendar.translations);
    }
    /**
     * Check if a calendar has translations for a specific language
     */
    static hasLanguage(calendar, language) {
        return language in calendar.translations;
    }
    /**
     * Create a localized calendar object for UI display
     */
    static getLocalizedCalendarInfo(calendar) {
        return {
            id: calendar.id,
            label: this.getCalendarLabel(calendar),
            description: this.getCalendarDescription(calendar) || '',
            setting: this.getCalendarSetting(calendar) || '',
            availableLanguages: this.getAvailableLanguages(calendar),
            currentLanguage: this.getCurrentLanguage(),
        };
    }
    /**
     * Get translated name for a calendar element (month, weekday, etc.)
     */
    static getCalendarTranslation(calendar, path, fallback) {
        const lang = this.getCurrentLanguage();
        const pathParts = path.split('.');
        if (pathParts.length !== 2) {
            return fallback;
        }
        const [type, id] = pathParts;
        // Try current language first
        if (calendar.translations[lang]) {
            const translation = calendar.translations[lang][type];
            if (translation && typeof translation === 'object' && id in translation) {
                return translation[id];
            }
        }
        // Fall back to English
        if (calendar.translations.en) {
            const translation = calendar.translations.en[type];
            if (translation && typeof translation === 'object' && id in translation) {
                return translation[id];
            }
        }
        // Last resort: use fallback
        return fallback;
    }
    /**
     * Create settings choices for calendar selection with hierarchical organization
     */
    static createCalendarChoices(calendars) {
        const choices = {};
        // Group calendars by base calendar ID
        const calendarGroups = new Map();
        for (const calendar of calendars) {
            // Check if this is a variant calendar
            const isVariant = calendar.id.includes('(') && calendar.id.includes(')');
            let baseCalendarId = calendar.id;
            if (isVariant) {
                const match = calendar.id.match(/^([^(]+)\(([^)]+)\)$/);
                if (match) {
                    baseCalendarId = match[1];
                }
            }
            // Initialize group if it doesn't exist
            if (!calendarGroups.has(baseCalendarId)) {
                calendarGroups.set(baseCalendarId, { base: null, variants: [] });
            }
            const group = calendarGroups.get(baseCalendarId);
            if (!group)
                continue;
            if (isVariant) {
                group.variants.push(calendar);
            }
            else {
                group.base = calendar;
            }
        }
        // Sort groups with Gregorian first, then alphabetically
        const sortedGroups = Array.from(calendarGroups.entries()).sort(([aId, aGroup], [bId, bGroup]) => {
            // Gregorian calendar always comes first
            if (aId === 'gregorian')
                return -1;
            if (bId === 'gregorian')
                return 1;
            // All other calendars sorted alphabetically by display label
            const labelA = aGroup.base ? this.getCalendarLabel(aGroup.base) : aId;
            const labelB = bGroup.base ? this.getCalendarLabel(bGroup.base) : bId;
            return labelA.localeCompare(labelB);
        });
        // Build choices with hierarchical structure
        for (const [, group] of sortedGroups) {
            // Add base calendar first
            if (group.base) {
                const label = this.getCalendarLabel(group.base);
                const setting = this.getCalendarSetting(group.base);
                const sourceInfo = group.base.sourceInfo;
                let displayLabel = label;
                // For settings dropdown, prioritize showing source over setting to avoid redundancy
                if (sourceInfo && sourceInfo.type !== 'builtin') {
                    displayLabel += ` - ${sourceInfo.sourceName}`;
                }
                else if (setting) {
                    displayLabel += ` (${setting})`;
                }
                choices[group.base.id] = displayLabel;
            }
            // Sort variants alphabetically and add with prefix
            group.variants.sort((a, b) => {
                const labelA = this.getCalendarLabel(a);
                const labelB = this.getCalendarLabel(b);
                return labelA.localeCompare(labelB);
            });
            for (const variant of group.variants) {
                const variantLabel = this.getCalendarLabel(variant);
                const variantSetting = this.getCalendarSetting(variant);
                const sourceInfo = variant.sourceInfo;
                let displayLabel = variantLabel;
                // For settings dropdown, prioritize showing source over setting to avoid redundancy
                if (sourceInfo && sourceInfo.type !== 'builtin') {
                    displayLabel += ` - ${sourceInfo.sourceName}`;
                }
                else if (variantSetting) {
                    displayLabel += ` (${variantSetting})`;
                }
                choices[variant.id] = `— ${displayLabel}`;
            }
        }
        return choices;
    }
}

/**
 * CalendarLoader - Handles loading calendars from external URLs and local sources
 *
 * Extends the existing calendar loading system to support:
 * - URL-based calendar loading with validation
 * - Caching and error handling
 * - CORS and security considerations
 * - Collection and variant loading
 */
/**
 * Calendar loading and caching system for external sources
 */
class CalendarLoader {
    constructor() {
        this.sources = new Map();
        this.loadSourcesFromStorage();
    }
    /**
     * Load a calendar from a URL
     */
    async loadFromUrl(url, options = {}) {
        Logger.debug(`CalendarLoader: Loading calendar from URL: ${url}`);
        // Validate URL format
        const urlValidation = this.validateUrl(url);
        if (!urlValidation.valid) {
            return {
                success: false,
                error: urlValidation.error,
                sourceUrl: url,
            };
        }
        try {
            // Perform the fetch request
            const response = await this.fetchWithTimeout(url, {
                timeout: options.timeout || CalendarLoader.DEFAULT_TIMEOUT,
                headers: {
                    Accept: 'application/json',
                    // Note: Content-Type not needed for GET requests and causes CORS issues
                    ...options.headers,
                },
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const calendarData = await response.json();
            // Validate the calendar if requested
            let validation;
            if (options.validate !== false) {
                validation = await CalendarValidator.validate(calendarData);
                if (!validation.isValid) {
                    return {
                        success: false,
                        error: `Calendar validation failed: ${validation.errors.join(', ')}`,
                        validation,
                        sourceUrl: url,
                    };
                }
            }
            Logger.info(`CalendarLoader: Successfully loaded calendar from ${url}`);
            return {
                success: true,
                calendar: calendarData,
                validation,
                sourceUrl: url,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            Logger.error(`CalendarLoader: Failed to load calendar from ${url}`, error);
            return {
                success: false,
                error: errorMessage,
                sourceUrl: url,
            };
        }
    }
    /**
     * Load multiple calendars from a collection URL
     */
    async loadCollection(url, options = {}) {
        Logger.debug(`CalendarLoader: Loading calendar collection from URL: ${url}`);
        const collectionResult = await this.loadFromUrl(url, {
            ...options,
            validate: false, // Don't validate collection structure with calendar schema
        });
        if (!collectionResult.success || !collectionResult.calendar) {
            return [collectionResult];
        }
        const collection = collectionResult.calendar;
        // Validate collection structure
        if (!collection.calendars || !Array.isArray(collection.calendars)) {
            return [
                {
                    success: false,
                    error: 'Invalid collection format: missing or invalid calendars array',
                    sourceUrl: url,
                },
            ];
        }
        // Load each calendar in the collection
        const results = [];
        for (const calendarEntry of collection.calendars) {
            // Check for URL in entry (either absolute URL or relative file path)
            const calendarUrl = calendarEntry.url || calendarEntry.file;
            if (!calendarUrl) {
                results.push({
                    success: false,
                    error: `Calendar entry missing URL or file: ${JSON.stringify(calendarEntry)}`,
                    sourceUrl: url,
                    collectionEntry: calendarEntry,
                });
                continue;
            }
            // Resolve relative URLs against the collection base URL
            const resolvedUrl = this.resolveUrl(calendarUrl, url);
            // Detect external variant files by ID pattern and skip validation for them
            const isVariantFile = calendarEntry.id && calendarEntry.id.includes('-variants');
            const loadOptions = {
                ...options,
                validate: isVariantFile ? false : options.validate !== false,
            };
            const result = await this.loadFromUrl(resolvedUrl, loadOptions);
            // Add collection entry metadata to the result with sanitized preview
            if (result.success) {
                const sanitizedEntry = { ...calendarEntry };
                if (sanitizedEntry.preview) {
                    sanitizedEntry.preview = this.sanitizeHTML(sanitizedEntry.preview);
                }
                result.collectionEntry = sanitizedEntry;
            }
            results.push(result);
        }
        return results;
    }
    /**
     * Add an external calendar source
     */
    addSource(source) {
        const id = this.generateSourceId(source.name);
        const fullSource = {
            ...source,
            id,
        };
        this.sources.set(id, fullSource);
        this.saveSourcesToStorage();
        Logger.info(`CalendarLoader: Added external source: ${fullSource.name} (${fullSource.url})`);
        return id;
    }
    /**
     * Remove an external calendar source
     */
    removeSource(id) {
        const source = this.sources.get(id);
        if (!source) {
            return false;
        }
        this.sources.delete(id);
        this.saveSourcesToStorage();
        Logger.info(`CalendarLoader: Removed external source: ${source.name}`);
        return true;
    }
    /**
     * Get all external sources
     */
    getSources() {
        return Array.from(this.sources.values());
    }
    /**
     * Get a specific source by ID
     */
    getSource(id) {
        return this.sources.get(id);
    }
    /**
     * Update the status of an external source after a load attempt
     */
    updateSourceStatus(id, success, error) {
        const source = this.sources.get(id);
        if (!source) {
            return;
        }
        if (success) {
            source.lastLoaded = Date.now();
            source.lastError = undefined;
        }
        else {
            source.lastError = error;
        }
        this.sources.set(id, source);
        this.saveSourcesToStorage();
    }
    /**
     * Validate URL format and security
     */
    validateUrl(url) {
        try {
            // Handle module:// protocol specially
            if (url.startsWith('module:')) {
                return this.validateModuleUrl(url);
            }
            const parsed = new URL(url);
            // Only allow HTTP/HTTPS protocols for external URLs
            if (!['http:', 'https:'].includes(parsed.protocol)) {
                return {
                    valid: false,
                    error: `Unsupported protocol: ${parsed.protocol}. Only HTTP, HTTPS, and module: are allowed.`,
                };
            }
            // Recommend HTTPS for security
            if (parsed.protocol === 'http:' && parsed.hostname !== 'localhost') {
                Logger.warn(`CalendarLoader: Non-HTTPS URL detected: ${url}. HTTPS is recommended for security.`);
            }
            return { valid: true };
        }
        catch (error) {
            return {
                valid: false,
                error: `Invalid URL format: ${error instanceof Error ? error.message : 'Unknown error'}`,
            };
        }
    }
    /**
     * Validate module:// URL format
     */
    validateModuleUrl(url) {
        // Extract module ID from either simple or full format
        let moduleId;
        const simpleMatch = url.match(/^module:([a-z0-9-]+)$/);
        const fullMatch = url.match(/^module:([a-z0-9-]+)\/(.+)$/);
        if (simpleMatch) {
            moduleId = simpleMatch[1];
        }
        else if (fullMatch) {
            moduleId = fullMatch[1];
        }
        else {
            return {
                valid: false,
                error: 'Invalid module URL format. Expected: module:module-id or module:module-id/path',
            };
        }
        const module = game.modules.get(moduleId);
        if (!module) {
            return {
                valid: false,
                error: `Module '${moduleId}' not found`,
            };
        }
        if (!module.active) {
            return {
                valid: false,
                error: `Module '${moduleId}' is not active`,
            };
        }
        return { valid: true };
    }
    /**
     * Resolve module:// URLs to actual file paths
     */
    resolveModuleUrl(moduleUrl) {
        // Handle simple module:module-name format (defaults to calendars/index.json)
        const simpleMatch = moduleUrl.match(/^module:([a-z0-9-]+)$/);
        if (simpleMatch) {
            const [, moduleId] = simpleMatch;
            return `modules/${moduleId}/calendars/index.json`;
        }
        // Handle full module:module-name/path format
        const fullMatch = moduleUrl.match(/^module:([a-z0-9-]+)\/(.+)$/);
        if (!fullMatch) {
            throw new Error('Invalid module URL format. Expected: module:module-id or module:module-id/path');
        }
        const [, moduleId, path] = fullMatch;
        // Convert to actual file path - append index.json if path doesn't end with .json
        const fullPath = path.endsWith('.json') ? path : `${path}/index.json`;
        return `modules/${moduleId}/${fullPath}`;
    }
    /**
     * Fetch with timeout support
     */
    async fetchWithTimeout(url, options) {
        // Handle module URLs by converting to local file paths
        if (url.startsWith('module:')) {
            const localPath = this.resolveModuleUrl(url);
            Logger.debug(`CalendarLoader: Resolving module URL ${url} to ${localPath}`);
            url = localPath;
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), options.timeout);
        try {
            // First attempt: CORS mode with headers
            const response = await fetch(url, {
                signal: controller.signal,
                headers: options.headers,
                mode: 'cors',
            });
            clearTimeout(timeoutId);
            return response;
        }
        catch (corsError) {
            // If CORS fails, try without custom headers (simpler request)
            try {
                Logger.debug(`CORS failed for ${url}, retrying with no-cors mode`);
                const response = await fetch(url, {
                    signal: controller.signal,
                    mode: 'no-cors',
                });
                clearTimeout(timeoutId);
                // no-cors mode returns opaque responses, so we can't read JSON directly
                // This is a limitation - we'd need to use script tag loading for actual data
                if (response.type === 'opaque') {
                    throw new Error('CORS blocked - server does not allow cross-origin requests. Consider using a CORS proxy or hosting the calendar file on a CORS-enabled server.');
                }
                return response;
            }
            catch {
                clearTimeout(timeoutId);
                if (corsError instanceof Error && corsError.name === 'AbortError') {
                    throw new Error(`Request timeout after ${options.timeout}ms`);
                }
                // Throw the original CORS error with helpful message
                throw new Error(`CORS error: ${corsError instanceof Error ? corsError.message : 'Unknown error'}. The server hosting this calendar does not allow cross-origin requests. Consider hosting the file on a CORS-enabled service or using a proxy.`);
            }
        }
    }
    /**
     * Resolve relative URLs against a base URL
     */
    resolveUrl(relativeUrl, baseUrl) {
        try {
            // Handle module URLs specially - only for simple module:name format
            if (baseUrl.startsWith('module:') && !baseUrl.includes('/')) {
                // Extract module ID from base URL (only simple format like module:seasons-and-stars-test-pack)
                const moduleId = baseUrl.replace('module:', '');
                // Construct module URL for the relative file in the calendars directory
                return `module:${moduleId}/calendars/${relativeUrl}`;
            }
            return new URL(relativeUrl, baseUrl).toString();
        }
        catch {
            // If URL construction fails, assume it's already absolute
            return relativeUrl;
        }
    }
    /**
     * Generate a unique source ID
     */
    generateSourceId(name) {
        const base = name
            .toLowerCase()
            .replace(/[^a-z0-9]/g, '-')
            .replace(/-{2,}/g, '-')
            .replace(/^-+|-+$/g, '');
        let id = base;
        let counter = 1;
        while (this.sources.has(id)) {
            id = `${base}-${counter}`;
            counter++;
        }
        return id;
    }
    /**
     * Load sources from persistent storage
     */
    loadSourcesFromStorage() {
        try {
            const stored = game.settings?.get('seasons-and-stars', CalendarLoader.SOURCES_KEY);
            if (stored && Array.isArray(stored)) {
                for (const source of stored) {
                    this.sources.set(source.id, source);
                }
            }
        }
        catch (error) {
            Logger.warn('CalendarLoader: Failed to load sources from storage', error);
        }
    }
    /**
     * Save sources to persistent storage
     */
    saveSourcesToStorage() {
        try {
            const sourcesArray = Array.from(this.sources.values());
            game.settings?.set('seasons-and-stars', CalendarLoader.SOURCES_KEY, sourcesArray);
        }
        catch (error) {
            Logger.warn('CalendarLoader: Failed to save sources to storage', error);
        }
    }
    /**
     * Sanitize HTML content using Foundry's stripScripts method
     */
    sanitizeHTML(html) {
        try {
            // Use Foundry's String.stripScripts method if available
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (typeof String.prototype.stripScripts === 'function') {
                return html.stripScripts();
            }
            // If no Foundry methods available, return the original content
            // This is acceptable for calendar descriptions which are typically safe
            return html;
        }
        catch (error) {
            Logger.warn('CalendarLoader: Failed to sanitize HTML, returning original content', error);
            return html;
        }
    }
}
CalendarLoader.DEFAULT_TIMEOUT = 10000; // 10 seconds
CalendarLoader.SOURCES_KEY = 'seasons-stars.external-sources';

/**
 * Calendar management system for Seasons & Stars
 */
// Calendar list is now loaded dynamically from calendars/index.json
class CalendarManager {
    constructor() {
        this.calendars = new Map();
        this.engines = new Map();
        this.timeConverter = null;
        this.activeCalendarId = null;
        this.calendarLoader = new CalendarLoader();
    }
    /**
     * Initialize the calendar manager synchronously from cached data
     * This method loads only cached calendar data and is used during the init hook
     * to ensure calendars are available immediately for compatibility bridges
     */
    initializeSync() {
        Logger.debug('Initializing Calendar Manager synchronously from cached data');
        // Try to load active calendar from cached settings data
        const savedCalendarId = game.settings?.get('seasons-and-stars', 'activeCalendar');
        const cachedCalendarData = game.settings?.get('seasons-and-stars', 'activeCalendarData');
        if (savedCalendarId && cachedCalendarData && cachedCalendarData.id === savedCalendarId) {
            Logger.debug('Loading calendar synchronously from cached data:', savedCalendarId);
            // Load the calendar into the manager
            const sourceInfo = {
                type: 'builtin',
                sourceName: 'Seasons & Stars',
                description: 'Built-in calendar from cached data',
                icon: 'fa-solid fa-calendar',
            };
            const success = this.loadCalendar(cachedCalendarData, sourceInfo);
            if (success) {
                // Set active calendar synchronously
                const activateSuccess = this.setActiveCalendarSync(savedCalendarId);
                if (activateSuccess) {
                    Logger.debug('Successfully initialized calendar synchronously:', savedCalendarId);
                    return true;
                }
            }
        }
        Logger.debug('No cached calendar data available for synchronous initialization');
        return false;
    }
    /**
     * Initialize the calendar manager
     */
    async initialize() {
        Logger.debug('Initializing Calendar Manager');
        // Load built-in calendars
        await this.loadBuiltInCalendars();
        // Fire hook to allow external modules to register calendars
        this.fireExternalCalendarRegistrationHook();
        // Complete initialization after settings are registered
        await this.completeInitialization();
    }
    /**
     * Complete initialization after settings are registered
     */
    async completeInitialization() {
        Logger.debug('Completing Calendar Manager initialization');
        // Check for file-based calendar first
        const activeCalendarFile = game.settings?.get('seasons-and-stars', 'activeCalendarFile');
        const activeCalendar = game.settings?.get('seasons-and-stars', 'activeCalendar');
        Logger.debug('Settings check:', { activeCalendarFile, activeCalendar });
        // Prioritize file-based calendars - if there's a file path, use it regardless of activeCalendar setting
        if (activeCalendarFile && activeCalendarFile.trim() !== '') {
            // Ensure activeCalendar is cleared if it's set (defensive cleanup)
            if (activeCalendar && activeCalendar.trim() !== '') {
                Logger.debug('Clearing conflicting activeCalendar setting');
                await game.settings?.set('seasons-and-stars', 'activeCalendar', '');
            }
            Logger.debug('Loading calendar from file:', activeCalendarFile);
            // Convert Foundry server path to proper URL for fetching
            const fileUrl = this.convertFoundryPathToUrl(activeCalendarFile);
            Logger.debug('Converted path to URL:', fileUrl);
            // Use existing loadCalendarFromUrl method to load from URL
            const result = await this.loadCalendarFromUrl(fileUrl, { validate: true });
            if (result.success && result.calendar) {
                // Create source info for the file-based calendar
                const fileSourceInfo = {
                    type: 'external',
                    sourceName: 'Custom File',
                    description: `Calendar loaded from ${activeCalendarFile}`,
                    icon: 'fa-solid fa-file',
                    url: fileUrl,
                };
                // Add the calendar to the manager's calendar map
                const loadSuccess = this.loadCalendar(result.calendar, fileSourceInfo);
                if (loadSuccess) {
                    // Set it as active using the proper method, but don't save to activeCalendar setting
                    await this.setActiveCalendar(result.calendar.id, false);
                    Logger.info('Successfully loaded and activated calendar from file:', activeCalendarFile);
                    return;
                }
                else {
                    Logger.error('Failed to load calendar into manager during initialization:', new Error(`Validation failed for ${activeCalendarFile}`));
                    // Continue with regular calendar loading as fallback
                }
            }
            else {
                Logger.warn('Failed to load calendar from file:', result.error);
                ui.notifications?.warn(game.i18n.format('SEASONS_STARS.warnings.calendar_file_failed', {
                    path: activeCalendarFile,
                    error: result.error || 'Unknown error',
                }));
                // Continue with regular calendar loading as fallback
            }
        }
        // Load active calendar from settings
        const savedCalendarId = game.settings?.get('seasons-and-stars', 'activeCalendar');
        const cachedCalendarData = game.settings?.get('seasons-and-stars', 'activeCalendarData');
        // Try to load from cached calendar data first (synchronous)
        if (savedCalendarId && cachedCalendarData && cachedCalendarData.id === savedCalendarId) {
            Logger.debug('Loading calendar synchronously from cached data:', savedCalendarId);
            // Load the calendar into the manager if not already present
            if (!this.calendars.has(savedCalendarId)) {
                const sourceInfo = {
                    type: 'builtin',
                    sourceName: 'Seasons & Stars',
                    description: 'Built-in calendar from cached data',
                    icon: 'fa-solid fa-calendar',
                };
                this.loadCalendar(cachedCalendarData, sourceInfo);
            }
            // Set active calendar synchronously (no settings save needed)
            this.setActiveCalendarSync(savedCalendarId);
        }
        else if (savedCalendarId && this.calendars.has(savedCalendarId)) {
            // Fall back to async loading if calendar is already loaded but not cached
            await this.setActiveCalendar(savedCalendarId);
        }
        else {
            // Default to first available calendar
            const firstCalendarId = this.calendars.keys().next().value;
            if (firstCalendarId) {
                await this.setActiveCalendar(firstCalendarId);
            }
        }
        Logger.debug(`Loaded ${this.calendars.size} calendars`);
    }
    /**
     * Get list of built-in calendar IDs from index.json
     */
    async getBuiltInCalendarList() {
        try {
            const results = await this.loadCalendarCollection('module:seasons-and-stars', {
                validate: false,
            });
            const successfulResults = results.filter(r => r.success);
            return successfulResults.map(r => r.calendar?.id).filter(Boolean);
        }
        catch (error) {
            Logger.error('Failed to load built-in calendar list:', error instanceof Error ? error : new Error(String(error)));
            // Fallback to known calendars
            return ['gregorian'];
        }
    }
    /**
     * Load built-in calendar definitions synchronously for immediate API availability
     * Uses Gregorian defaults as fallback to ensure API works immediately
     */
    loadBuiltInCalendarsSync() {
        Logger.debug('Loading calendars synchronously - ensuring immediate API availability');
        // For immediate API availability, we need at least one working calendar
        // Since we can't import synchronously in browser, let's skip the sync approach
        // and just ensure the async loading happens immediately
        // Start async loading but don't block on it
        this.loadBuiltInCalendars().catch(error => {
            Logger.error('Failed to load calendars asynchronously:', error instanceof Error ? error : new Error(String(error)));
        });
        Logger.debug('Calendar loading initiated asynchronously');
    }
    /**
     * Load built-in calendar definitions
     */
    async loadBuiltInCalendars() {
        const builtInCalendars = await this.getBuiltInCalendarList();
        // First, load all base calendars (excluding external variant files)
        for (const calendarId of builtInCalendars) {
            // Skip external variant files - they'll be loaded separately
            if (calendarId.includes('-variants')) {
                continue;
            }
            try {
                // Load from module's calendars directory using CalendarLoader
                const result = await this.calendarLoader.loadFromUrl(`module:seasons-and-stars/calendars/${calendarId}.json`, {
                    validate: true, // Keep validation for built-in calendars
                });
                if (result.success && result.calendar) {
                    // Tag built-in calendars with source info
                    const builtinSourceInfo = {
                        type: 'builtin',
                        sourceName: 'Seasons & Stars',
                        description: 'Calendar included with Seasons & Stars',
                        icon: 'fa-solid fa-calendar',
                        url: `module:seasons-and-stars/calendars/${calendarId}.json`,
                    };
                    this.loadCalendar(result.calendar, builtinSourceInfo);
                }
                else {
                    Logger.warn(`Could not load built-in calendar: ${calendarId}`, result.error);
                }
            }
            catch (error) {
                Logger.error(`Error loading calendar ${calendarId}`, error);
            }
        }
        // Then, load external variant files
        await this.loadExternalVariantFiles();
        // Auto-detect and load calendar pack modules
        await this.autoLoadCalendarPacks();
    }
    /**
     * Load a calendar from data
     */
    loadCalendar(calendarData, sourceInfo) {
        // Check for duplicate calendar ID and skip if already loaded
        if (this.calendars.has(calendarData.id)) {
            Logger.debug(`Calendar ${calendarData.id} already loaded, skipping duplicate`);
            return true; // Return true since the calendar exists and is usable
        }
        // Validate the calendar data (using synchronous legacy validation for performance)
        const validation = CalendarValidator.validateWithHelp(calendarData);
        if (!validation.isValid) {
            Logger.error(`Invalid calendar data for ${calendarData.id}: ${validation.errors.join(', ')}`);
            return false;
        }
        // Warn about potential issues
        if (validation.warnings.length > 0) {
            Logger.debug(`Calendar info for ${calendarData.id}: ${validation.warnings.join(', ')}`);
        }
        // Set source information if provided
        if (sourceInfo) {
            calendarData.sourceInfo = sourceInfo;
        }
        // Store the base calendar
        this.calendars.set(calendarData.id, calendarData);
        // Create engine for base calendar with error handling
        let engine;
        try {
            engine = new CalendarEngine(calendarData);
            this.engines.set(calendarData.id, engine);
        }
        catch (error) {
            // Remove calendar entry if engine creation fails
            this.calendars.delete(calendarData.id);
            Logger.error(`Failed to create calendar engine for ${calendarData.id}:`, error instanceof Error ? error : new Error(String(error)));
            return false;
        }
        // Expand variants if they exist
        if (calendarData.variants) {
            this.expandCalendarVariants(calendarData);
        }
        const label = CalendarLocalization.getCalendarLabel(calendarData);
        Logger.debug(`Loaded calendar: ${label} (${calendarData.id})`);
        return true;
    }
    /**
     * Set the active calendar synchronously (calendars must already be loaded)
     */
    setActiveCalendarSync(calendarId) {
        Logger.debug(`Setting active calendar synchronously: ${calendarId}`);
        // Resolve default variant if setting base calendar with variants
        const resolvedCalendarId = this.resolveDefaultVariant(calendarId);
        // Check if calendar exists (should be loaded already from init hook)
        if (!this.calendars.has(resolvedCalendarId)) {
            Logger.error(`Calendar not found: ${resolvedCalendarId}`);
            return false;
        }
        // Get the engine for this calendar
        const engine = this.engines.get(resolvedCalendarId);
        if (!engine) {
            Logger.error(`Engine not found for calendar: ${resolvedCalendarId}`);
            return false;
        }
        // Store old calendar ID for hook
        const oldCalendarId = this.activeCalendarId;
        // Update or create time converter
        if (this.timeConverter) {
            this.timeConverter.updateEngine(engine);
        }
        else {
            this.timeConverter = new TimeConverter(engine);
        }
        // Update active calendar
        this.activeCalendarId = resolvedCalendarId;
        // Note: Synchronous method doesn't save to settings since world settings
        // can't be saved during init hook - only the async version saves settings
        // Get calendar data for hook
        const calendarData = this.calendars.get(resolvedCalendarId);
        // Fire calendar changed event
        Hooks.callAll('seasons-stars:calendarChanged', {
            oldCalendarId,
            newCalendarId: resolvedCalendarId,
            calendar: calendarData,
        });
        Logger.debug(`Active calendar set synchronously: ${resolvedCalendarId}`);
        return true;
    }
    /**
     * Set the active calendar
     * @param calendarId The calendar ID to set as active
     * @param saveToSettings Whether to save the calendar ID to settings (default: true)
     */
    async setActiveCalendar(calendarId, saveToSettings = true) {
        // Resolve default variant if setting base calendar with variants
        const resolvedCalendarId = this.resolveDefaultVariant(calendarId);
        if (!this.calendars.has(resolvedCalendarId)) {
            Logger.error(`Calendar not found: ${resolvedCalendarId}`);
            return false;
        }
        this.activeCalendarId = resolvedCalendarId;
        // Update time converter with new engine
        const engine = this.engines.get(resolvedCalendarId);
        if (!engine) {
            Logger.error(`Engine not found for calendar: ${resolvedCalendarId}`);
            return false;
        }
        if (this.timeConverter) {
            this.timeConverter.updateEngine(engine);
        }
        else {
            this.timeConverter = new TimeConverter(engine);
        }
        // Save to settings only if requested (skip for file-based calendars to avoid mutual exclusion)
        if (saveToSettings && game.settings) {
            await game.settings.set('seasons-and-stars', 'activeCalendar', resolvedCalendarId);
            // Also store the full calendar JSON for synchronous loading
            const calendarData = this.calendars.get(resolvedCalendarId);
            if (calendarData) {
                await game.settings.set('seasons-and-stars', 'activeCalendarData', calendarData);
                Logger.debug(`Cached calendar data for ${resolvedCalendarId} in settings`);
            }
        }
        // Emit hook for calendar change
        Hooks.callAll('seasons-stars:calendarChanged', {
            newCalendarId: resolvedCalendarId,
            calendar: this.calendars.get(resolvedCalendarId),
        });
        Logger.debug(`Active calendar set to: ${resolvedCalendarId}`);
        return true;
    }
    /**
     * Get the active calendar
     */
    getActiveCalendar() {
        if (!this.activeCalendarId)
            return null;
        return this.calendars.get(this.activeCalendarId) || null;
    }
    /**
     * Get the active calendar engine
     */
    getActiveEngine() {
        if (!this.activeCalendarId)
            return null;
        return this.engines.get(this.activeCalendarId) || null;
    }
    /**
     * Get the active calendar ID
     */
    getActiveCalendarId() {
        return this.activeCalendarId;
    }
    /**
     * Get the time converter
     */
    getTimeConverter() {
        return this.timeConverter;
    }
    /**
     * Get all available calendar IDs
     */
    getAvailableCalendars() {
        return Array.from(this.calendars.values());
    }
    /**
     * Get all calendar objects
     */
    getAllCalendars() {
        return Array.from(this.calendars.values());
    }
    /**
     * Get calendar data by ID
     */
    getCalendar(calendarId) {
        return this.calendars.get(calendarId) || null;
    }
    /**
     * Import a calendar from JSON file
     */
    async importCalendarFromFile(file) {
        try {
            const text = await file.text();
            const calendarData = JSON.parse(text);
            return this.loadCalendar(calendarData);
        }
        catch (error) {
            Logger.error('Error importing calendar', error);
            ui.notifications?.error(`Failed to import calendar: ${error.message}`);
            return false;
        }
    }
    /**
     * Export a calendar to JSON
     */
    exportCalendar(calendarId) {
        const calendar = this.calendars.get(calendarId);
        if (!calendar) {
            Logger.error(`Calendar not found for export: ${calendarId}`);
            return null;
        }
        try {
            return JSON.stringify(calendar, null, 2);
        }
        catch (error) {
            Logger.error('Error exporting calendar', error);
            return null;
        }
    }
    /**
     * Remove a calendar (built-in calendars cannot be removed)
     */
    removeCalendar(calendarId) {
        const builtInCalendars = ['gregorian', 'vale-reckoning'];
        if (builtInCalendars.includes(calendarId)) {
            Logger.warn(`Cannot remove built-in calendar: ${calendarId}`);
            return false;
        }
        if (!this.calendars.has(calendarId)) {
            Logger.warn(`Calendar not found: ${calendarId}`);
            return false;
        }
        // Don't remove if it's the active calendar
        if (this.activeCalendarId === calendarId) {
            Logger.warn(`Cannot remove active calendar: ${calendarId}`);
            return false;
        }
        this.calendars.delete(calendarId);
        this.engines.delete(calendarId);
        Logger.debug(`Removed calendar: ${calendarId}`);
        return true;
    }
    /**
     * Get current date from active calendar
     */
    getCurrentDate() {
        if (!this.timeConverter)
            return null;
        return this.timeConverter.getCurrentDate();
    }
    /**
     * Advance time by days using active calendar
     */
    async advanceDays(days) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceDays(days);
    }
    /**
     * Advance time by hours using active calendar
     */
    async advanceHours(hours) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceHours(hours);
    }
    /**
     * Advance time by weeks using active calendar
     */
    async advanceWeeks(weeks) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceWeeks(weeks);
    }
    /**
     * Advance time by months using active calendar
     */
    async advanceMonths(months) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceMonths(months);
    }
    /**
     * Advance time by years using active calendar
     */
    async advanceYears(years) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceYears(years);
    }
    /**
     * Advance time by minutes using active calendar
     */
    async advanceMinutes(minutes) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceMinutes(minutes);
    }
    /**
     * Advance time by seconds using active calendar
     */
    async advanceSeconds(seconds) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.advanceSeconds(seconds);
    }
    /**
     * Set current date using active calendar
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async setCurrentDate(date) {
        if (!this.timeConverter) {
            throw new Error('No active calendar set');
        }
        await this.timeConverter.setCurrentDate(date);
    }
    /**
     * Get debug information
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getDebugInfo() {
        return {
            activeCalendarId: this.activeCalendarId,
            availableCalendars: this.getAvailableCalendars(),
            currentDate: this.getCurrentDate()?.toLongString(),
            timeConverter: this.timeConverter?.getDebugInfo(),
        };
    }
    /**
     * Validate all loaded calendars
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validateAllCalendars() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const results = {};
        for (const [calendarId, calendar] of this.calendars.entries()) {
            results[calendarId] = CalendarValidator.validateWithHelp(calendar);
        }
        return results;
    }
    /**
     * Resolve a calendar ID to its default variant if applicable
     */
    resolveDefaultVariant(calendarId) {
        // If the ID already includes a variant (contains parentheses), return as-is
        if (calendarId.includes('(') && calendarId.includes(')')) {
            return calendarId;
        }
        // First, check for inline variants in the base calendar
        const baseCalendar = this.calendars.get(calendarId);
        if (baseCalendar?.variants) {
            // Find the default variant in inline variants
            for (const [variantId, variant] of Object.entries(baseCalendar.variants)) {
                if (variant.default) {
                    return `${calendarId}(${variantId})`;
                }
            }
        }
        // Note: External variants are not checked for automatic defaults
        // They represent themed collections intended for specific campaign types
        // and should be explicitly selected by users, not automatic defaults
        // Return the original ID if no default variant found
        return calendarId;
    }
    /**
     * Expand calendar variants into separate calendar entries
     */
    expandCalendarVariants(baseCalendar) {
        if (!baseCalendar.variants)
            return;
        for (const [variantId, variant] of Object.entries(baseCalendar.variants)) {
            const variantCalendar = this.applyVariantOverrides(baseCalendar, variantId, variant);
            const variantCalendarId = `${baseCalendar.id}(${variantId})`;
            // Store the variant calendar
            this.calendars.set(variantCalendarId, variantCalendar);
            // Create engine for variant calendar
            const variantEngine = new CalendarEngine(variantCalendar);
            this.engines.set(variantCalendarId, variantEngine);
            Logger.debug(`Created calendar variant: ${variantCalendarId}`);
        }
    }
    /**
     * Apply variant overrides to a base calendar
     */
    applyVariantOverrides(baseCalendar, variantId, variant) {
        // Deep clone the base calendar
        const variantCalendar = JSON.parse(JSON.stringify(baseCalendar));
        // Update ID to include variant
        variantCalendar.id = `${baseCalendar.id}(${variantId})`;
        // Update translations to show variant name
        for (const translation of Object.values(variantCalendar.translations)) {
            translation.label = `${translation.label} (${variant.name})`;
        }
        // Apply config-based modifications (e.g., yearOffset)
        if (variant.config?.yearOffset !== undefined) {
            const offsetDifference = variant.config.yearOffset - baseCalendar.year.epoch;
            variantCalendar.year.epoch = variant.config.yearOffset;
            variantCalendar.year.currentYear = baseCalendar.year.currentYear + offsetDifference;
            // Also update worldTime if present
            if (variantCalendar.worldTime && baseCalendar.worldTime) {
                variantCalendar.worldTime.epochYear = variant.config.yearOffset;
                variantCalendar.worldTime.currentYear =
                    baseCalendar.worldTime.currentYear + offsetDifference;
            }
        }
        // Apply overrides
        if (variant.overrides) {
            // Apply year overrides
            if (variant.overrides.year) {
                Object.assign(variantCalendar.year, variant.overrides.year);
            }
            // Apply month overrides
            if (variant.overrides.months) {
                for (const [monthName, monthOverrides] of Object.entries(variant.overrides.months)) {
                    const monthIndex = variantCalendar.months.findIndex(m => m.name === monthName);
                    if (monthIndex !== -1) {
                        Object.assign(variantCalendar.months[monthIndex], monthOverrides);
                    }
                }
            }
            // Apply weekday overrides
            if (variant.overrides.weekdays) {
                for (const [weekdayName, weekdayOverrides] of Object.entries(variant.overrides.weekdays)) {
                    const weekdayIndex = variantCalendar.weekdays.findIndex(w => w.name === weekdayName);
                    if (weekdayIndex !== -1) {
                        Object.assign(variantCalendar.weekdays[weekdayIndex], weekdayOverrides);
                    }
                }
            }
            // Apply dateFormats overrides
            if (variant.overrides.dateFormats) {
                // Deep merge dateFormats to preserve base calendar formats while adding variant-specific ones
                variantCalendar.dateFormats = {
                    ...variantCalendar.dateFormats,
                    ...variant.overrides.dateFormats,
                    // Merge nested objects like widgets
                    ...(variantCalendar.dateFormats?.widgets || variant.overrides.dateFormats?.widgets
                        ? {
                            widgets: {
                                ...variantCalendar.dateFormats?.widgets,
                                ...variant.overrides.dateFormats?.widgets,
                            },
                        }
                        : {}),
                };
            }
            // Apply moon overrides
            if (variant.overrides.moons !== undefined) {
                variantCalendar.moons = variant.overrides.moons;
            }
            // Apply canonical hours overrides
            if (variant.overrides.canonicalHours !== undefined) {
                variantCalendar.canonicalHours = variant.overrides.canonicalHours;
            }
        }
        return variantCalendar;
    }
    /**
     * Load external variant files that reference existing calendars
     */
    async loadExternalVariantFiles() {
        const builtInCalendars = await this.getBuiltInCalendarList();
        // Find all variant files in the calendar list
        const variantFiles = builtInCalendars.filter(calendarId => calendarId.includes('-variants'));
        for (const variantFileId of variantFiles) {
            await this.loadExternalVariantFile(variantFileId);
        }
    }
    /**
     * Load a specific external variant file
     */
    async loadExternalVariantFile(variantFileId) {
        try {
            // Load external variant file using CalendarLoader
            const result = await this.calendarLoader.loadFromUrl(`module:seasons-and-stars/calendars/${variantFileId}.json`, {
                validate: false, // External variant files have different structure than calendars
            });
            if (!result.success || !result.calendar) {
                Logger.debug(`External variant file not found: ${variantFileId}`, result.error);
                return;
            }
            // Cast to variant file data since we disabled validation
            const variantFileData = result.calendar;
            // Validate external variant file structure
            if (!this.validateExternalVariantFile(variantFileData)) {
                Logger.error(`Invalid external variant file: ${variantFileId}`);
                return;
            }
            // Check if base calendar exists
            const baseCalendar = this.calendars.get(variantFileData.baseCalendar);
            if (!baseCalendar) {
                Logger.warn(`Base calendar '${variantFileData.baseCalendar}' not found for variant file: ${variantFileId}`);
                return;
            }
            // Apply external variants to the base calendar
            this.applyExternalVariants(baseCalendar, variantFileData);
            Logger.debug(`Loaded external variant file: ${variantFileId} (${Object.keys(variantFileData.variants).length} variants)`);
        }
        catch (error) {
            Logger.error(`Error loading external variant file ${variantFileId}`, error);
        }
    }
    /**
     * Validate external variant file structure
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validateExternalVariantFile(data) {
        return (data &&
            typeof data === 'object' &&
            typeof data.id === 'string' &&
            typeof data.baseCalendar === 'string' &&
            typeof data.variants === 'object' &&
            data.variants !== null);
    }
    /**
     * Apply external variants to a base calendar
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    applyExternalVariants(baseCalendar, variantFileData) {
        for (const [variantId, variant] of Object.entries(variantFileData.variants)) {
            const variantCalendar = this.applyVariantOverrides(baseCalendar, variantId, variant);
            const variantCalendarId = `${baseCalendar.id}(${variantId})`;
            // Store the variant calendar
            this.calendars.set(variantCalendarId, variantCalendar);
            // Create engine for variant calendar
            const variantEngine = new CalendarEngine(variantCalendar);
            this.engines.set(variantCalendarId, variantEngine);
            // Note: External variants with default=true are only defaults within their
            // themed context, not automatic defaults for the base calendar
            Logger.debug(`Created external calendar variant: ${variantCalendarId}`);
        }
    }
    // External Calendar Loading Methods
    /**
     * Load a calendar from an external URL
     */
    async loadCalendarFromUrl(url, options) {
        Logger.info(`Loading calendar from URL: ${url}`);
        const result = await this.calendarLoader.loadFromUrl(url, {
            validate: options?.validate !== false,
        });
        if (result.success && result.calendar) {
            // Determine source information based on URL
            const sourceInfo = this.determineSourceInfo(url, result);
            // Load the calendar into the manager with source info
            const loadSuccess = this.loadCalendar(result.calendar, sourceInfo);
            if (!loadSuccess) {
                return {
                    ...result,
                    success: false,
                    error: 'Calendar loaded from URL but failed validation in CalendarManager',
                };
            }
            // Update source status if this was from a registered source
            const sources = this.calendarLoader.getSources();
            const matchingSource = sources.find(s => s.url === url);
            if (matchingSource) {
                this.calendarLoader.updateSourceStatus(matchingSource.id, true);
            }
            Logger.info(`Successfully loaded external calendar: ${result.calendar.id}`);
        }
        else if (result.error) {
            // Update source status if this was from a registered source
            const sources = this.calendarLoader.getSources();
            const matchingSource = sources.find(s => s.url === url);
            if (matchingSource) {
                this.calendarLoader.updateSourceStatus(matchingSource.id, false, result.error);
            }
            Logger.error(`Failed to load calendar from URL: ${result.error}`);
        }
        return result;
    }
    /**
     * Load multiple calendars from a collection URL
     */
    async loadCalendarCollection(url, options) {
        Logger.info(`Loading calendar collection from URL: ${url}`);
        const results = await this.calendarLoader.loadCollection(url, {
            validate: options?.validate !== false,
        });
        let successCount = 0;
        let errorCount = 0;
        // Two-pass loading: first regular calendars, then variants
        // Pass 1: Load regular calendars
        for (const result of results) {
            if (result.success && result.calendar) {
                const isVariantFile = result.calendar.id && result.calendar.id.includes('-variants');
                if (isVariantFile) {
                    // Skip variants in first pass
                    continue;
                }
                // Determine source information based on URL
                const sourceInfo = this.determineSourceInfo(url, result);
                const loadSuccess = this.loadCalendar(result.calendar, sourceInfo);
                if (loadSuccess) {
                    successCount++;
                }
                else {
                    result.success = false;
                    result.error = 'Calendar loaded from collection but failed validation in CalendarManager';
                    errorCount++;
                }
            }
            else {
                errorCount++;
            }
        }
        // Pass 2: Process variant files as external variants
        for (const result of results) {
            if (result.success && result.calendar) {
                const isVariantFile = result.calendar.id && result.calendar.id.includes('-variants');
                if (isVariantFile) {
                    // Process as external variant
                    try {
                        const variantFileData = result.calendar;
                        if (this.validateExternalVariantFile(variantFileData)) {
                            const baseCalendar = this.calendars.get(variantFileData.baseCalendar);
                            if (baseCalendar) {
                                this.applyExternalVariants(baseCalendar, variantFileData);
                                successCount++;
                            }
                            else {
                                result.success = false;
                                result.error = `Base calendar '${variantFileData.baseCalendar}' not found for variant file`;
                                errorCount++;
                            }
                        }
                        else {
                            result.success = false;
                            result.error = 'Invalid external variant file structure';
                            errorCount++;
                        }
                    }
                    catch (error) {
                        result.success = false;
                        result.error = `Error processing variant file: ${error.message}`;
                        errorCount++;
                    }
                }
            }
        }
        Logger.info(`Collection load completed: ${successCount} successful, ${errorCount} failed`);
        return results;
    }
    /**
     * Determine source information based on URL and load result
     */
    determineSourceInfo(url, _result) {
        // Check if this is a module URL
        if (url.startsWith('module:')) {
            const moduleMatch = url.match(/^module:([a-z0-9-]+)/);
            if (moduleMatch) {
                const moduleId = moduleMatch[1];
                const module = game.modules.get(moduleId);
                if (module) {
                    return {
                        type: 'module',
                        sourceName: module.title,
                        description: `Calendar provided by the ${module.title} module`,
                        icon: 'fa-solid fa-puzzle-piece',
                        moduleId,
                        url,
                    };
                }
            }
        }
        // Check if this came from an external source (tracked by CalendarLoader)
        const externalSources = this.calendarLoader.getSources();
        for (const source of externalSources) {
            if (source.url === url) {
                return {
                    type: 'external',
                    sourceName: source.name,
                    description: `Calendar loaded from external source: ${source.name}`,
                    icon: 'fa-solid fa-cloud',
                    externalSourceId: source.id,
                    url: source.url,
                };
            }
        }
        // Default fallback (shouldn't happen for collections, but safety)
        return {
            type: 'builtin',
            sourceName: 'Unknown Source',
            description: 'Calendar source could not be determined',
            icon: 'fa-solid fa-question-circle',
            url,
        };
    }
    /**
     * Auto-detect and load calendar pack modules
     * Scans for enabled modules starting with 'seasons-and-stars-' and loads their calendars
     */
    async autoLoadCalendarPacks() {
        Logger.debug('Auto-detecting calendar pack modules');
        // Find all enabled modules that start with 'seasons-and-stars-' (excluding core module)
        const calendarPackModules = Array.from(game.modules.values()).filter(module => module.id.startsWith('seasons-and-stars-') && module.active);
        if (calendarPackModules.length === 0) {
            Logger.debug('No calendar pack modules found');
            return;
        }
        Logger.info(`Found ${calendarPackModules.length} calendar pack modules: ${calendarPackModules.map(m => m.id).join(', ')}`);
        for (const module of calendarPackModules) {
            await this.loadModuleCalendars(module.id);
        }
    }
    /**
     * Load calendars from a specific module
     * @param moduleId - The module ID to load calendars from
     */
    async loadModuleCalendars(moduleId) {
        Logger.debug(`Loading calendars from module: ${moduleId}`);
        // Check if module is enabled
        const module = game.modules.get(moduleId);
        if (!module?.active) {
            Logger.warn(`Module not found or not enabled: ${moduleId}`);
            return [];
        }
        // Use module URL protocol for proper CalendarLoader handling
        const indexUrl = `module:${moduleId}`;
        try {
            // Try to load the calendar collection from the module
            const results = await this.loadCalendarCollection(indexUrl, {
                validate: true,
            });
            const successfulResults = results.filter(r => r.success);
            const failedResults = results.filter(r => !r.success);
            if (successfulResults.length > 0) {
                Logger.info(`Successfully loaded ${successfulResults.length} calendars from module ${moduleId}`);
            }
            if (failedResults.length > 0) {
                Logger.warn(`Failed to load ${failedResults.length} calendars from module ${moduleId}`);
                failedResults.forEach(result => {
                    if (result.error) {
                        Logger.debug(`  - ${result.collectionEntry?.name || 'Unknown'}: ${result.error}`);
                    }
                });
            }
            return results;
        }
        catch (error) {
            Logger.warn(`Failed to load calendar collection from module ${moduleId}:`, error);
            return [];
        }
    }
    /**
     * Add an external calendar source
     */
    addExternalSource(source) {
        const sourceId = this.calendarLoader.addSource(source);
        Logger.info(`Added external calendar source: ${source.name} (${sourceId})`);
        return sourceId;
    }
    /**
     * Remove an external calendar source and its calendars
     */
    removeExternalSource(sourceId) {
        const source = this.calendarLoader.getSource(sourceId);
        if (!source) {
            Logger.warn(`External source not found: ${sourceId}`);
            return false;
        }
        const success = this.calendarLoader.removeSource(sourceId);
        if (success) {
            Logger.info(`Removed external calendar source: ${source.name}`);
        }
        return success;
    }
    /**
     * Get all external calendar sources
     */
    getExternalSources() {
        return this.calendarLoader.getSources();
    }
    /**
     * Get an external calendar source by ID
     */
    getExternalSource(sourceId) {
        return this.calendarLoader.getSource(sourceId);
    }
    /**
     * Refresh a calendar from an external source
     */
    async refreshExternalCalendar(sourceId) {
        const source = this.calendarLoader.getSource(sourceId);
        if (!source) {
            return {
                success: false,
                error: `External source not found: ${sourceId}`,
            };
        }
        if (!source.enabled) {
            return {
                success: false,
                error: `External source is disabled: ${source.name}`,
            };
        }
        // Clear cache for this URL to force fresh load
        // Load based on source type
        if (source.type === 'collection') {
            const results = await this.loadCalendarCollection(source.url);
            // Return summary result for collection
            const successCount = results.filter(r => r.success).length;
            return {
                success: successCount > 0,
                error: successCount === 0 ? 'All calendars in collection failed to load' : undefined,
                sourceUrl: source.url,
            };
        }
        else {
            return await this.loadCalendarFromUrl(source.url);
        }
    }
    /**
     * Refresh all enabled external sources
     */
    async refreshAllExternalCalendars() {
        const sources = this.calendarLoader.getSources().filter(s => s.enabled);
        const results = {};
        Logger.info(`Refreshing ${sources.length} external calendar sources`);
        for (const source of sources) {
            try {
                results[source.id] = await this.refreshExternalCalendar(source.id);
            }
            catch (error) {
                results[source.id] = {
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    sourceUrl: source.url,
                };
            }
        }
        const successCount = Object.values(results).filter(r => r.success).length;
        Logger.info(`External calendar refresh completed: ${successCount}/${sources.length} successful`);
        return results;
    }
    /**
     * Clear external calendar cache
     */
    clearExternalCalendarCache() {
        Logger.info('Cache system removed - no operation needed');
    }
    /**
     * Get the CalendarLoader instance for advanced operations
     */
    getCalendarLoader() {
        return this.calendarLoader;
    }
    /**
     * Fire hook to allow external modules to register calendars
     */
    fireExternalCalendarRegistrationHook() {
        Logger.debug('Firing external calendar registration hook');
        // Create registration callback that modules can use to add calendars
        const registerCalendar = (calendarData, sourceInfo) => {
            // Validate that we have valid calendar data
            if (!calendarData || !calendarData.id) {
                Logger.error('Invalid calendar data provided to registration hook');
                return false;
            }
            // Use existing loadCalendar method for validation and registration
            const success = this.loadCalendar(calendarData, sourceInfo);
            if (success) {
                Logger.info(`External calendar registered: ${calendarData.id}`);
            }
            else {
                Logger.warn(`Failed to register external calendar: ${calendarData.id}`);
            }
            return success;
        };
        // Fire the hook with registration callback
        Hooks.callAll('seasons-stars:registerExternalCalendars', {
            registerCalendar,
            manager: this,
        });
    }
    /**
     * Convert a Foundry server path to a proper URL for fetching
     */
    convertFoundryPathToUrl(foundryPath) {
        // If it's already a proper URL, return as-is
        if (foundryPath.startsWith('http://') ||
            foundryPath.startsWith('https://') ||
            foundryPath.startsWith('module:')) {
            return foundryPath;
        }
        // Remove file:// protocol if present
        if (foundryPath.startsWith('file://')) {
            foundryPath = foundryPath.substring(7);
        }
        // For Foundry server paths, we need to construct a proper URL
        // The path should be relative to the Foundry installation
        const baseUrl = window.location.origin;
        const cleanPath = foundryPath.startsWith('/') ? foundryPath : `/${foundryPath}`;
        return `${baseUrl}${cleanPath}`;
    }
}

/**
 * Performance optimization utilities for the notes system
 *
 * Note: Memory monitoring has been moved to the Memory Mage module.
 * This optimizer now focuses on search performance and caching only.
 */
/**
 * Performance optimizer for large note collections
 */
class NotePerformanceOptimizer {
    constructor(config = {}) {
        // LRU cache implementation
        this.lruCache = new Map();
        this.cacheAccessOrder = [];
        this.config = {
            cacheSize: 200,
            cacheEvictionStrategy: 'lru',
            maxSearchResults: 1000,
            searchTimeout: 5000,
            enablePagination: true,
            lazyIndexing: true,
            indexRebuildThreshold: 500,
            ...config,
        };
        this.metrics = {
            indexBuildTime: 0,
            searchTime: 0,
            cacheHitRate: 0,
            totalNotes: 0,
            indexedDates: 0,
        };
    }
    static getInstance(config) {
        if (!this.instance) {
            this.instance = new NotePerformanceOptimizer(config);
        }
        return this.instance;
    }
    /**
     * Optimized note retrieval with smart caching
     */
    async getOptimizedNotes(dateKeys, useCache = true) {
        const startTime = performance.now();
        const result = new Map();
        const uncachedKeys = [];
        // Check cache first
        if (useCache) {
            for (const dateKey of dateKeys) {
                const cachedNotes = this.getCachedNotesForDate(dateKey);
                if (cachedNotes) {
                    result.set(dateKey, cachedNotes);
                }
                else {
                    uncachedKeys.push(dateKey);
                }
            }
        }
        else {
            uncachedKeys.push(...dateKeys);
        }
        // Fetch uncached notes in batches
        if (uncachedKeys.length > 0) {
            const batchSize = 10; // Process 10 dates at a time
            for (let i = 0; i < uncachedKeys.length; i += batchSize) {
                const batch = uncachedKeys.slice(i, i + batchSize);
                const batchResults = await this.fetchNotesBatch(batch);
                for (const [dateKey, notes] of batchResults) {
                    result.set(dateKey, notes);
                    // Cache the results
                    if (useCache) {
                        this.cacheNotesForDate(dateKey, notes);
                    }
                }
                // Yield to prevent blocking
                if (i + batchSize < uncachedKeys.length) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }
        }
        const endTime = performance.now();
        this.metrics.searchTime = endTime - startTime;
        return result;
    }
    /**
     * Optimized search with early termination and pagination
     */
    async optimizedSearch(criteria) {
        const startTime = performance.now();
        // Apply smart filtering strategy
        const searchStrategy = this.determineSearchStrategy(criteria);
        let notes = [];
        try {
            // Use timeout to prevent long-running searches
            notes = await Promise.race([
                this.executeSearchStrategy(searchStrategy, criteria),
                this.createSearchTimeout(),
            ]);
        }
        catch (error) {
            Logger.warn('Search timeout or error:', error);
            // Return partial results
            notes = [];
        }
        // Apply pagination if enabled
        const limit = criteria.limit || this.config.maxSearchResults;
        const offset = criteria.offset || 0;
        const totalCount = notes.length;
        if (this.config.enablePagination && totalCount > limit) {
            notes = notes.slice(offset, offset + limit);
        }
        const endTime = performance.now();
        const searchTime = endTime - startTime;
        this.metrics.searchTime = searchTime;
        return {
            notes,
            totalCount,
            hasMore: totalCount > offset + notes.length,
            searchTime,
        };
    }
    /**
     * Memory pressure relief - clean up caches and rebuild indexes
     * Called by Memory Mage during memory pressure events
     */
    relieveMemoryPressure() {
        Logger.info('Relieving memory pressure...');
        // Clear cache partially (keep most recent 50%)
        this.clearOldCacheEntries(0.5);
        Logger.info('Memory pressure relief completed');
    }
    /**
     * Get current performance metrics
     */
    getMetrics() {
        this.updateMetrics();
        return { ...this.metrics };
    }
    /**
     * Update configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        // Adjust cache size if needed
        if (newConfig.cacheSize && newConfig.cacheSize < this.lruCache.size) {
            this.clearOldCacheEntries(1 - newConfig.cacheSize / this.lruCache.size);
        }
    }
    /**
     * Get estimated memory usage for Memory Mage
     */
    getMemoryUsage() {
        // Estimate cache memory usage
        const avgNoteSize = 0.01; // Estimate 10KB per cached note
        const cacheMemory = this.lruCache.size * avgNoteSize;
        // Add small baseline for the optimizer itself
        const baseMemory = 0.1;
        return cacheMemory + baseMemory;
    }
    /**
     * Determine optimal search strategy based on criteria
     */
    determineSearchStrategy(criteria) {
        // Use index strategy for date-based searches
        if (criteria.dateFrom || criteria.dateTo) {
            return 'index';
        }
        // Use full search for complex text queries
        if (criteria.query && criteria.query.length > 3) {
            return 'full';
        }
        // Use hybrid for mixed criteria
        return 'hybrid';
    }
    /**
     * Execute search based on strategy
     */
    async executeSearchStrategy(strategy, criteria) {
        switch (strategy) {
            case 'index':
                return this.indexBasedSearch(criteria);
            case 'full':
                return this.fullTextSearch(criteria);
            case 'hybrid':
                return this.hybridSearch(criteria);
            default:
                return this.fullTextSearch(criteria);
        }
    }
    /**
     * Index-based search for date ranges
     */
    async indexBasedSearch(criteria) {
        const dateKeys = this.generateDateKeys(criteria.dateFrom, criteria.dateTo);
        const notesMap = await this.getOptimizedNotes(dateKeys);
        const allNotes = [];
        for (const notes of notesMap.values()) {
            allNotes.push(...notes);
        }
        // Apply additional filters
        return this.applyAdditionalFilters(allNotes, criteria);
    }
    /**
     * Full text search with optimizations
     */
    async fullTextSearch(criteria) {
        const allNotes = this.getAllCalendarNotes();
        // Early termination if too many notes
        if (allNotes.length > this.config.indexRebuildThreshold) {
            Logger.warn(`Large collection (${allNotes.length} notes) - consider date filtering`);
        }
        return this.applyAdditionalFilters(allNotes, criteria);
    }
    /**
     * Hybrid search combining index and full search
     */
    async hybridSearch(criteria) {
        // Start with index-based filtering if date criteria exists
        let notes;
        if (criteria.dateFrom || criteria.dateTo) {
            notes = await this.indexBasedSearch(criteria);
        }
        else {
            notes = this.getAllCalendarNotes();
        }
        // Apply text filtering on the reduced set
        return this.applyAdditionalFilters(notes, criteria);
    }
    /**
     * Create search timeout promise
     */
    createSearchTimeout() {
        return new Promise((_, reject) => {
            setTimeout(() => {
                reject(new Error('Search timeout'));
            }, this.config.searchTimeout);
        });
    }
    /**
     * Generate date keys for a range
     */
    generateDateKeys(from, to) {
        if (!from && !to)
            return [];
        const keys = [];
        const start = from || to;
        const end = to || from;
        // Limit range to prevent excessive key generation
        const maxDays = 366; // One year maximum
        let dayCount = 0;
        const current = { ...start };
        while (dayCount < maxDays && this.compareDates(current, end) <= 0) {
            keys.push(this.getDateKey(current));
            this.incrementDate(current);
            dayCount++;
        }
        return keys;
    }
    /**
     * Apply additional filters to notes
     */
    applyAdditionalFilters(notes, criteria) {
        let filtered = notes;
        // Apply text filter
        if (criteria.query) {
            const queryLower = criteria.query.toLowerCase();
            filtered = filtered.filter(note => {
                const title = note.name?.toLowerCase() || '';
                const content = this.getNoteContent(note).toLowerCase();
                return title.includes(queryLower) || content.includes(queryLower);
            });
        }
        // Apply category filter
        if (criteria.categories && criteria.categories.length > 0) {
            filtered = filtered.filter(note => {
                const category = note.flags?.['seasons-and-stars']?.category;
                return criteria.categories.includes(category);
            });
        }
        // Apply other filters...
        // (Implementation similar to existing NoteSearch)
        return filtered;
    }
    /**
     * Cache management methods
     */
    getCachedNotesForDate(dateKey) {
        const cached = this.lruCache.get(dateKey);
        if (cached) {
            // Update access time
            cached.lastAccess = Date.now();
            this.updateCacheAccessOrder(dateKey);
            return [cached.note]; // For single note, adjust for multiple notes
        }
        return null;
    }
    cacheNotesForDate(dateKey, notes) {
        // For simplicity, cache first note only
        // In production, implement proper multi-note caching
        if (notes.length > 0) {
            this.addToLRUCache(dateKey, notes[0]);
        }
    }
    addToLRUCache(key, note) {
        // Remove if already exists
        if (this.lruCache.has(key)) {
            this.lruCache.delete(key);
            const index = this.cacheAccessOrder.indexOf(key);
            if (index > -1) {
                this.cacheAccessOrder.splice(index, 1);
            }
        }
        // Check cache size
        while (this.lruCache.size >= this.config.cacheSize) {
            const oldestKey = this.cacheAccessOrder.shift();
            if (oldestKey) {
                this.lruCache.delete(oldestKey);
            }
        }
        // Add new entry
        this.lruCache.set(key, { note, lastAccess: Date.now() });
        this.cacheAccessOrder.push(key);
    }
    updateCacheAccessOrder(key) {
        const index = this.cacheAccessOrder.indexOf(key);
        if (index > -1) {
            this.cacheAccessOrder.splice(index, 1);
            this.cacheAccessOrder.push(key);
        }
    }
    clearOldCacheEntries(fraction) {
        const entriesToRemove = Math.floor(this.lruCache.size * fraction);
        for (let i = 0; i < entriesToRemove && this.cacheAccessOrder.length > 0; i++) {
            const oldestKey = this.cacheAccessOrder.shift();
            if (oldestKey) {
                this.lruCache.delete(oldestKey);
            }
        }
    }
    /**
     * Utility methods
     */
    async fetchNotesBatch(dateKeys) {
        const result = new Map();
        // Implementation would use note storage system
        // For now, return empty map
        dateKeys.forEach(key => {
            result.set(key, []);
        });
        return result;
    }
    getAllCalendarNotes() {
        if (!game.journal)
            return [];
        return game.journal.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote === true;
        });
    }
    getNoteContent(note) {
        // Extract content from first text page
        const textPage = note.pages?.find(page => page.type === 'text');
        return textPage?.text?.content || '';
    }
    getDateKey(date) {
        const year = date.year.toString().padStart(4, '0');
        const month = date.month.toString().padStart(2, '0');
        const day = date.day.toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    }
    compareDates(date1, date2) {
        return CalendarTimeUtils.compareDates(date1, date2);
    }
    incrementDate(date) {
        // Simple increment - would need calendar-aware logic in production
        date.day++;
        if (date.day > 30) {
            // Simplified
            date.day = 1;
            date.month++;
            if (date.month > 12) {
                date.month = 1;
                date.year++;
            }
        }
    }
    updateMetrics() {
        this.metrics.totalNotes = this.getAllCalendarNotes().length;
        this.metrics.cacheHitRate = this.calculateCacheHitRate();
    }
    calculateCacheHitRate() {
        // Would need to track hits/misses in production
        return 0.85; // Placeholder
    }
}

/**
 * Efficient date-based storage and retrieval system for calendar notes
 */
/**
 * High-performance storage system with date-based indexing
 */
class NoteStorage {
    constructor() {
        this.dateIndex = new Map();
        this.noteCache = new Map();
        this.cacheSize = 100; // Limit cache size to prevent memory issues
        this.indexBuilt = false;
    }
    /**
     * Initialize the storage system
     */
    initialize() {
        this.performanceOptimizer = NotePerformanceOptimizer.getInstance({
            cacheSize: this.cacheSize,
        });
        this.buildDateIndex();
        this.indexBuilt = true;
        Logger.debug('Note storage initialized with performance optimization');
    }
    /**
     * Store a note with date indexing
     */
    async storeNote(note, date) {
        if (!this.indexBuilt) {
            this.initialize();
        }
        const dateKey = this.getDateKey(date);
        this.addToDateIndex(dateKey, note.id);
        // Add to cache
        this.addToCache(note.id, note);
    }
    /**
     * Remove a note from storage and indexing
     */
    async removeNote(noteId) {
        // Remove from all date indices
        for (const [dateKey, noteIds] of this.dateIndex.entries()) {
            if (noteIds.has(noteId)) {
                this.removeFromDateIndex(dateKey, noteId);
            }
        }
        // Remove from cache
        this.noteCache.delete(noteId);
    }
    /**
     * Find notes by specific date (fast retrieval using index)
     */
    async findNotesByDate(date) {
        if (!this.indexBuilt) {
            this.initialize();
        }
        const dateKey = this.getDateKey(date);
        const noteIds = this.dateIndex.get(dateKey) || new Set();
        const notes = [];
        for (const noteId of noteIds) {
            const note = this.getFromCache(noteId) || game.journal?.get(noteId);
            if (note && this.isCalendarNote(note)) {
                notes.push(note);
                // Add to cache if retrieved from game
                if (!this.noteCache.has(noteId)) {
                    this.addToCache(noteId, note);
                }
            }
        }
        return this.sortNotesByCreation(notes);
    }
    /**
     * Find notes by specific date (synchronous version for API compatibility)
     */
    findNotesByDateSync(date) {
        if (!this.indexBuilt) {
            this.initialize();
        }
        const dateKey = this.getDateKey(date);
        const noteIds = this.dateIndex.get(dateKey) || new Set();
        const notes = [];
        for (const noteId of noteIds) {
            const note = this.getFromCache(noteId) || game.journal?.get(noteId);
            if (note && this.isCalendarNote(note)) {
                notes.push(note);
                // Add to cache if retrieved from game
                if (!this.noteCache.has(noteId)) {
                    this.addToCache(noteId, note);
                }
            }
        }
        return this.sortNotesByCreation(notes);
    }
    /**
     * Find notes by date range (optimized for ranges)
     */
    async findNotesByDateRange(start, end) {
        if (!this.indexBuilt) {
            this.initialize();
        }
        const notes = [];
        const noteIds = new Set();
        // Iterate through date range and collect note IDs
        const startKey = this.getDateKey(start);
        const endKey = this.getDateKey(end);
        for (const [dateKey, dayNoteIds] of this.dateIndex.entries()) {
            if (dateKey >= startKey && dateKey <= endKey) {
                for (const noteId of dayNoteIds) {
                    noteIds.add(noteId);
                }
            }
        }
        // Retrieve notes
        for (const noteId of noteIds) {
            const note = this.getFromCache(noteId) || game.journal?.get(noteId);
            if (note && this.isCalendarNote(note)) {
                // Double-check date range for notes that span multiple days
                // Try S&S flags first, then bridge flags
                const ssFlags = note.flags?.['seasons-and-stars'];
                const bridgeFlags = note.flags?.['foundryvtt-simple-calendar-compat'];
                const startDate = ssFlags?.startDate || bridgeFlags?.startDate;
                if (startDate && this.isDateInRange(startDate, start, end)) {
                    notes.push(note);
                    // Add to cache if retrieved from game
                    if (!this.noteCache.has(noteId)) {
                        this.addToCache(noteId, note);
                    }
                }
            }
        }
        return this.sortNotesByDate(notes);
    }
    /**
     * Rebuild the date index (call when notes are created/updated outside storage)
     *
     * NOTE: This is a workaround for bridge integration synchronization issues.
     * When external modules (like Simple Weather) create notes through the Simple Calendar
     * Compatibility Bridge, those notes don't automatically appear in calendar highlighting
     * until this method is called. See KNOWN-ISSUES.md for details.
     */
    rebuildIndex() {
        Logger.debug('Rebuilding note storage index');
        this.dateIndex.clear();
        this.buildDateIndex();
        Logger.debug(`Index rebuilt with ${this.dateIndex.size} date entries`);
    }
    /**
     * Clear the cache to free memory
     */
    clearCache() {
        this.noteCache.clear();
        Logger.debug('Note cache cleared');
    }
    /**
     * Get cache statistics for debugging
     */
    getCacheStats() {
        return {
            size: this.noteCache.size,
            maxSize: this.cacheSize,
        };
    }
    /**
     * Get performance metrics
     */
    getPerformanceMetrics() {
        if (!this.performanceOptimizer) {
            return null;
        }
        return this.performanceOptimizer.getMetrics();
    }
    /**
     * Optimize storage for large collections
     */
    async optimizeForLargeCollections() {
        if (!this.performanceOptimizer) {
            Logger.warn('Performance optimizer not initialized');
            return;
        }
        Logger.debug('Optimizing storage for large collections...');
        // Clear cache and rebuild index
        this.clearCache();
        this.rebuildIndex();
        // Update configuration for large collections
        this.performanceOptimizer.updateConfig({
            cacheSize: Math.min(500, Math.max(200, this.dateIndex.size * 2)),
            maxSearchResults: 500,
            enablePagination: true,
        });
        Logger.debug('Storage optimization completed');
    }
    /**
     * Build the date index from existing journal entries
     */
    buildDateIndex() {
        this.dateIndex.clear();
        if (!game.journal) {
            Logger.warn('Game journal not available for indexing');
            return;
        }
        let indexedCount = 0;
        game.journal.forEach(journal => {
            if (this.isCalendarNote(journal)) {
                // Try to get dateKey from S&S flags first, then bridge flags
                const ssFlags = journal.flags?.['seasons-and-stars'];
                const bridgeFlags = journal.flags?.['foundryvtt-simple-calendar-compat'];
                const dateKey = ssFlags?.dateKey || bridgeFlags?.dateKey;
                if (dateKey) {
                    this.addToDateIndex(dateKey, journal.id);
                    indexedCount++;
                }
            }
        });
        Logger.debug(`Built date index for ${indexedCount} calendar notes`);
    }
    /**
     * Generate a date key for indexing (YYYY-MM-DD format)
     */
    getDateKey(date) {
        if (!date ||
            typeof date.year === 'undefined' ||
            typeof date.month === 'undefined' ||
            typeof date.day === 'undefined') {
            throw new Error(`Invalid date object passed to getDateKey: ${JSON.stringify(date)}`);
        }
        const year = date.year.toString().padStart(4, '0');
        const month = date.month.toString().padStart(2, '0');
        const day = date.day.toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    }
    /**
     * Add a note to the date index
     */
    addToDateIndex(dateKey, noteId) {
        if (!this.dateIndex.has(dateKey)) {
            this.dateIndex.set(dateKey, new Set());
        }
        this.dateIndex.get(dateKey).add(noteId);
    }
    /**
     * Remove a note from the date index
     */
    removeFromDateIndex(dateKey, noteId) {
        const noteIds = this.dateIndex.get(dateKey);
        if (noteIds) {
            noteIds.delete(noteId);
            // Clean up empty date entries
            if (noteIds.size === 0) {
                this.dateIndex.delete(dateKey);
            }
        }
    }
    /**
     * Add note to cache with size management
     */
    addToCache(noteId, note) {
        // Manage cache size
        if (this.noteCache.size >= this.cacheSize) {
            // Remove oldest entry (FIFO)
            const firstKey = this.noteCache.keys().next().value;
            if (firstKey) {
                this.noteCache.delete(firstKey);
            }
        }
        this.noteCache.set(noteId, note);
    }
    /**
     * Get note from cache
     */
    getFromCache(noteId) {
        return this.noteCache.get(noteId) || null;
    }
    /**
     * Check if a journal entry is a calendar note
     */
    isCalendarNote(journal) {
        // Check for native S&S flags
        const ssFlags = journal.flags?.['seasons-and-stars'];
        if (ssFlags?.calendarNote === true) {
            return true;
        }
        // Check for bridge flags (Simple Calendar compatibility)
        const bridgeFlags = journal.flags?.['foundryvtt-simple-calendar-compat'];
        return bridgeFlags?.isCalendarNote === true;
    }
    /**
     * Check if a date is within a range (inclusive)
     */
    isDateInRange(date, start, end) {
        return this.compareDates(date, start) >= 0 && this.compareDates(date, end) <= 0;
    }
    /**
     * Compare two dates
     */
    compareDates(a, b) {
        if (a.year !== b.year)
            return a.year - b.year;
        if (a.month !== b.month)
            return a.month - b.month;
        return a.day - b.day;
    }
    /**
     * Sort notes by creation time
     */
    sortNotesByCreation(notes) {
        return notes.sort((a, b) => {
            // Try S&S flags first, then bridge flags
            const aSSFlags = a.flags?.['seasons-and-stars'];
            const aBridgeFlags = a.flags?.['foundryvtt-simple-calendar-compat'];
            const bSSFlags = b.flags?.['seasons-and-stars'];
            const bBridgeFlags = b.flags?.['foundryvtt-simple-calendar-compat'];
            const aCreated = aSSFlags?.created || aBridgeFlags?.created || 0;
            const bCreated = bSSFlags?.created || bBridgeFlags?.created || 0;
            return aCreated - bCreated;
        });
    }
    /**
     * Sort notes by date, then creation time
     */
    sortNotesByDate(notes) {
        return notes.sort((a, b) => {
            // Try S&S flags first, then bridge flags
            const aSSFlags = a.flags?.['seasons-and-stars'];
            const aBridgeFlags = a.flags?.['foundryvtt-simple-calendar-compat'];
            const bSSFlags = b.flags?.['seasons-and-stars'];
            const bBridgeFlags = b.flags?.['foundryvtt-simple-calendar-compat'];
            const aDate = aSSFlags?.startDate || aBridgeFlags?.startDate;
            const bDate = bSSFlags?.startDate || bBridgeFlags?.startDate;
            if (aDate && bDate) {
                const comparison = this.compareDates(aDate, bDate);
                if (comparison !== 0)
                    return comparison;
            }
            const aCreated = aSSFlags?.created || aBridgeFlags?.created || 0;
            const bCreated = bSSFlags?.created || bBridgeFlags?.created || 0;
            return aCreated - bCreated;
        });
    }
}

/**
 * Permission management system for calendar notes
 */
/**
 * Manages permissions and access control for calendar notes
 */
class NotePermissions {
    /**
     * Check if a user can create calendar notes
     */
    canCreateNote(user) {
        // GMs can always create notes
        if (user.isGM)
            return true;
        // Check if players are allowed to create notes via setting
        const allowPlayerCreation = game.settings?.get('seasons-and-stars', 'allowPlayerNotes');
        return allowPlayerCreation || false;
    }
    /**
     * Check if a user can edit a specific note
     */
    canEditNote(user, note) {
        // GMs can always edit notes
        if (user.isGM)
            return true;
        // Check ownership level
        const ownership = note.ownership;
        const userLevel = ownership[user.id] || ownership.default || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
        return userLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    }
    /**
     * Check if a user can delete a specific note
     */
    canDeleteNote(user, note) {
        // GMs can always delete notes
        if (user.isGM)
            return true;
        // Check ownership level (same as edit for now)
        const ownership = note.ownership;
        const userLevel = ownership[user.id] || ownership.default || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
        return userLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    }
    /**
     * Check if a user can view a specific note
     */
    canViewNote(user, note) {
        // GMs can always view notes
        if (user.isGM)
            return true;
        // Check ownership level
        const ownership = note.ownership;
        const userLevel = ownership[user.id] || ownership.default || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
        return userLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
    }
    /**
     * Check if a user can manage a specific note's permissions
     */
    canManagePermissions(user, note) {
        // Only GMs can manage permissions
        if (user.isGM)
            return true;
        // Note creators with owner level can manage their own notes
        const ownership = note.ownership;
        const userLevel = ownership[user.id] || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
        return userLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    }
    /**
     * Set note ownership permissions
     */
    async setNoteOwnership(note, ownership) {
        await note.update({ ownership });
    }
    /**
     * Set a note to be GM-only
     */
    async setGMOnly(note) {
        await this.setNoteOwnership(note, {
            default: CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE,
        });
    }
    /**
     * Set a note to be player-visible
     */
    async setPlayerVisible(note) {
        await this.setNoteOwnership(note, {
            default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
        });
    }
    /**
     * Set a note to be player-editable
     */
    async setPlayerEditable(note) {
        await this.setNoteOwnership(note, {
            default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER,
        });
    }
    /**
     * Give a specific user ownership of a note
     */
    async setUserOwnership(note, userId, level) {
        const currentOwnership = note.ownership || {};
        const newOwnership = {
            ...currentOwnership,
            [userId]: level,
        };
        await this.setNoteOwnership(note, newOwnership);
    }
    /**
     * Remove a user's specific permissions (fall back to default)
     */
    async removeUserOwnership(note, userId) {
        const currentOwnership = note.ownership || {};
        const newOwnership = { ...currentOwnership };
        delete newOwnership[userId];
        await this.setNoteOwnership(note, newOwnership);
    }
    /**
     * Get the effective permission level for a user on a note
     */
    getUserPermissionLevel(user, note) {
        if (user.isGM)
            return CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
        const ownership = note.ownership;
        return ownership[user.id] || ownership.default || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
    }
    /**
     * Get a human-readable permission level name
     */
    getPermissionLevelName(level) {
        switch (level) {
            case CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE:
                return 'None';
            case CONST.DOCUMENT_OWNERSHIP_LEVELS.LIMITED:
                return 'Limited';
            case CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER:
                return 'Observer';
            case CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER:
                return 'Owner';
            default:
                return 'Unknown';
        }
    }
    /**
     * Check if an action is a GM-only feature
     */
    isGMOnlyFeature(action) {
        const gmOnlyActions = [
            'manage-permissions',
            'delete-any-note',
            'edit-any-note',
            'view-private-notes',
            'bulk-operations',
            'import-export',
        ];
        return gmOnlyActions.includes(action);
    }
    /**
     * Check if a user can perform a GM-only action
     */
    canPerformGMAction(user, action) {
        if (!this.isGMOnlyFeature(action))
            return true;
        return user.isGM;
    }
    /**
     * Filter notes based on user permissions
     */
    filterNotesByPermission(notes, user, requiredLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER) {
        return notes.filter(note => {
            const userLevel = this.getUserPermissionLevel(user, note);
            return userLevel >= requiredLevel;
        });
    }
    /**
     * Get all notes the user can view
     */
    getViewableNotes(user) {
        const allNotes = game.journal?.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote === true;
        }) || [];
        return this.filterNotesByPermission(allNotes, user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER);
    }
    /**
     * Get all notes the user can edit
     */
    getEditableNotes(user) {
        const allNotes = game.journal?.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote === true;
        }) || [];
        return this.filterNotesByPermission(allNotes, user, CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER);
    }
    /**
     * Check if the current user has sufficient permissions for an operation
     */
    checkPermission(operation, note, user) {
        const currentUser = user || game.user;
        if (!currentUser)
            return false;
        switch (operation) {
            case 'create':
                return this.canCreateNote(currentUser);
            case 'view':
                return note ? this.canViewNote(currentUser, note) : false;
            case 'edit':
                return note ? this.canEditNote(currentUser, note) : false;
            case 'delete':
                return note ? this.canDeleteNote(currentUser, note) : false;
            case 'manage':
                return note ? this.canManagePermissions(currentUser, note) : false;
            default:
                return false;
        }
    }
    /**
     * Create ownership object for new notes based on settings
     */
    getDefaultOwnership(creatorId) {
        const playerVisible = game.settings?.get('seasons-and-stars', 'defaultPlayerVisible');
        const playerEditable = game.settings?.get('seasons-and-stars', 'defaultPlayerEditable');
        let defaultLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
        if (playerEditable) {
            defaultLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
        }
        else if (playerVisible) {
            defaultLevel = CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
        }
        return {
            [creatorId]: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER,
            default: defaultLevel,
        };
    }
    /**
     * Validate ownership data
     */
    validateOwnership(ownership) {
        const errors = [];
        if (!ownership || typeof ownership !== 'object') {
            errors.push('Ownership must be an object');
            return { isValid: false, errors };
        }
        // Check default level
        if (ownership.default !== undefined) {
            const validLevels = Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS);
            if (!validLevels.includes(ownership.default)) {
                errors.push(`Invalid default ownership level: ${ownership.default}`);
            }
        }
        // Check user-specific levels
        for (const [userId, level] of Object.entries(ownership)) {
            if (userId === 'default')
                continue;
            const validLevels = Object.values(CONST.DOCUMENT_OWNERSHIP_LEVELS);
            if (!validLevels.includes(level)) {
                errors.push(`Invalid ownership level for user ${userId}: ${level}`);
            }
        }
        return { isValid: errors.length === 0, errors };
    }
    /**
     * Get permission summary for debugging
     */
    getPermissionSummary(note, user) {
        const currentUser = user || game.user;
        if (!currentUser)
            return null;
        return {
            noteId: note.id,
            noteName: note.name,
            userId: currentUser.id,
            userName: currentUser.name,
            isGM: currentUser.isGM,
            permissionLevel: this.getUserPermissionLevel(currentUser, note),
            permissionName: this.getPermissionLevelName(this.getUserPermissionLevel(currentUser, note)),
            canView: this.canViewNote(currentUser, note),
            canEdit: this.canEditNote(currentUser, note),
            canDelete: this.canDeleteNote(currentUser, note),
            canManage: this.canManagePermissions(currentUser, note),
            ownership: note.ownership,
        };
    }
}
/**
 * Singleton instance for global access
 */
const notePermissions = new NotePermissions();

/**
 * Recurring events system for calendar notes
 */
/**
 * Manages recurring events and generates occurrence dates
 */
class NoteRecurrence {
    /**
     * Generate all occurrences for a recurring pattern within a date range
     */
    static generateOccurrences(startDate, pattern, rangeStart, rangeEnd, engine // Calendar engine for date calculations
    ) {
        const occurrences = [];
        let currentDate = { ...startDate };
        let occurrenceIndex = 0;
        // Safety limit to prevent infinite loops
        const maxIterations = 10000;
        let iterations = 0;
        while (iterations < maxIterations) {
            iterations++;
            // Check if we've exceeded our limits
            if (pattern.endDate && this.isDateAfter(currentDate, pattern.endDate)) {
                break;
            }
            if (pattern.maxOccurrences && occurrenceIndex >= pattern.maxOccurrences) {
                break;
            }
            // Check if current date is within our requested range
            if (this.isDateInRange(currentDate, rangeStart, rangeEnd)) {
                const isException = this.isExceptionDate(currentDate, pattern.exceptions || []);
                occurrences.push({
                    date: { ...currentDate },
                    isException,
                    index: occurrenceIndex,
                });
            }
            // If we're past the range end, stop
            if (this.isDateAfter(currentDate, rangeEnd)) {
                break;
            }
            // Calculate next occurrence date
            currentDate = this.getNextOccurrenceDate(currentDate, pattern, engine);
            occurrenceIndex++;
        }
        return occurrences;
    }
    /**
     * Calculate the next occurrence date based on the recurrence pattern
     */
    static getNextOccurrenceDate(currentDate, pattern, engine) {
        switch (pattern.frequency) {
            case 'daily':
                return this.addDays(currentDate, pattern.interval, engine);
            case 'weekly':
                if (pattern.weekdays && pattern.weekdays.length > 0) {
                    return this.getNextWeekdayOccurrence(currentDate, pattern, engine);
                }
                else {
                    // Use calendar-specific week length instead of hardcoded 7
                    const calendar = engine.getCalendar();
                    const weekLength = CalendarTimeUtils.getDaysPerWeek(calendar);
                    return this.addDays(currentDate, weekLength * pattern.interval, engine);
                }
            case 'monthly':
                return this.getNextMonthlyOccurrence(currentDate, pattern, engine);
            case 'yearly':
                return this.getNextYearlyOccurrence(currentDate, pattern, engine);
            default:
                throw new Error(`Unsupported recurrence frequency: ${pattern.frequency}`);
        }
    }
    /**
     * Get next occurrence for weekly pattern with specific weekdays
     */
    static getNextWeekdayOccurrence(currentDate, pattern, engine) {
        if (!pattern.weekdays || pattern.weekdays.length === 0) {
            // Use calendar-specific week length instead of hardcoded 7
            const calendar = engine.getCalendar();
            const weekLength = CalendarTimeUtils.getDaysPerWeek(calendar);
            return this.addDays(currentDate, weekLength * pattern.interval, engine);
        }
        const weekdayNumbers = pattern.weekdays.map(day => this.weekdayNameToNumber(day));
        weekdayNumbers.sort((a, b) => a - b);
        const currentWeekday = currentDate.weekday || 0;
        // Find next weekday in current week
        const nextWeekday = weekdayNumbers.find(day => day > currentWeekday);
        if (nextWeekday !== undefined) {
            // Next occurrence is in the same week
            const daysToAdd = nextWeekday - currentWeekday;
            return this.addDays(currentDate, daysToAdd, engine);
        }
        else {
            // Move to next interval week and use first weekday
            const calendar = engine.getCalendar();
            const weekLength = CalendarTimeUtils.getDaysPerWeek(calendar);
            const daysToNextWeek = weekLength - currentWeekday + weekdayNumbers[0];
            const daysToAdd = daysToNextWeek + (pattern.interval - 1) * weekLength;
            return this.addDays(currentDate, daysToAdd, engine);
        }
    }
    /**
     * Get next occurrence for monthly pattern
     */
    static getNextMonthlyOccurrence(currentDate, pattern, engine) {
        if (pattern.monthDay) {
            // Specific day of month (e.g., 15th of every month)
            let nextDate = { ...currentDate };
            // Try same month first
            if (currentDate.day < pattern.monthDay) {
                nextDate.day = pattern.monthDay;
                if (this.isValidDate(nextDate, engine)) {
                    return nextDate;
                }
            }
            // Move to next interval month
            nextDate = this.addMonths(currentDate, pattern.interval, engine);
            nextDate.day = Math.min(pattern.monthDay, engine.getMonthLength(nextDate.month, nextDate.year));
            return nextDate;
        }
        else if (pattern.monthWeek && pattern.monthWeekday) {
            // Specific weekday of specific week (e.g., 2nd Tuesday of every month)
            return this.getNextMonthlyWeekdayOccurrence(currentDate, pattern, engine);
        }
        else {
            // Default: same day of next interval month
            return this.addMonths(currentDate, pattern.interval, engine);
        }
    }
    /**
     * Get next occurrence for monthly weekday pattern (e.g., 2nd Tuesday)
     */
    static getNextMonthlyWeekdayOccurrence(currentDate, pattern, engine) {
        if (!pattern.monthWeek || !pattern.monthWeekday) {
            return this.addMonths(currentDate, pattern.interval, engine);
        }
        const targetWeekday = this.weekdayNameToNumber(pattern.monthWeekday);
        // Try current month first
        const currentMonthDate = this.getNthWeekdayOfMonth(currentDate.year, currentDate.month, pattern.monthWeek, targetWeekday, engine);
        if (currentMonthDate && this.isDateAfter(currentMonthDate, currentDate)) {
            return currentMonthDate;
        }
        // Move to next interval month
        const nextMonth = this.addMonths(currentDate, pattern.interval, engine);
        const nextMonthDate = this.getNthWeekdayOfMonth(nextMonth.year, nextMonth.month, pattern.monthWeek, targetWeekday, engine);
        return nextMonthDate || this.addMonths(currentDate, pattern.interval, engine);
    }
    /**
     * Get next occurrence for yearly pattern
     */
    static getNextYearlyOccurrence(currentDate, pattern, engine) {
        const targetMonth = pattern.yearMonth || currentDate.month;
        const targetDay = pattern.yearDay || currentDate.day;
        // Try current year first
        if (currentDate.month < targetMonth ||
            (currentDate.month === targetMonth && currentDate.day < targetDay)) {
            const thisYearDateData = {
                year: currentDate.year,
                month: targetMonth,
                day: targetDay,
                weekday: engine.calculateWeekday(currentDate.year, targetMonth, targetDay),
                time: currentDate.time,
            };
            const calendar = engine.getCalendar();
            const thisYearDate = new CalendarDate(thisYearDateData, calendar);
            if (this.isValidDate(thisYearDate, engine)) {
                return thisYearDate;
            }
        }
        // Move to next interval year
        const nextYear = currentDate.year + pattern.interval;
        const maxDay = engine.getMonthLength(targetMonth, nextYear);
        const nextYearDay = Math.min(targetDay, maxDay);
        const nextYearDateData = {
            year: nextYear,
            month: targetMonth,
            day: nextYearDay,
            weekday: engine.calculateWeekday(nextYear, targetMonth, nextYearDay),
            time: currentDate.time,
        };
        const calendar = engine.getCalendar();
        return new CalendarDate(nextYearDateData, calendar);
    }
    /**
     * Add days to a date using the calendar engine
     */
    static addDays(date, days, engine) {
        // Convert to world time, add days, convert back
        const worldTime = engine.dateToWorldTime(date);
        // Use calendar-specific day length instead of hardcoded 24 * 60 * 60
        const calendar = engine.getCalendar();
        const dayInSeconds = CalendarTimeUtils.getSecondsPerDay(calendar);
        const newWorldTime = worldTime + days * dayInSeconds;
        const result = engine.worldTimeToDate(newWorldTime);
        // Ensure we return a proper CalendarDate instance
        if (result instanceof CalendarDate) {
            return result;
        }
        else {
            // Convert plain object to CalendarDate instance
            return new CalendarDate(result, calendar);
        }
    }
    /**
     * Add months to a date using the calendar engine
     */
    static addMonths(date, months, engine) {
        let newYear = date.year;
        let newMonth = date.month + months;
        // Handle year overflow/underflow using calendar-specific month count
        const calendar = engine.getCalendar();
        const monthsPerYear = CalendarTimeUtils.getMonthsPerYear(calendar);
        while (newMonth > monthsPerYear) {
            newMonth -= monthsPerYear;
            newYear++;
        }
        while (newMonth < 1) {
            newMonth += monthsPerYear;
            newYear--;
        }
        // Handle day overflow (e.g., Jan 31 + 1 month should be Feb 28/29)
        const maxDay = engine.getMonthLength(newMonth, newYear);
        const newDay = Math.min(date.day, maxDay);
        const newDateData = {
            year: newYear,
            month: newMonth,
            day: newDay,
            weekday: engine.calculateWeekday(newYear, newMonth, newDay),
            time: date.time,
        };
        return new CalendarDate(newDateData, calendar);
    }
    /**
     * Get the Nth occurrence of a weekday in a month
     */
    static getNthWeekdayOfMonth(year, month, week, weekday, engine) {
        // Find first occurrence of weekday in month
        let day = 1;
        let foundWeekday = engine.calculateWeekday(year, month, day);
        const calendar = engine.getCalendar();
        const weekLength = CalendarTimeUtils.getDaysPerWeek(calendar);
        while (foundWeekday !== weekday && day <= weekLength) {
            day++;
            if (day <= engine.getMonthLength(month, year)) {
                foundWeekday = engine.calculateWeekday(year, month, day);
            }
            else {
                return null; // Weekday doesn't exist in this month
            }
        }
        // Add weeks to get to the Nth occurrence
        const targetDay = day + (week - 1) * weekLength;
        if (targetDay > engine.getMonthLength(month, year)) {
            return null; // Nth occurrence doesn't exist
        }
        const dateData = {
            year,
            month,
            day: targetDay,
            weekday: engine.calculateWeekday(year, month, targetDay),
            time: { hour: 0, minute: 0, second: 0 },
        };
        return new CalendarDate(dateData, calendar);
    }
    /**
     * Convert weekday name to number (0 = Sunday, 6 = Saturday)
     */
    static weekdayNameToNumber(weekday) {
        const mapping = {
            sunday: 0,
            monday: 1,
            tuesday: 2,
            wednesday: 3,
            thursday: 4,
            friday: 5,
            saturday: 6,
        };
        return mapping[weekday] || 0;
    }
    /**
     * Check if a date is within a range (inclusive)
     */
    static isDateInRange(date, start, end) {
        return (!CalendarTimeUtils.isDateBefore(date, start) && !CalendarTimeUtils.isDateAfter(date, end));
    }
    /**
     * Check if date A is before date B
     */
    static isDateBefore(dateA, dateB) {
        return CalendarTimeUtils.isDateBefore(dateA, dateB);
    }
    /**
     * Check if date A is after date B
     */
    static isDateAfter(dateA, dateB) {
        return CalendarTimeUtils.isDateAfter(dateA, dateB);
    }
    /**
     * Check if a date is an exception (should be skipped)
     */
    static isExceptionDate(date, exceptions) {
        return exceptions.some(exception => CalendarTimeUtils.isDateEqual(date, exception));
    }
    /**
     * Validate that a date is valid for the calendar
     */
    static isValidDate(date, engine) {
        try {
            const monthLength = engine.getMonthLength(date.month, date.year);
            return date.day >= 1 && date.day <= monthLength;
        }
        catch {
            return false;
        }
    }
    /**
     * Create a simple recurring pattern
     */
    static createSimplePattern(frequency, interval = 1, options = {}) {
        return {
            frequency,
            interval,
            ...options,
        };
    }
    /**
     * Create a weekly pattern for specific days
     */
    static createWeeklyPattern(weekdays, interval = 1, options = {}) {
        return {
            frequency: 'weekly',
            interval,
            weekdays,
            ...options,
        };
    }
    /**
     * Create a monthly pattern for a specific day
     */
    static createMonthlyDayPattern(dayOfMonth, interval = 1, options = {}) {
        return {
            frequency: 'monthly',
            interval,
            monthDay: dayOfMonth,
            ...options,
        };
    }
    /**
     * Create a monthly pattern for a specific weekday of a specific week
     */
    static createMonthlyWeekdayPattern(week, weekday, interval = 1, options = {}) {
        return {
            frequency: 'monthly',
            interval,
            monthWeek: week,
            monthWeekday: weekday,
            ...options,
        };
    }
    /**
     * Create a yearly pattern
     */
    static createYearlyPattern(month, day, interval = 1, options = {}) {
        return {
            frequency: 'yearly',
            interval,
            yearMonth: month,
            yearDay: day,
            ...options,
        };
    }
}

/**
 * Search and filtering system for calendar notes
 */
/**
 * Search and filter calendar notes
 */
class NoteSearch {
    /**
     * Search notes based on criteria
     */
    static async searchNotes(criteria) {
        const startTime = performance.now();
        // Get all calendar notes
        const allNotes = this.getAllCalendarNotes();
        // Apply filters
        let filteredNotes = allNotes;
        if (criteria.query) {
            filteredNotes = this.filterByText(filteredNotes, criteria.query);
        }
        if (criteria.dateFrom || criteria.dateTo) {
            filteredNotes = this.filterByDateRange(filteredNotes, criteria.dateFrom, criteria.dateTo);
        }
        if (criteria.categories && criteria.categories.length > 0) {
            filteredNotes = this.filterByCategories(filteredNotes, criteria.categories, false);
        }
        if (criteria.excludeCategories && criteria.excludeCategories.length > 0) {
            filteredNotes = this.filterByCategories(filteredNotes, criteria.excludeCategories, true);
        }
        if (criteria.tags && criteria.tags.length > 0) {
            filteredNotes = this.filterByTags(filteredNotes, criteria.tags, 'all');
        }
        if (criteria.anyTags && criteria.anyTags.length > 0) {
            filteredNotes = this.filterByTags(filteredNotes, criteria.anyTags, 'any');
        }
        if (criteria.excludeTags && criteria.excludeTags.length > 0) {
            filteredNotes = this.filterByTags(filteredNotes, criteria.excludeTags, 'exclude');
        }
        if (criteria.playerVisible !== undefined) {
            filteredNotes = this.filterByPlayerVisibility(filteredNotes, criteria.playerVisible);
        }
        if (criteria.isRecurring !== undefined) {
            filteredNotes = this.filterByRecurring(filteredNotes, criteria.isRecurring);
        }
        if (criteria.author) {
            filteredNotes = this.filterByAuthor(filteredNotes, criteria.author);
        }
        // Sort results
        const sortBy = criteria.sortBy || 'created';
        const sortOrder = criteria.sortOrder || 'desc';
        filteredNotes = this.sortNotes(filteredNotes, sortBy, sortOrder);
        // Apply pagination
        const totalCount = filteredNotes.length;
        const offset = criteria.offset || 0;
        const limit = criteria.limit || 50;
        const paginatedNotes = filteredNotes.slice(offset, offset + limit);
        const hasMore = offset + limit < totalCount;
        const searchTime = performance.now() - startTime;
        return {
            notes: paginatedNotes,
            totalCount,
            hasMore,
            searchTime,
        };
    }
    /**
     * Get all calendar notes
     */
    static getAllCalendarNotes() {
        return game.journal.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote === true;
        });
    }
    /**
     * Filter notes by text search in title and content
     */
    static filterByText(notes, query) {
        if (!query.trim())
            return notes;
        const searchTerms = query
            .toLowerCase()
            .split(/\s+/)
            .filter(term => term.length > 0);
        return notes.filter(note => {
            const title = note.name?.toLowerCase() || '';
            const content = note.pages.values().next().value?.text?.content?.toLowerCase() || '';
            const searchText = `${title} ${content}`;
            // All search terms must be found
            return searchTerms.every(term => searchText.includes(term));
        });
    }
    /**
     * Filter notes by date range
     */
    static filterByDateRange(notes, dateFrom, dateTo) {
        return notes.filter(note => {
            const flags = note.flags?.['seasons-and-stars'];
            if (!flags?.startDate)
                return false;
            const noteDate = flags.startDate;
            if (dateFrom && this.isDateBefore(noteDate, dateFrom)) {
                return false;
            }
            if (dateTo && this.isDateAfter(noteDate, dateTo)) {
                return false;
            }
            return true;
        });
    }
    /**
     * Filter notes by categories
     */
    static filterByCategories(notes, categories, exclude = false) {
        return notes.filter(note => {
            const flags = note.flags?.['seasons-and-stars'];
            const noteCategory = flags?.category || 'general';
            const isInCategory = categories.includes(noteCategory);
            return exclude ? !isInCategory : isInCategory;
        });
    }
    /**
     * Filter notes by tags
     */
    static filterByTags(notes, tags, mode) {
        return notes.filter(note => {
            const flags = note.flags?.['seasons-and-stars'];
            const noteTags = (flags?.tags || []).map(tag => tag.toLowerCase());
            const searchTags = tags.map(tag => tag.toLowerCase());
            switch (mode) {
                case 'all':
                    return searchTags.every(tag => noteTags.includes(tag));
                case 'any':
                    return searchTags.some(tag => noteTags.includes(tag));
                case 'exclude':
                    return !searchTags.some(tag => noteTags.includes(tag));
                default:
                    return true;
            }
        });
    }
    /**
     * Filter notes by player visibility
     */
    static filterByPlayerVisibility(notes, playerVisible) {
        return notes.filter(note => {
            const isVisible = note.ownership?.default >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
            return isVisible === playerVisible;
        });
    }
    /**
     * Filter notes by recurring status
     */
    static filterByRecurring(notes, isRecurring) {
        return notes.filter(note => {
            const flags = note.flags?.['seasons-and-stars'];
            const noteIsRecurring = flags?.isRecurringParent === true || !!flags?.recurringParentId;
            return noteIsRecurring === isRecurring;
        });
    }
    /**
     * Filter notes by author
     */
    static filterByAuthor(notes, authorId) {
        return notes.filter(note => note.author?.id === authorId);
    }
    /**
     * Sort notes by criteria
     */
    static sortNotes(notes, sortBy, sortOrder) {
        const multiplier = sortOrder === 'asc' ? 1 : -1;
        return notes.sort((a, b) => {
            let comparison = 0;
            switch (sortBy) {
                case 'title':
                    comparison = (a.name || '').localeCompare(b.name || '');
                    break;
                case 'category': {
                    const catA = a.flags?.['seasons-and-stars']?.category || 'general';
                    const catB = b.flags?.['seasons-and-stars']?.category || 'general';
                    comparison = catA.localeCompare(catB);
                    break;
                }
                case 'date': {
                    const dateA = a.flags?.['seasons-and-stars']?.startDate;
                    const dateB = b.flags?.['seasons-and-stars']?.startDate;
                    if (dateA && dateB) {
                        comparison = this.compareDates(dateA, dateB);
                    }
                    break;
                }
                case 'created': {
                    const createdA = a.flags?.['seasons-and-stars']?.created || 0;
                    const createdB = b.flags?.['seasons-and-stars']?.created || 0;
                    comparison = createdA - createdB;
                    break;
                }
                case 'modified': {
                    const modifiedA = a.flags?.['seasons-and-stars']?.modified || 0;
                    const modifiedB = b.flags?.['seasons-and-stars']?.modified || 0;
                    comparison = modifiedA - modifiedB;
                    break;
                }
            }
            return comparison * multiplier;
        });
    }
    /**
     * Compare two dates
     */
    static compareDates(dateA, dateB) {
        if (dateA.year !== dateB.year)
            return dateA.year - dateB.year;
        if (dateA.month !== dateB.month)
            return dateA.month - dateB.month;
        return dateA.day - dateB.day;
    }
    /**
     * Check if date A is before date B
     */
    static isDateBefore(dateA, dateB) {
        return this.compareDates(dateA, dateB) < 0;
    }
    /**
     * Check if date A is after date B
     */
    static isDateAfter(dateA, dateB) {
        return this.compareDates(dateA, dateB) > 0;
    }
    /**
     * Get search suggestions based on existing notes
     */
    static getSearchSuggestions() {
        const notes = this.getAllCalendarNotes();
        const categories = new Set();
        const tags = new Set();
        const authors = new Set();
        notes.forEach(note => {
            const flags = note.flags?.['seasons-and-stars'];
            // Collect categories
            if (flags?.category) {
                categories.add(flags.category);
            }
            // Collect tags
            if (flags?.tags) {
                flags.tags.forEach((tag) => tags.add(tag));
            }
            // Collect authors
            if (note.author?.name) {
                authors.add(note.author.name);
            }
        });
        return {
            categories: Array.from(categories).sort(),
            tags: Array.from(tags).sort(),
            authors: Array.from(authors).sort(),
        };
    }
    /**
     * Create quick search presets
     */
    static getSearchPresets() {
        return {
            recent: {
                sortBy: 'created',
                sortOrder: 'desc',
                limit: 10,
            },
            upcoming: {
                dateFrom: this.getCurrentDate(),
                sortBy: 'date',
                sortOrder: 'asc',
                limit: 10,
            },
            recurring: {
                isRecurring: true,
                sortBy: 'title',
                sortOrder: 'asc',
            },
            important: {
                anyTags: ['important', 'urgent'],
                sortBy: 'created',
                sortOrder: 'desc',
            },
            'player-visible': {
                playerVisible: true,
                sortBy: 'date',
                sortOrder: 'asc',
            },
        };
    }
    /**
     * Get current date from calendar manager
     */
    static getCurrentDate() {
        const currentDate = game.seasonsStars?.manager?.getCurrentDate();
        if (currentDate) {
            return currentDate;
        }
        // Fallback to a reasonable default
        const fallbackData = {
            year: 2024,
            month: 1,
            day: 1,
            weekday: 0,
            time: { hour: 0, minute: 0, second: 0 },
        };
        // Create a CalendarDate instance - need calendar for this
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar();
        if (calendar) {
            return new CalendarDate(fallbackData, calendar);
        }
        // If no calendar available, this shouldn't happen but return the data
        return fallbackData;
    }
}

/**
 * Notes management system for Seasons & Stars calendar integration
 */
/**
 * Central coordinator for all calendar note operations
 */
class NotesManager {
    constructor() {
        this.initialized = false;
        this.notesFolderId = null;
        this.storage = new NoteStorage();
    }
    /**
     * Check if the notes manager is initialized
     */
    isInitialized() {
        return this.initialized;
    }
    /**
     * Initialize the notes manager synchronously for immediate API availability
     * Defers folder creation and optimization to async operations
     */
    initializeSync() {
        if (this.initialized)
            return;
        Logger.debug('Initializing Notes Manager synchronously');
        // Initialize storage system (this is synchronous)
        try {
            this.storage.initialize();
        }
        catch (error) {
            Logger.error('Storage initialization failed during sync init:', error instanceof Error ? error : new Error(String(error)));
        }
        // Mark as initialized so basic note operations work
        this.initialized = true;
        // Schedule async initialization for folder creation and optimization
        // Use queueMicrotask for better timing guarantees than setTimeout
        queueMicrotask(async () => {
            try {
                await this.initializeNotesFolder();
                // Check if we have a large collection and optimize accordingly
                const noteCount = this.getAllCalendarNotes().length;
                if (noteCount > 500) {
                    Logger.info(`Large note collection detected (${noteCount} notes) - applying optimizations`);
                    await this.storage.optimizeForLargeCollections();
                }
                Logger.info('Notes Manager async initialization complete');
            }
            catch (error) {
                Logger.error('Failed to complete notes manager async initialization:', error instanceof Error ? error : new Error(String(error)));
            }
        });
        Logger.debug('Notes Manager synchronous initialization complete');
    }
    /**
     * Initialize the notes manager
     */
    async initialize() {
        if (this.initialized)
            return;
        Logger.info('Initializing Notes Manager');
        // Initialize storage system
        this.storage.initialize();
        // Initialize notes folder
        await this.initializeNotesFolder();
        // Check if we have a large collection and optimize accordingly
        const noteCount = this.getAllCalendarNotes().length;
        if (noteCount > 500) {
            Logger.info(`Large note collection detected (${noteCount} notes) - applying optimizations`);
            await this.storage.optimizeForLargeCollections();
        }
        this.initialized = true;
        Logger.info('Notes Manager initialized');
    }
    /**
     * Create a new calendar note
     */
    async createNote(data) {
        if (!this.initialized) {
            throw new Error('NotesManager not initialized');
        }
        const noteFolder = await this.getOrCreateNotesFolder();
        const activeCalendar = game.seasonsStars?.manager?.getActiveCalendar();
        if (!activeCalendar) {
            throw new Error('No active calendar available');
        }
        // Create the journal entry
        const journal = await JournalEntry.create({
            name: data.title,
            folder: noteFolder.id,
            ownership: data.playerVisible ? { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER } : {},
            flags: {
                'seasons-and-stars': {
                    calendarNote: true,
                    version: '1.0',
                    dateKey: this.formatDateKey(data.startDate),
                    startDate: data.startDate,
                    endDate: data.endDate,
                    allDay: data.allDay,
                    calendarId: data.calendarId || activeCalendar.id,
                    category: data.category || 'general',
                    tags: data.tags || [],
                    recurring: data.recurring,
                    isRecurringParent: !!data.recurring,
                    created: Date.now(),
                    modified: Date.now(),
                },
            },
        });
        if (!journal) {
            throw new Error('Failed to create journal entry');
        }
        // Create content page using v13 pages system
        await journal.createEmbeddedDocuments('JournalEntryPage', [
            {
                type: 'text',
                name: 'Content',
                text: { content: data.content },
            },
        ]);
        // Add to storage system
        await this.storage.storeNote(journal, data.startDate);
        // Handle recurring notes - generate initial occurrences
        if (data.recurring) {
            await this.generateRecurringOccurrences(journal, data.recurring, data.startDate);
        }
        // Emit hook for note creation
        Hooks.callAll('seasons-stars:noteCreated', journal);
        Logger.info(`Created note: ${data.title}${data.recurring ? ' (recurring)' : ''}`);
        return journal;
    }
    /**
     * Update an existing calendar note
     */
    async updateNote(noteId, data) {
        const journal = game.journal?.get(noteId);
        if (!journal) {
            throw new Error(`Note ${noteId} not found`);
        }
        // Verify this is a calendar note
        const flags = journal.flags?.['seasons-and-stars'];
        if (!flags?.calendarNote) {
            throw new Error(`Journal entry ${noteId} is not a calendar note`);
        }
        // Build update object
        const updateData = {};
        // Update basic properties
        if (data.title !== undefined) {
            updateData.name = data.title;
        }
        // Update flags
        const flagUpdates = {
            modified: Date.now(),
        };
        if (data.startDate !== undefined) {
            flagUpdates.startDate = data.startDate;
            flagUpdates.dateKey = this.formatDateKey(data.startDate);
        }
        if (data.endDate !== undefined)
            flagUpdates.endDate = data.endDate;
        if (data.allDay !== undefined)
            flagUpdates.allDay = data.allDay;
        if (data.category !== undefined)
            flagUpdates.category = data.category;
        if (data.tags !== undefined)
            flagUpdates.tags = data.tags;
        updateData['flags.seasons-and-stars'] = flagUpdates;
        // Update ownership if visibility changed
        if (data.playerVisible !== undefined) {
            updateData.ownership = data.playerVisible
                ? { default: CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER }
                : {};
        }
        await journal.update(updateData);
        // Update content if provided
        if (data.content !== undefined) {
            const pages = journal.pages;
            if (pages.size > 0) {
                const contentPage = pages.values().next().value;
                if (contentPage?.update) {
                    await contentPage.update({
                        'text.content': data.content,
                    });
                }
            }
        }
        // Emit hook for note update
        Hooks.callAll('seasons-stars:noteUpdated', journal);
        Logger.info(`Updated note: ${journal.name}`);
        return journal;
    }
    /**
     * Delete a calendar note
     */
    async deleteNote(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal) {
            throw new Error(`Note ${noteId} not found`);
        }
        // Verify this is a calendar note
        const flags = journal.flags?.['seasons-and-stars'];
        if (!flags?.calendarNote) {
            throw new Error(`Journal entry ${noteId} is not a calendar note`);
        }
        // Remove from storage system
        await this.storage.removeNote(noteId);
        await journal.delete();
        // Emit hook for note deletion
        Hooks.callAll('seasons-stars:noteDeleted', noteId);
        Logger.info(`Deleted note: ${journal.name}`);
    }
    /**
     * Get a specific calendar note
     */
    async getNote(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return null;
        // Verify this is a calendar note
        const flags = journal.flags?.['seasons-and-stars'];
        if (!flags?.calendarNote)
            return null;
        return journal;
    }
    /**
     * Get all notes for a specific date
     */
    async getNotesForDate(date) {
        if (!this.initialized) {
            throw new Error('NotesManager not initialized');
        }
        return await this.storage.findNotesByDate(date);
    }
    /**
     * Get all notes for a date range
     */
    async getNotesForDateRange(start, end) {
        if (!this.initialized) {
            throw new Error('NotesManager not initialized');
        }
        return await this.storage.findNotesByDateRange(start, end);
    }
    /**
     * Set module-specific data on a note
     */
    async setNoteModuleData(noteId, moduleId, data) {
        const journal = game.journal?.get(noteId);
        if (!journal) {
            throw new Error(`Note ${noteId} not found`);
        }
        await journal.setFlag(moduleId, 'data', data);
        // Update modification timestamp
        await journal.setFlag('seasons-and-stars', 'modified', Date.now());
    }
    /**
     * Get module-specific data from a note
     */
    getNoteModuleData(noteId, moduleId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return null;
        return journal.getFlag(moduleId, 'data');
    }
    /**
     * Initialize the notes folder if it doesn't exist
     */
    async initializeNotesFolder() {
        await this.getOrCreateNotesFolder();
    }
    /**
     * Get or create the notes folder
     */
    async getOrCreateNotesFolder() {
        // Try to find existing folder
        const existingFolder = game.folders?.find(f => f.type === 'JournalEntry' &&
            f.getFlag?.('seasons-and-stars', 'notesFolder') === true);
        if (existingFolder) {
            this.notesFolderId = existingFolder.id;
            return existingFolder;
        }
        // Create new folder
        const folder = await Folder.create({
            name: 'Calendar Notes',
            type: 'JournalEntry',
            flags: {
                'seasons-and-stars': {
                    notesFolder: true,
                    version: '1.0',
                },
            },
        });
        if (!folder) {
            throw new Error('Failed to create notes folder');
        }
        this.notesFolderId = folder.id;
        Logger.info('Created Calendar Notes folder');
        return folder;
    }
    /**
     * Format a date as a key for storage (YYYY-MM-DD format, 1-based)
     */
    formatDateKey(date) {
        const year = date.year.toString().padStart(4, '0');
        const month = date.month.toString().padStart(2, '0');
        const day = date.day.toString().padStart(2, '0');
        return `${year}-${month}-${day}`;
    }
    /**
     * Check if a date is within a range (inclusive)
     */
    isDateInRange(date, start, end) {
        return this.compareDates(date, start) >= 0 && this.compareDates(date, end) <= 0;
    }
    /**
     * Compare two dates
     */
    compareDates(a, b) {
        if (a.year !== b.year)
            return a.year - b.year;
        if (a.month !== b.month)
            return a.month - b.month;
        return a.day - b.day;
    }
    /**
     * Rebuild storage index (useful after bulk operations)
     */
    rebuildStorageIndex() {
        if (!this.initialized)
            return;
        this.storage.rebuildIndex();
    }
    /**
     * Get storage statistics for debugging
     */
    getStorageStats() {
        if (!this.initialized)
            return null;
        const stats = this.storage.getCacheStats();
        return {
            totalNotes: stats.size || 0,
            indexSize: stats.maxSize || 0,
            cacheSize: stats.size || 0,
        };
    }
    /**
     * Check if current user can create notes
     */
    canCreateNote() {
        return notePermissions.canCreateNote(game.user);
    }
    /**
     * Check if current user can edit a note
     */
    canEditNote(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return false;
        return notePermissions.canEditNote(game.user, journal);
    }
    /**
     * Check if current user can delete a note
     */
    canDeleteNote(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return false;
        return notePermissions.canDeleteNote(game.user, journal);
    }
    /**
     * Check if current user can view a note
     */
    canViewNote(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return false;
        return notePermissions.canViewNote(game.user, journal);
    }
    /**
     * Get all notes the current user can view
     */
    getUserViewableNotes() {
        return notePermissions.getViewableNotes(game.user);
    }
    /**
     * Get all notes the current user can edit
     */
    getUserEditableNotes() {
        return notePermissions.getEditableNotes(game.user);
    }
    /**
     * Search notes based on criteria
     */
    async searchNotes(criteria) {
        if (!this.initialized) {
            throw new Error('NotesManager not initialized');
        }
        return await NoteSearch.searchNotes(criteria);
    }
    /**
     * Get search suggestions based on existing notes
     */
    getSearchSuggestions() {
        return NoteSearch.getSearchSuggestions();
    }
    /**
     * Get predefined search presets
     */
    getSearchPresets() {
        return NoteSearch.getSearchPresets();
    }
    /**
     * Quick search for notes by text
     */
    async quickSearch(query, limit = 10) {
        const result = await this.searchNotes({
            query,
            limit,
            sortBy: 'created',
            sortOrder: 'desc',
        });
        return result.notes;
    }
    /**
     * Get notes for a specific category
     */
    async getNotesByCategory(category, limit) {
        const result = await this.searchNotes({
            categories: [category],
            limit,
            sortBy: 'date',
            sortOrder: 'asc',
        });
        return result.notes;
    }
    /**
     * Get notes with specific tags
     */
    async getNotesByTags(tags, matchAll = true, limit) {
        const searchCriteria = {
            limit,
            sortBy: 'date',
            sortOrder: 'asc',
        };
        if (matchAll) {
            searchCriteria.tags = tags;
        }
        else {
            searchCriteria.anyTags = tags;
        }
        const result = await this.searchNotes(searchCriteria);
        return result.notes;
    }
    /**
     * Get upcoming notes (from current date forward)
     */
    async getUpcomingNotes(limit = 20) {
        const currentDate = game.seasonsStars?.manager?.getCurrentDate();
        if (!currentDate)
            return [];
        const result = await this.searchNotes({
            dateFrom: currentDate,
            limit,
            sortBy: 'date',
            sortOrder: 'asc',
        });
        return result.notes;
    }
    /**
     * Get recent notes (by creation date)
     */
    async getRecentNotes(limit = 10) {
        const result = await this.searchNotes({
            limit,
            sortBy: 'created',
            sortOrder: 'desc',
        });
        return result.notes;
    }
    /**
     * Generate recurring occurrences for a note
     */
    async generateRecurringOccurrences(parentNote, pattern, startDate) {
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine) {
            Logger.warn('No calendar engine available for recurring note generation');
            return;
        }
        // Generate occurrences for next 2 years to start
        const currentDate = game.seasonsStars?.manager?.getCurrentDate();
        if (!currentDate)
            return;
        const rangeStart = currentDate;
        const rangeEndData = {
            year: rangeStart.year + 2,
            month: rangeStart.month,
            day: rangeStart.day,
            weekday: rangeStart.weekday,
            time: rangeStart.time,
        };
        const calendar = game.seasonsStars?.manager?.getActiveCalendar();
        const rangeEnd = calendar ? new CalendarDate(rangeEndData, calendar) : rangeStart;
        const occurrences = NoteRecurrence.generateOccurrences(startDate, pattern, rangeStart, rangeEnd, engine);
        Logger.info(`Generating ${occurrences.length} recurring occurrences`);
        // Create notes for each occurrence (except exceptions)
        for (const occurrence of occurrences) {
            if (occurrence.isException || occurrence.index === 0) {
                continue; // Skip exceptions and the original note
            }
            await this.createRecurringOccurrence(parentNote, occurrence.date);
        }
    }
    /**
     * Create a single recurring occurrence note
     */
    async createRecurringOccurrence(parentNote, occurrenceDate) {
        const noteFolder = await this.getOrCreateNotesFolder();
        const parentFlags = parentNote.flags['seasons-and-stars'];
        const parentContent = parentNote.pages.values().next().value?.text?.content || '';
        // Create the occurrence note
        const journal = await JournalEntry.create({
            name: `${parentNote.name} (${this.formatDateKey(occurrenceDate)})`,
            folder: noteFolder.id,
            ownership: parentNote.ownership,
            flags: {
                'seasons-and-stars': {
                    calendarNote: true,
                    version: '1.0',
                    dateKey: this.formatDateKey(occurrenceDate),
                    startDate: occurrenceDate,
                    endDate: parentFlags.endDate,
                    allDay: parentFlags.allDay,
                    calendarId: parentFlags.calendarId,
                    category: parentFlags.category,
                    tags: parentFlags.tags,
                    recurringParentId: parentNote.id,
                    isRecurringParent: false,
                    created: Date.now(),
                    modified: Date.now(),
                },
            },
        });
        if (!journal) {
            throw new Error('Failed to create recurring occurrence');
        }
        // Create content page
        await journal.createEmbeddedDocuments('JournalEntryPage', [
            {
                type: 'text',
                name: 'Content',
                text: { content: parentContent },
            },
        ]);
        // Add to storage system
        await this.storage.storeNote(journal, occurrenceDate);
        return journal;
    }
    /**
     * Get all recurring occurrences for a parent note
     */
    getRecurringOccurrences(parentNoteId) {
        return game.journal.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote && flags?.recurringParentId === parentNoteId;
        });
    }
    /**
     * Delete recurring note and all its occurrences
     */
    async deleteRecurringNote(parentNoteId) {
        const parentNote = game.journal?.get(parentNoteId);
        if (!parentNote) {
            throw new Error(`Parent note ${parentNoteId} not found`);
        }
        // Check permissions
        if (!notePermissions.canDeleteNote(game.user, parentNote)) {
            throw new Error('Insufficient permissions to delete recurring note');
        }
        // Get all occurrences
        const occurrences = this.getRecurringOccurrences(parentNoteId);
        // Delete all occurrences first
        for (const occurrence of occurrences) {
            await this.deleteNote(occurrence.id);
        }
        // Delete the parent note
        await this.deleteNote(parentNoteId);
        Logger.info(`Deleted recurring note and ${occurrences.length} occurrences`);
    }
    /**
     * Update recurring pattern for a note
     */
    async updateRecurringPattern(parentNoteId, newPattern) {
        const parentNote = game.journal?.get(parentNoteId);
        if (!parentNote) {
            throw new Error(`Parent note ${parentNoteId} not found`);
        }
        // Check permissions
        if (!notePermissions.canEditNote(game.user, parentNote)) {
            throw new Error('Insufficient permissions to update recurring note');
        }
        // Update the parent note's pattern
        await parentNote.setFlag('seasons-and-stars', 'recurring', newPattern);
        await parentNote.setFlag('seasons-and-stars', 'modified', Date.now());
        // Delete existing occurrences
        const existingOccurrences = this.getRecurringOccurrences(parentNoteId);
        for (const occurrence of existingOccurrences) {
            await this.deleteNote(occurrence.id);
        }
        // Generate new occurrences
        const startDate = parentNote.flags['seasons-and-stars'].startDate;
        await this.generateRecurringOccurrences(parentNote, newPattern, startDate);
        Logger.info('Updated recurring pattern and regenerated occurrences');
    }
    /**
     * Check if a note is a recurring parent
     */
    isRecurringParent(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return false;
        const flags = journal.flags?.['seasons-and-stars'];
        return flags?.calendarNote && flags?.isRecurringParent === true;
    }
    /**
     * Check if a note is a recurring occurrence
     */
    isRecurringOccurrence(noteId) {
        const journal = game.journal?.get(noteId);
        if (!journal)
            return false;
        const flags = journal.flags?.['seasons-and-stars'];
        return flags?.calendarNote && !!flags?.recurringParentId;
    }
    /**
     * Get the parent note for a recurring occurrence
     */
    getRecurringParent(occurrenceId) {
        const occurrence = game.journal?.get(occurrenceId);
        if (!occurrence)
            return null;
        const parentId = occurrence.flags?.['seasons-and-stars']?.recurringParentId;
        if (!parentId)
            return null;
        return game.journal?.get(parentId) || null;
    }
    /**
     * Get all calendar notes in the system
     */
    getAllCalendarNotes() {
        if (!game.journal)
            return [];
        return game.journal.filter(journal => {
            const flags = journal.flags?.['seasons-and-stars'];
            return flags?.calendarNote === true;
        });
    }
    /**
     * Get performance metrics for monitoring
     */
    getPerformanceMetrics() {
        return this.storage.getPerformanceMetrics();
    }
    /**
     * Optimize the notes system for better performance
     */
    async optimizePerformance() {
        Logger.info('Starting notes system optimization...');
        await this.storage.optimizeForLargeCollections();
        // Clean up any orphaned data
        await this.cleanupOrphanedData();
        Logger.info('Notes system optimization completed');
    }
    /**
     * Clean up orphaned data
     */
    async cleanupOrphanedData() {
        const allNotes = this.getAllCalendarNotes();
        let orphanedCount = 0;
        for (const note of allNotes) {
            const flags = note.flags?.['seasons-and-stars'];
            // Check for recurring orphans
            if (flags?.recurringParentId) {
                const parent = game.journal?.get(flags.recurringParentId);
                if (!parent) {
                    Logger.warn(`Found orphaned recurring note: ${note.id}`);
                    // Could optionally clean up or convert to standalone note
                    orphanedCount++;
                }
            }
        }
        if (orphanedCount > 0) {
            Logger.info(`Found ${orphanedCount} orphaned notes during cleanup`);
        }
    }
}

/**
 * Note categories and tagging system for calendar notes
 */
/**
 * Default note categories with icons and colors
 */
const DEFAULT_CATEGORIES = [
    {
        id: 'general',
        name: 'General',
        icon: 'fas fa-sticky-note',
        color: '#4a90e2',
        description: 'General notes and reminders',
        isDefault: true,
    },
    {
        id: 'event',
        name: 'Event',
        icon: 'fas fa-calendar-star',
        color: '#7b68ee',
        description: 'Special events and occasions',
    },
    {
        id: 'reminder',
        name: 'Reminder',
        icon: 'fas fa-bell',
        color: '#ffa500',
        description: 'Important reminders and deadlines',
    },
    {
        id: 'weather',
        name: 'Weather',
        icon: 'fas fa-cloud-sun',
        color: '#87ceeb',
        description: 'Weather conditions and patterns',
    },
    {
        id: 'story',
        name: 'Story',
        icon: 'fas fa-book-open',
        color: '#98fb98',
        description: 'Story events and narrative notes',
    },
    {
        id: 'combat',
        name: 'Combat',
        icon: 'fas fa-crossed-swords',
        color: '#dc143c',
        description: 'Combat encounters and battles',
    },
    {
        id: 'travel',
        name: 'Travel',
        icon: 'fas fa-route',
        color: '#daa520',
        description: 'Travel plans and journey notes',
    },
    {
        id: 'npc',
        name: 'NPC',
        icon: 'fas fa-users',
        color: '#9370db',
        description: 'Non-player character events',
    },
];
/**
 * Default predefined tags for common use cases
 */
const DEFAULT_TAGS = [
    'important',
    'urgent',
    'recurring',
    'party',
    'player',
    'gm-only',
    'public',
    'private',
    'completed',
    'in-progress',
    'planned',
    'cancelled',
];
/**
 * Manages note categories and tags
 */
class NoteCategories {
    constructor() {
        this.config = this.loadConfiguration();
    }
    /**
     * Load category configuration from game settings
     */
    loadConfiguration() {
        const savedConfig = game.settings.get('seasons-and-stars', 'noteCategories');
        if (savedConfig && savedConfig.categories) {
            // Merge saved categories with defaults, ensuring defaults exist
            const savedIds = new Set(savedConfig.categories.map(c => c.id));
            const missingDefaults = DEFAULT_CATEGORIES.filter(c => !savedIds.has(c.id));
            return {
                categories: [...savedConfig.categories, ...missingDefaults],
                allowCustomTags: savedConfig.allowCustomTags ?? true,
                predefinedTags: savedConfig.predefinedTags || DEFAULT_TAGS,
            };
        }
        return {
            categories: [...DEFAULT_CATEGORIES],
            allowCustomTags: true,
            predefinedTags: [...DEFAULT_TAGS],
        };
    }
    /**
     * Save category configuration to game settings
     */
    async saveConfiguration() {
        await game.settings.set('seasons-and-stars', 'noteCategories', this.config);
    }
    /**
     * Get all available categories
     */
    getCategories() {
        return [...this.config.categories];
    }
    /**
     * Get category by ID
     */
    getCategory(id) {
        return this.config.categories.find(c => c.id === id) || null;
    }
    /**
     * Get default category
     */
    getDefaultCategory() {
        return this.config.categories.find(c => c.isDefault) || this.config.categories[0];
    }
    /**
     * Add a new category
     */
    async addCategory(category) {
        // Validate category
        if (!category.id || !category.name) {
            throw new Error('Category must have id and name');
        }
        // Check for duplicate ID
        if (this.config.categories.find(c => c.id === category.id)) {
            throw new Error(`Category with id '${category.id}' already exists`);
        }
        this.config.categories.push(category);
        await this.saveConfiguration();
    }
    /**
     * Update an existing category
     */
    async updateCategory(id, updates) {
        const index = this.config.categories.findIndex(c => c.id === id);
        if (index === -1) {
            throw new Error(`Category with id '${id}' not found`);
        }
        // Don't allow changing ID
        if (updates.id && updates.id !== id) {
            throw new Error('Cannot change category ID');
        }
        this.config.categories[index] = { ...this.config.categories[index], ...updates };
        await this.saveConfiguration();
    }
    /**
     * Remove a category
     */
    async removeCategory(id) {
        const category = this.getCategory(id);
        if (!category) {
            throw new Error(`Category with id '${id}' not found`);
        }
        // Prevent removal of default categories
        if (category.isDefault) {
            throw new Error('Cannot remove default category');
        }
        this.config.categories = this.config.categories.filter(c => c.id !== id);
        await this.saveConfiguration();
    }
    /**
     * Get all predefined tags
     */
    getPredefinedTags() {
        return [...this.config.predefinedTags];
    }
    /**
     * Add a predefined tag
     */
    async addPredefinedTag(tag) {
        if (!tag || typeof tag !== 'string') {
            throw new Error('Tag must be a non-empty string');
        }
        const normalizedTag = tag.toLowerCase().trim();
        if (this.config.predefinedTags.includes(normalizedTag)) {
            return; // Already exists
        }
        this.config.predefinedTags.push(normalizedTag);
        await this.saveConfiguration();
    }
    /**
     * Remove a predefined tag
     */
    async removePredefinedTag(tag) {
        const normalizedTag = tag.toLowerCase().trim();
        this.config.predefinedTags = this.config.predefinedTags.filter(t => t !== normalizedTag);
        await this.saveConfiguration();
    }
    /**
     * Check if custom tags are allowed
     */
    areCustomTagsAllowed() {
        return this.config.allowCustomTags;
    }
    /**
     * Set whether custom tags are allowed
     */
    async setCustomTagsAllowed(allowed) {
        this.config.allowCustomTags = allowed;
        await this.saveConfiguration();
    }
    /**
     * Validate tags against configuration
     */
    validateTags(tags) {
        const valid = [];
        const invalid = [];
        for (const tag of tags) {
            const normalizedTag = tag.toLowerCase().trim();
            if (this.config.predefinedTags.includes(normalizedTag)) {
                valid.push(normalizedTag);
            }
            else if (this.config.allowCustomTags) {
                valid.push(normalizedTag);
            }
            else {
                invalid.push(tag);
            }
        }
        return { valid, invalid };
    }
    /**
     * Parse tag string into array of tags
     */
    parseTagString(tagString) {
        if (!tagString)
            return [];
        return tagString
            .split(/[,;]/) // Split on comma or semicolon
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0)
            .map(tag => tag.toLowerCase());
    }
    /**
     * Format tags array into string
     */
    formatTagsToString(tags) {
        return tags.join(', ');
    }
    /**
     * Get category color for styling
     */
    getCategoryColor(categoryId) {
        const category = this.getCategory(categoryId);
        return category?.color || '#4a90e2';
    }
    /**
     * Get category icon for display
     */
    getCategoryIcon(categoryId) {
        const category = this.getCategory(categoryId);
        return category?.icon || 'fas fa-sticky-note';
    }
    /**
     * Search categories by name
     */
    searchCategories(query) {
        if (!query)
            return this.getCategories();
        const lowercaseQuery = query.toLowerCase();
        return this.config.categories.filter(category => category.name.toLowerCase().includes(lowercaseQuery) ||
            category.description?.toLowerCase().includes(lowercaseQuery));
    }
}
// Global instance - initialized manually in module.ts after settings are registered
let noteCategories;
/**
 * Initialize the global noteCategories instance
 * Called from module.ts after settings are registered
 */
function initializeNoteCategories() {
    noteCategories = new NoteCategories();
}

/**
 * Calendar Selection Dialog for Seasons & Stars
 * Allows users to browse and switch between available calendars
 */
class CalendarSelectionDialog extends foundry.applications.api.HandlebarsApplicationMixin(foundry.applications.api.ApplicationV2) {
    constructor(calendars, currentCalendarId, collectionEntries, externalSources) {
        super();
        this.selectedCalendarId = null;
        Logger.debug('CalendarSelectionDialog constructor', {
            type: typeof calendars,
            isMap: calendars instanceof Map,
            calendars,
            collectionEntries,
        });
        // Convert array to Map if needed
        if (Array.isArray(calendars)) {
            Logger.debug('Converting array to Map');
            this.calendars = new Map();
            calendars.forEach((calendar, index) => {
                const id = calendar.id || String(index);
                this.calendars.set(id, calendar);
            });
            Logger.debug('Converted calendars Map', this.calendars);
        }
        else if (calendars instanceof Map) {
            this.calendars = calendars;
        }
        else {
            Logger.error('Unsupported calendars type', new Error(`Type: ${typeof calendars}`));
            this.calendars = new Map();
        }
        // Store collection entries metadata (if available)
        this.collectionEntries = collectionEntries || new Map();
        // Store external sources metadata (if available)
        this.externalSources = externalSources || new Map();
        // Check if a file picker calendar is currently active
        const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
        const activeCalendarSetting = game.settings?.get('seasons-and-stars', 'activeCalendar') || '';
        // File picker is active if there's a file path AND no regular calendar setting
        const filePickerActive = selectedFilePath !== '' && activeCalendarSetting === '';
        if (filePickerActive) {
            // File picker is currently the active mode
            this.currentCalendarId = '__FILE_PICKER__';
            this.selectedCalendarId = '__FILE_PICKER__';
            Logger.debug('Dialog initialized with file picker active:', {
                selectedFilePath,
                activeCalendarSetting,
            });
        }
        else {
            this.currentCalendarId = currentCalendarId;
            this.selectedCalendarId = currentCalendarId;
            Logger.debug('Dialog initialized with regular calendar:', {
                currentCalendarId,
                selectedFilePath,
                activeCalendarSetting,
            });
        }
    }
    /** @override */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async _prepareContext(options = {}) {
        const context = await super._prepareContext(options);
        // Get file picker state
        const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
        const activeCalendarSetting = game.settings?.get('seasons-and-stars', 'activeCalendar') || '';
        // File picker is active if there's a file path AND no regular calendar setting
        const filePickerActive = selectedFilePath !== '' && activeCalendarSetting === '';
        // Update current calendar ID based on actual settings (dynamic detection)
        if (filePickerActive) {
            this.currentCalendarId = '__FILE_PICKER__';
        }
        else if (activeCalendarSetting) {
            this.currentCalendarId = activeCalendarSetting;
        }
        const showFilePicker = true;
        const calendarsData = Array.from(this.calendars.entries()).map(([id, calendar]) => {
            const label = CalendarLocalization.getCalendarLabel(calendar);
            const description = CalendarLocalization.getCalendarDescription(calendar);
            const setting = CalendarLocalization.getCalendarSetting(calendar);
            // Check if this is a calendar variant
            const isVariant = id.includes('(') && id.includes(')');
            let variantInfo = '';
            let baseCalendarId = id;
            if (isVariant) {
                // Extract base calendar ID and variant name
                const match = id.match(/^(.+)\((.+)\)$/);
                if (match) {
                    baseCalendarId = match[1];
                    const variantId = match[2];
                    variantInfo = `Variant: ${variantId.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
                }
            }
            // Determine the source type and metadata
            const sourceInfo = this.getCalendarSourceInfo(id);
            // Use collection preview if available, otherwise generate sample date
            const collectionEntry = this.collectionEntries.get(id);
            const sampleDate = collectionEntry?.preview || this.generateSampleDate(calendar);
            // Generate mini widget preview (use collection preview for consistency if available)
            const miniPreview = collectionEntry?.preview || this.generateMiniWidgetPreview(calendar);
            return {
                id,
                label,
                description,
                setting,
                sampleDate,
                miniPreview,
                isCurrent: id === this.currentCalendarId,
                isSelected: id === this.selectedCalendarId,
                isVariant,
                variantInfo,
                baseCalendarId,
                sourceType: sourceInfo.type,
                sourceIcon: sourceInfo.icon,
                sourceLabel: sourceInfo.label,
                sourceDescription: sourceInfo.description,
                isModuleSource: sourceInfo.type === 'module',
                isBuiltinSource: sourceInfo.type === 'builtin',
                isExternalSource: sourceInfo.type === 'external',
            };
        });
        // Group calendars hierarchically by base calendar
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const calendarGroups = new Map();
        for (const calendar of calendarsData) {
            if (!calendarGroups.has(calendar.baseCalendarId)) {
                calendarGroups.set(calendar.baseCalendarId, { base: null, variants: [] });
            }
            const group = calendarGroups.get(calendar.baseCalendarId);
            if (!group)
                continue;
            if (calendar.isVariant) {
                group.variants.push(calendar);
            }
            else {
                group.base = calendar;
            }
        }
        // Sort groups with Gregorian first, then alphabetically
        const sortedGroups = Array.from(calendarGroups.entries()).sort(([aId, aGroup], [bId, bGroup]) => {
            // Gregorian calendar always comes first
            if (aId === 'gregorian')
                return -1;
            if (bId === 'gregorian')
                return 1;
            // All other calendars sorted alphabetically by display label
            const labelA = aGroup.base ? aGroup.base.label : aId;
            const labelB = bGroup.base ? bGroup.base.label : bId;
            return labelA.localeCompare(labelB);
        });
        // Build hierarchical calendar list
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const sortedCalendars = [];
        for (const [, group] of sortedGroups) {
            // Add base calendar first
            if (group.base) {
                sortedCalendars.push(group.base);
            }
            // Sort variants alphabetically and add with hierarchy indicator
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            group.variants.sort((a, b) => a.label.localeCompare(b.label));
            for (const variant of group.variants) {
                // Add visual hierarchy level for CSS styling
                variant.hierarchyLevel = 1;
                sortedCalendars.push(variant);
            }
        }
        // Determine if file picker should be considered "selected"
        // Only show as selected if there's actually a file selected AND it's either the selected ID or is currently active
        const filePickerSelected = selectedFilePath !== '' &&
            (this.selectedCalendarId === '__FILE_PICKER__' || filePickerActive);
        return Object.assign(context, {
            calendars: sortedCalendars,
            selectedCalendar: this.selectedCalendarId,
            currentCalendar: this.currentCalendarId,
            showFilePicker,
            selectedFilePath,
            filePickerActive,
            filePickerSelected,
        });
    }
    /** @override */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        Logger.debug('Attaching part listeners', { partId, element: htmlElement });
        Logger.debug('Scrollable elements', htmlElement.querySelectorAll('.calendar-selection-grid'));
        // Add action buttons to window and update button state after rendering
        this.addActionButtons($(htmlElement));
        this.updateSelectButton($(htmlElement));
        // Debug: Check if scrolling is working
        const scrollableGrid = htmlElement.querySelector('.calendar-selection-grid');
        if (scrollableGrid) {
            const style = getComputedStyle(scrollableGrid);
            Logger.debug('Found scrollable grid', {
                overflow: style.overflow,
                clientHeight: scrollableGrid.clientHeight,
                scrollHeight: scrollableGrid.scrollHeight,
            });
        }
    }
    /**
     * Add action buttons to the dialog
     */
    addActionButtons(html) {
        const footer = $(`
      <div class="dialog-buttons flexrow">
        <button data-action="cancel" type="button" class="button">
          <i class="fas fa-times"></i>
          ${game.i18n.localize('SEASONS_STARS.dialog.calendar_selection.cancel')}
        </button>
        <button data-action="chooseCalendar" type="button" class="button ss-button primary" id="select-calendar">
          <i class="fas fa-check"></i>
          ${game.i18n.localize('SEASONS_STARS.dialog.calendar_selection.select')}
        </button>
      </div>
    `);
        html.append(footer);
    }
    /**
     * Select a calendar card
     */
    selectCalendarCard(calendarId) {
        // Special handling for file picker selection
        if (calendarId === '__FILE_PICKER__') {
            const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
            if (!selectedFilePath) {
                Logger.warn('Cannot select file picker card - no file selected');
                // Open file picker instead
                this._onOpenFilePicker(new Event('click'), document.createElement('button'));
                return;
            }
        }
        this.selectedCalendarId = calendarId;
        // Re-render to update UI state
        this.render(true);
    }
    /**
     * Update the select button state
     */
    updateSelectButton(html) {
        const $html = html || (this.element ? $(this.element) : $());
        const selectButton = $html.find('#select-calendar');
        const isDifferent = this.selectedCalendarId !== this.currentCalendarId;
        selectButton.prop('disabled', !isDifferent);
        selectButton.toggleClass('disabled', !isDifferent);
        if (isDifferent && this.selectedCalendarId) {
            let label;
            if (this.selectedCalendarId === '__FILE_PICKER__') {
                // Handle file picker case - show file name
                const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
                const fileName = selectedFilePath
                    ? selectedFilePath.split('/').pop() || 'Custom File'
                    : 'Custom File';
                label = fileName;
            }
            else {
                // Handle regular calendar case
                const calendar = this.calendars.get(this.selectedCalendarId);
                label = calendar
                    ? CalendarLocalization.getCalendarLabel(calendar)
                    : this.selectedCalendarId;
            }
            selectButton.html(`<i class="fas fa-check"></i> Switch to ${label}`);
        }
        else {
            selectButton.html(`<i class="fas fa-check"></i> Select Calendar`);
        }
    }
    /**
     * Show preview for a calendar
     */
    showPreview(calendarId) {
        const calendar = this.calendars.get(calendarId);
        if (!calendar)
            return;
        const label = CalendarLocalization.getCalendarLabel(calendar);
        const description = CalendarLocalization.getCalendarDescription(calendar);
        const setting = CalendarLocalization.getCalendarSetting(calendar);
        // Generate multiple sample dates
        const samples = [
            this.generateSampleDate(calendar, 1),
            this.generateSampleDate(calendar, 100),
            this.generateSampleDate(calendar, 365),
        ];
        const content = `
      <div class="calendar-preview">
        <div class="preview-header">
          <h3>${label}</h3>
          <div class="preview-setting">${setting}</div>
        </div>
        <div class="preview-description">${description}</div>
        <div class="preview-samples">
          <h4>${game.i18n.localize('SEASONS_STARS.dialog.calendar_selection.sample_dates')}</h4>
          ${samples.map(sample => `<div class="sample-date">${sample}</div>`).join('')}
        </div>
        <div class="preview-structure">
          <h4>${game.i18n.localize('SEASONS_STARS.dialog.calendar_selection.structure')}</h4>
          <div class="structure-info">
            <div><strong>${game.i18n.localize('SEASONS_STARS.calendar.months')}:</strong> ${calendar.months.length}</div>
            <div><strong>${game.i18n.localize('SEASONS_STARS.calendar.days_per_week')}:</strong> ${calendar.weekdays.length}</div>
            ${calendar.leapYear ? `<div><strong>${game.i18n.localize('SEASONS_STARS.calendar.leap_year')}:</strong> ${game.i18n.localize('SEASONS_STARS.calendar.enabled')}</div>` : ''}
          </div>
        </div>
      </div>
    `;
        new foundry.applications.api.DialogV2({
            window: {
                title: game.i18n.format('SEASONS_STARS.dialog.calendar_preview.title', { calendar: label }),
            },
            content,
            buttons: [
                {
                    action: 'close',
                    icon: 'fas fa-times',
                    label: game.i18n.localize('SEASONS_STARS.dialog.close'),
                    callback: () => { },
                },
            ],
            default: 'close',
            classes: ['seasons-stars', 'calendar-preview-dialog'],
            position: {
                width: 400,
                height: 'auto',
            },
        }).render(true);
    }
    /**
     * Generate a sample date for preview
     */
    generateSampleDate(calendar, dayOffset = 1) {
        // Use current world time if no offset, otherwise use offset from a reasonable base
        let totalDays;
        if (dayOffset === 1) {
            // Use current world time for default sample
            const currentTime = game.time?.worldTime || 0;
            Logger.debug(`Using current world time for sample: ${currentTime} seconds`);
            // Use calendar-specific day length instead of hardcoded 86400
            const secondsPerDay = CalendarTimeUtils.getSecondsPerDay(calendar);
            totalDays = Math.floor(currentTime / secondsPerDay);
            Logger.debug(`Converted to total days: ${totalDays}`);
        }
        else {
            // Use offset for other samples
            totalDays = dayOffset;
            Logger.debug(`Using offset days for sample: ${totalDays}`);
        }
        // Use approximate year calculation for sample generation
        // For accurate date calculation, use the calendar engine, but this is just for preview samples
        const approximateYearLength = CalendarTimeUtils.getApproximateYearLength(calendar);
        const year = 1000 + Math.floor(totalDays / approximateYearLength);
        const dayInYear = totalDays % approximateYearLength;
        Logger.debug('Calculated year and day in year', { year, dayInYear });
        let remainingDays = dayInYear;
        let monthIndex = 0;
        // Find the month
        for (let i = 0; i < calendar.months.length; i++) {
            const monthDays = calendar.months[i].days;
            if (remainingDays <= monthDays) {
                monthIndex = i;
                break;
            }
            remainingDays -= monthDays;
        }
        const month = calendar.months[monthIndex];
        const day = Math.max(1, remainingDays);
        const weekdayIndex = (dayOffset - 1) % calendar.weekdays.length;
        const weekday = calendar.weekdays[weekdayIndex];
        // Create a proper CalendarDate object and use the calendar's dateFormats
        const calendarDate = {
            year: year,
            month: monthIndex + 1, // CalendarDate expects 1-based months
            day: day,
            weekday: weekdayIndex,
            time: { hour: 12, minute: 0, second: 0 }, // Use noon for preview
        };
        try {
            // Use CalendarDate's formatting which respects the calendar's dateFormats
            const calendarDateInstance = new CalendarDate(calendarDate, calendar);
            return calendarDateInstance.toLongString();
        }
        catch (error) {
            Logger.warn('Failed to use calendar date formatting, falling back to manual format:', error);
            // Fallback to manual formatting if CalendarDate fails
            const monthLabel = CalendarLocalization.getCalendarTranslation(calendar, `months.${month.id || month.name}`, month.name);
            const weekdayLabel = CalendarLocalization.getCalendarTranslation(calendar, `weekdays.${weekday.id || weekday.name}`, weekday.name);
            return `${weekdayLabel}, ${monthLabel} ${day}, ${year}`;
        }
    }
    /**
     * Determine the source type and metadata for a calendar
     */
    getCalendarSourceInfo(calendarId) {
        // Get the calendar object to check for source information
        const calendar = this.calendars.get(calendarId);
        // Use the stored source information if available
        if (calendar?.sourceInfo) {
            return {
                type: calendar.sourceInfo.type,
                icon: calendar.sourceInfo.icon,
                label: calendar.sourceInfo.sourceName,
                description: calendar.sourceInfo.description,
            };
        }
        // Fallback for calendars without source information (shouldn't happen with new system)
        Logger.warn(`Calendar ${calendarId} missing source information, using fallback detection`);
        return {
            type: 'builtin',
            icon: 'fa-solid fa-question-circle',
            label: 'Unknown Source',
            description: 'Calendar source information not available',
        };
    }
    /**
     * Generate mini widget preview for calendar selection
     */
    generateMiniWidgetPreview(calendar) {
        // Create a sample CalendarDate to demonstrate mini widget formatting
        const sampleDate = {
            year: 2370,
            month: 1,
            day: 15,
            weekday: 1,
            time: { hour: 12, minute: 0, second: 0 },
        };
        try {
            // Create CalendarDate instance and use toShortString()
            const calendarDateInstance = new CalendarDate(sampleDate, calendar);
            return calendarDateInstance.toShortString();
        }
        catch (error) {
            Logger.warn('Failed to generate mini widget preview, using fallback:', error);
            // Fallback to basic format
            const monthName = calendar.months?.[0]?.abbreviation || calendar.months?.[0]?.name || 'Jan';
            const yearString = calendar.year?.prefix + sampleDate.year + (calendar.year?.suffix || '');
            return `${sampleDate.day} ${monthName} ${yearString}`;
        }
    }
    /**
     * Update current calendar state based on actual settings
     */
    async _updateCurrentCalendarState() {
        const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
        const activeCalendarSetting = game.settings?.get('seasons-and-stars', 'activeCalendar') || '';
        Logger.debug('_updateCurrentCalendarState settings:', {
            selectedFilePath,
            activeCalendarSetting,
        });
        // File picker is active if there's a file path AND no regular calendar setting
        const filePickerActive = selectedFilePath !== '' && activeCalendarSetting === '';
        Logger.debug('File picker detection:', { filePickerActive });
        // When file picker is active, we should treat it as the "current" calendar for dialog purposes
        if (filePickerActive) {
            this.currentCalendarId = '__FILE_PICKER__';
        }
        else if (activeCalendarSetting) {
            this.currentCalendarId = activeCalendarSetting;
        }
        Logger.debug('Updated currentCalendarId to:', this.currentCalendarId);
    }
    /**
     * Handle calendar selection
     */
    async selectCalendar() {
        // Ensure dialog state is up-to-date before processing selection
        await this._updateCurrentCalendarState();
        Logger.debug('selectCalendar called:', {
            selectedCalendarId: this.selectedCalendarId,
            currentCalendarId: this.currentCalendarId,
            condition: this.selectedCalendarId && this.selectedCalendarId !== this.currentCalendarId,
        });
        if (this.selectedCalendarId && this.selectedCalendarId !== this.currentCalendarId) {
            if (this.selectedCalendarId === '__FILE_PICKER__') {
                // Handle file picker selection
                const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
                if (!selectedFilePath) {
                    Logger.debug('No custom calendar file selected, user must select a file first');
                    // Open file picker instead of showing error
                    await this._onOpenFilePicker(new Event('click'), document.createElement('button'));
                    return;
                }
                // Load calendar from file path
                Logger.debug('Loading calendar from file via selectCalendar:', selectedFilePath);
                const calendarManager = game.seasonsStars?.manager;
                if (!calendarManager) {
                    Logger.error('Calendar manager not available for file loading');
                    return;
                }
                const fileUrl = calendarManager.convertFoundryPathToUrl(selectedFilePath);
                const result = await calendarManager.loadCalendarFromUrl(fileUrl, { validate: true });
                if (result.success && result.calendar) {
                    // Create source info for the file-based calendar
                    const fileSourceInfo = {
                        type: 'external',
                        sourceName: 'Custom File',
                        description: `Calendar loaded from ${selectedFilePath}`,
                        icon: 'fa-solid fa-file',
                        url: fileUrl,
                    };
                    // Add the calendar to the manager's calendar map
                    const loadSuccess = calendarManager.loadCalendar(result.calendar, fileSourceInfo);
                    if (loadSuccess) {
                        // Clear regular calendar setting if it's currently set
                        const currentActiveCalendar = game.settings?.get('seasons-and-stars', 'activeCalendar') || '';
                        if (currentActiveCalendar) {
                            await game.settings?.set('seasons-and-stars', 'activeCalendar', '');
                        }
                        // Set the calendar as active, but don't save to activeCalendar setting
                        await calendarManager.setActiveCalendar(result.calendar.id, false);
                        Logger.info('Successfully loaded and activated calendar from file:', selectedFilePath);
                        // Notify user
                        ui.notifications?.info(game.i18n.format('SEASONS_STARS.notifications.calendar_changed', {
                            calendar: `Custom File: ${selectedFilePath.split('/').pop()}`,
                        }));
                    }
                    else {
                        Logger.error('Failed to load calendar into manager:', new Error(`Validation failed for ${selectedFilePath}`));
                        ui.notifications?.error(game.i18n.format('SEASONS_STARS.errors.calendar_file_load_failed', {
                            path: selectedFilePath,
                            error: 'Calendar validation failed',
                        }));
                        return;
                    }
                }
                else {
                    Logger.error('Failed to load calendar from file:', new Error(result.error || 'Unknown error'));
                    ui.notifications?.error(game.i18n.format('SEASONS_STARS.errors.calendar_file_load_failed', {
                        path: selectedFilePath,
                        error: result.error || 'Unknown error',
                    }));
                    return;
                }
            }
            else {
                // Switch to a regular calendar
                await game.settings?.set('seasons-and-stars', 'activeCalendar', this.selectedCalendarId);
                // Clear file picker setting to ensure regular calendar takes precedence
                await game.settings?.set('seasons-and-stars', 'activeCalendarFile', '');
                // Notify user
                const calendar = this.calendars.get(this.selectedCalendarId);
                const label = calendar
                    ? CalendarLocalization.getCalendarLabel(calendar)
                    : this.selectedCalendarId;
                ui.notifications?.info(game.i18n.format('SEASONS_STARS.notifications.calendar_changed', { calendar: label }));
            }
        }
    }
    /**
     * Instance action handler for calendar card selection
     */
    async _onSelectCalendar(event, target) {
        Logger.debug('Calendar card clicked', { event, target });
        const calendarId = target.getAttribute('data-calendar-id');
        Logger.debug(`Found calendar ID for selection: ${calendarId}`);
        if (calendarId) {
            Logger.debug(`Calling selectCalendarCard with ID: ${calendarId}`);
            this.selectCalendarCard(calendarId);
        }
        else {
            Logger.warn('Selection action failed - no calendar ID found');
        }
    }
    /**
     * Instance action handler for calendar preview
     */
    async _onPreviewCalendar(event, target) {
        Logger.debug('Preview button clicked', { event, target });
        Logger.debug('Calendars data', {
            type: typeof this.calendars,
            isMap: this.calendars instanceof Map,
            calendars: this.calendars,
        });
        event.stopPropagation();
        const calendarId = target.closest('[data-calendar-id]')?.getAttribute('data-calendar-id');
        Logger.debug(`Found calendar ID: ${calendarId}`);
        if (calendarId) {
            Logger.debug(`Calling showPreview with ID: ${calendarId}`);
            this.showPreview(calendarId);
        }
        else {
            Logger.warn('Preview action failed - no calendar ID found');
        }
    }
    /**
     * Instance action handler for choosing calendar
     */
    async _onChooseCalendar(event, target) {
        Logger.debug('Choose calendar clicked', { event, target });
        await this.selectCalendar();
        this.close();
    }
    /**
     * Instance action handler for cancel
     */
    async _onCancel(event, target) {
        Logger.debug('Cancel clicked', { event, target });
        this.close();
    }
    /**
     * Instance action handler for opening file picker
     */
    async _onOpenFilePicker(event, target) {
        Logger.debug('File picker action triggered', { event, target });
        // Check if we clicked on the card itself (should select it as the active choice)
        const isCardClick = target.closest('.file-picker-card') && !target.closest('.card-actions');
        if (isCardClick) {
            // If clicking on the file picker card itself, select it (if it has a file path)
            const selectedFilePath = game.settings?.get('seasons-and-stars', 'activeCalendarFile') || '';
            if (selectedFilePath) {
                Logger.debug('File picker card selected with existing path', { selectedFilePath });
                this.selectedCalendarId = '__FILE_PICKER__'; // Special ID for file picker
                this.render(true);
                return;
            }
        }
        // Otherwise, open the file picker dialog
        try {
            // @ts-expect-error - FilePicker is available at runtime but TypeScript types may not reflect the full structure
            const filePicker = new foundry.applications.apps.FilePicker({
                type: 'data',
                extensions: ['.json'],
                callback: async (path) => {
                    Logger.debug('File selected', { path });
                    // Store the selected file path in settings - this triggers onChange handler
                    await game.settings.set('seasons-and-stars', 'activeCalendarFile', path);
                    // Update dialog state immediately - file picker is now selected
                    this.selectedCalendarId = '__FILE_PICKER__';
                    // Re-render dialog to show updated state
                    this.render(true);
                },
            });
            await filePicker.render(true);
        }
        catch (error) {
            Logger.error('Failed to open file picker:', error);
            ui.notifications?.error(game.i18n.localize('SEASONS_STARS.errors.file_picker_failed'));
        }
    }
    /**
     * Instance action handler for clearing file picker selection
     */
    async _onClearFilePicker(event, target) {
        Logger.debug('Clear file picker button clicked', { event, target });
        try {
            // Clear the file picker setting
            await game.settings.set('seasons-and-stars', 'activeCalendarFile', '');
            // Re-render dialog to show updated state
            this.render(true);
        }
        catch (error) {
            Logger.error('Failed to clear file picker:', error);
            ui.notifications?.error(game.i18n.localize('SEASONS_STARS.errors.clear_file_failed'));
        }
    }
    /**
     * Static method to show the calendar selection dialog
     */
    static async show() {
        if (!game.seasonsStars?.manager) {
            ui.notifications?.error(game.i18n.localize('SEASONS_STARS.errors.manager_not_ready'));
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const calendars = game.seasonsStars.manager.getAllCalendars();
        Logger.debug('CalendarSelectionDialog.show() - calendars from manager', {
            type: typeof calendars,
            isMap: calendars instanceof Map,
            calendars,
        });
        const currentCalendarId = game.settings?.get('seasons-and-stars', 'activeCalendar');
        if (calendars.size === 0) {
            ui.notifications?.warn(game.i18n.localize('SEASONS_STARS.warnings.no_calendars_available'));
            return;
        }
        // Get collection entries and external sources from CalendarLoader if available
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const calendarLoader = game.seasonsStars?.calendarLoader;
        let collectionEntries;
        let externalSources;
        if (calendarLoader) {
            try {
                // Get external sources from calendar loader
                const sources = calendarLoader.getSources();
                externalSources = new Map();
                for (const source of sources) {
                    externalSources.set(source.id, source);
                }
                // Collection entries would be populated during calendar loading
                // For now, we'll pass an empty map and the source detection will work based on external sources
                collectionEntries = new Map();
                Logger.debug('CalendarSelectionDialog.show() - external sources', {
                    sourcesCount: externalSources.size,
                    sources: Array.from(externalSources.values()),
                });
            }
            catch (error) {
                Logger.warn('Failed to get external sources from calendar loader:', error);
            }
        }
        const dialog = new CalendarSelectionDialog(calendars, currentCalendarId, collectionEntries, externalSources);
        dialog.render(true);
    }
}
CalendarSelectionDialog.DEFAULT_OPTIONS = {
    id: 'seasons-stars-calendar-selection',
    classes: ['seasons-stars', 'calendar-selection-dialog'],
    tag: 'div',
    window: {
        frame: true,
        positioned: true,
        title: 'SEASONS_STARS.dialog.calendar_selection.title',
        icon: 'fa-solid fa-calendar-alt',
        minimizable: false,
        resizable: true,
    },
    position: {
        width: 600,
        height: 750,
    },
    actions: {
        selectCalendar: CalendarSelectionDialog.prototype._onSelectCalendar,
        previewCalendar: CalendarSelectionDialog.prototype._onPreviewCalendar,
        chooseCalendar: CalendarSelectionDialog.prototype._onChooseCalendar,
        cancel: CalendarSelectionDialog.prototype._onCancel,
        openFilePicker: CalendarSelectionDialog.prototype._onOpenFilePicker,
        clearFilePicker: CalendarSelectionDialog.prototype._onClearFilePicker,
    },
};
CalendarSelectionDialog.PARTS = {
    main: {
        id: 'main',
        template: 'modules/seasons-and-stars/templates/calendar-selection-dialog.hbs',
        scrollable: ['.calendar-selection-grid'],
    },
};

var calendarSelectionDialog = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CalendarSelectionDialog: CalendarSelectionDialog
});

/**
 * Calendar Widget Manager
 *
 * Centralized widget management to break circular dependencies between widget classes.
 * Each widget type can be managed independently without direct references to other widgets.
 */
/**
 * Central manager for all calendar widgets
 * Eliminates the need for widgets to directly import each other
 */
class CalendarWidgetManager {
    /**
     * Register a widget factory function
     */
    static registerWidget(type, factory) {
        this.factories.set(type, factory);
        Logger.debug(`Registered widget factory for ${type}`);
    }
    /**
     * Get or create a widget instance
     */
    static getWidget(type) {
        let instance = this.instances.get(type);
        if (!instance) {
            const factory = this.factories.get(type);
            if (factory) {
                try {
                    instance = factory();
                    this.instances.set(type, instance);
                    Logger.debug(`Created widget instance for ${type}`);
                }
                catch (error) {
                    Logger.error(`Failed to create widget ${type}:`, error instanceof Error ? error : new Error(String(error)));
                    return null;
                }
            }
            else {
                Logger.warn(`No factory registered for widget type: ${type}`);
                return null;
            }
        }
        return instance;
    }
    /**
     * Show a specific widget type
     */
    static async showWidget(type) {
        const widget = this.getWidget(type);
        if (widget) {
            try {
                await widget.show();
                Logger.debug(`Showed widget: ${type}`);
            }
            catch (error) {
                Logger.error(`Failed to show widget ${type}:`, error instanceof Error ? error : new Error(String(error)));
            }
        }
    }
    /**
     * Hide a specific widget type
     */
    static async hideWidget(type) {
        const widget = this.getWidget(type);
        if (widget) {
            try {
                await widget.hide();
                Logger.debug(`Hid widget: ${type}`);
            }
            catch (error) {
                Logger.error(`Failed to hide widget ${type}:`, error instanceof Error ? error : new Error(String(error)));
            }
        }
    }
    /**
     * Toggle a specific widget type
     */
    static async toggleWidget(type) {
        const widget = this.getWidget(type);
        if (widget) {
            try {
                await widget.toggle();
                Logger.debug(`Toggled widget: ${type}`);
            }
            catch (error) {
                Logger.error(`Failed to toggle widget ${type}:`, error instanceof Error ? error : new Error(String(error)));
            }
        }
    }
    /**
     * Switch to a specific widget type, hiding others
     */
    static async switchToWidget(type, hideOthers = false) {
        if (hideOthers) {
            // Hide all other widgets first
            for (const [otherType] of this.instances) {
                if (otherType !== type) {
                    await this.hideWidget(otherType);
                }
            }
        }
        await this.showWidget(type);
    }
    /**
     * Check if a widget is visible
     */
    static isWidgetVisible(type) {
        const widget = this.getWidget(type);
        return widget ? widget.isVisible() : false;
    }
    /**
     * Get the actual widget instance for direct access
     */
    static getWidgetInstance(type) {
        const widget = this.getWidget(type);
        return widget ? widget.getInstance() : null;
    }
    /**
     * Hide all widgets
     */
    static async hideAllWidgets() {
        const hidePromises = Array.from(this.instances.keys()).map(type => this.hideWidget(type));
        await Promise.all(hidePromises);
        Logger.debug('Hid all widgets');
    }
    /**
     * Get list of currently visible widgets
     */
    static getVisibleWidgets() {
        const visible = [];
        for (const [type] of this.instances) {
            if (this.isWidgetVisible(type)) {
                visible.push(type);
            }
        }
        return visible;
    }
    /**
     * Clear all widget instances (useful for cleanup)
     */
    static clearInstances() {
        this.instances.clear();
        Logger.debug('Cleared all widget instances');
    }
    /**
     * Get registered widget types
     */
    static getRegisteredTypes() {
        return Array.from(this.factories.keys());
    }
}
CalendarWidgetManager.instances = new Map();
CalendarWidgetManager.factories = new Map();
/**
 * Widget wrapper class to make any widget compatible with the manager
 */
class WidgetWrapper {
    constructor(widget, showMethod = 'render', hideMethod = 'close', toggleMethod = 'toggle', getInstanceMethod = 'getInstance', isVisibleProperty = 'rendered') {
        this.widget = widget;
        this.showMethod = showMethod;
        this.hideMethod = hideMethod;
        this.toggleMethod = toggleMethod;
        this.getInstanceMethod = getInstanceMethod;
        this.isVisibleProperty = isVisibleProperty;
    }
    async show() {
        const fn = this.widget[this.showMethod];
        if (typeof fn === 'function') {
            await fn.call(this.widget);
        }
    }
    async hide() {
        const fn = this.widget[this.hideMethod];
        if (typeof fn === 'function') {
            await fn.call(this.widget);
        }
    }
    async toggle() {
        const fn = this.widget[this.toggleMethod];
        if (typeof fn === 'function') {
            await fn.call(this.widget);
        }
        else {
            // Fallback toggle implementation
            if (this.isVisible()) {
                await this.hide();
            }
            else {
                await this.show();
            }
        }
    }
    getInstance() {
        const fn = this.widget[this.getInstanceMethod];
        if (typeof fn === 'function') {
            return fn.call(this.widget);
        }
        return this.widget;
    }
    isVisible() {
        return Boolean(this.widget[this.isVisibleProperty]);
    }
}

/**
 * Time Advancement Service - Centralized automatic time advancement with combat integration
 *
 * This service provides automatic time advancement functionality with the following features:
 * - Singleton pattern ensuring only one advancement service exists
 * - Smart interval calculation based on advancement ratio
 * - Combat integration (auto-pause/resume)
 * - Comprehensive error handling and recovery
 * - Hook-based event system for third-party integration
 *
 * @example Basic usage
 * ```javascript
 * // Get the service instance
 * const timeService = TimeAdvancementService.getInstance();
 *
 * // Start automatic time advancement
 * await timeService.play();
 *
 * // Check if advancement is active
 * console.log('Time advancement active:', timeService.isActive);
 *
 * // Pause advancement
 * timeService.pause();
 *
 * // Update advancement speed (2x speed)
 * timeService.updateRatio(2.0);
 * ```
 *
 * @example Hook integration for third-party modules
 * ```javascript
 * // Listen for time advancement events
 * Hooks.on('seasons-stars:timeAdvancementStarted', (ratio) => {
 *   console.log(`Time advancement started at ${ratio}x speed`);
 *   // Your module logic here
 * });
 *
 * Hooks.on('seasons-stars:timeAdvancementPaused', () => {
 *   console.log('Time advancement paused');
 *   // Your module logic here
 * });
 * ```
 */
/**
 * Centralized service for managing automatic time advancement in Seasons & Stars
 *
 * The TimeAdvancementService provides automated time progression with intelligent
 * interval calculation, combat awareness, and robust error handling. It follows
 * the singleton pattern to ensure only one instance manages time advancement.
 *
 * ## Multi-Source Pause Management
 *
 * This service coordinates multiple pause sources to provide comprehensive control:
 *
 * ### Pause Sources:
 * 1. **Game Pause**: Foundry's global pause button (controlled by `syncWithGamePause` setting)
 * 2. **Combat Pause**: Automatic pause when combat starts (controlled by `pauseOnCombat` setting)
 *
 * ### Pause Interaction Matrix:
 * ```
 * Game Paused | Combat Active | Time Advancement State
 * ------------|---------------|---------------------
 * No          | No            | ✅ Can run normally
 * No          | Yes           | ❌ Paused (combat)
 * Yes         | No            | ❌ Paused (game)
 * Yes         | Yes           | ❌ Paused (both)
 * ```
 *
 * ### Resume Logic:
 * - **Game Unpause**: Resumes only if no combat active and was previously running
 * - **Combat End**: Resumes only if game not paused and was previously running
 * - **Both Clear**: Resumes if was previously running (GM permission required)
 *
 * ### Permission Model:
 * - **Pause**: Any user can pause via combat start or game pause
 * - **Resume**: Only GMs can trigger automatic resume for security
 * - **Manual**: GMs can always manually start/stop via UI
 *
 * ### Settings Control:
 * - `syncWithGamePause` (default: true): Enable/disable game pause synchronization
 * - `pauseOnCombat` (default: true): Enable/disable combat pause
 * - `resumeAfterCombat` (default: false): Enable/disable combat resume
 */
class TimeAdvancementService {
    /**
     * Private constructor to enforce singleton pattern
     * Registers hooks immediately - they'll check settings when called
     */
    constructor() {
        this._isActive = false;
        this.intervalId = null;
        this.advancementRatio = 1;
        this.lastAdvancement = 0;
        this.wasActiveBeforePause = false;
        /**
         * Handle combat start - pause if configured to do so
         *
         * **Combat Pause Behavior:**
         * This handler works independently but coordinates with game pause:
         *
         * **When Combat Starts:**
         * - Pauses time advancement if currently active and setting enabled
         * - Sets wasActiveBeforePause flag for potential later resume
         * - Available to all users (GM and players can pause)
         * - Shows notification about combat pause
         *
         * **Interaction with Game Pause:**
         * - If game is already paused: Combat pause adds additional blocking condition
         * - Both sources maintain separate wasActiveBeforePause tracking
         * - Time will only resume when ALL blocking conditions are cleared
         *
         * **Setting Control:**
         * - Controlled by 'pauseOnCombat' world setting
         * - When disabled, combat start/end events are ignored for time advancement
         * - Game pause continues to work independently
         *
         * @param combat The combat that started
         * @param updateData Combat update data
         * @private
         */
        this.handleCombatStart = (_combat, _updateData) => {
            if (!this.getSettingValue('pauseOnCombat', true)) {
                return;
            }
            if (this._isActive) {
                this.wasActiveBeforePause = true;
                this.pauseAutomatic();
                ui.notifications?.info('Time advancement paused for combat');
                Logger.info('Combat started - pausing time advancement');
            }
            // Notify UI about pause state change when combat starts
            this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
        };
        /**
         * Handle combat end - resume if configured to do so
         *
         * **Combat Resume Behavior:**
         * This handler coordinates with game pause to ensure proper resume logic:
         *
         * **When Combat Ends:**
         * - Only GMs can trigger auto-resume (security measure)
         * - Checks if time advancement was active before combat started
         * - Only resumes if 'resumeAfterCombat' setting is enabled
         * - Only resumes if NO other blocking conditions exist (game pause, etc.)
         * - Clears wasActiveBeforePause flag to prevent duplicate resumes
         *
         * **Multi-Source Resume Logic:**
         * - Combat end + Game paused: Time remains paused (game pause blocks)
         * - Combat end + Game unpaused + was active before: Time resumes
         * - Uses isBlockedByOtherReasons() to check all blocking conditions
         *
         * **Permission Model:**
         * - Only GMs can auto-resume time advancement for security
         * - Players can pause (via combat start) but cannot auto-resume
         * - Manual resume always available to GMs via UI controls
         *
         * **Setting Control:**
         * - Controlled by 'resumeAfterCombat' world setting
         * - When disabled, combat end never triggers auto-resume
         * - Manual resume still available to GMs
         *
         * @param combat The combat that ended
         * @param options Combat deletion options
         * @param userId The user who ended the combat
         * @private
         */
        this.handleCombatEnd = (_combat, _options, _userId) => {
            // Only GMs should attempt to resume time advancement
            if (!game.user?.isGM) {
                return;
            }
            if (!this.getSettingValue('resumeAfterCombat', false)) {
                return;
            }
            if (this.wasActiveBeforePause && !this._isActive && !this.isBlockedByOtherReasons()) {
                this.wasActiveBeforePause = false;
                Logger.info('Combat ended - resuming time advancement');
                this.play().catch(error => {
                    Logger.error('Failed to resume time advancement after combat', error);
                    ui.notifications?.error('Failed to resume time advancement after combat');
                });
            }
            // Notify UI about pause state change after combat ends
            this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
        };
        /**
         * Handle game pause/unpause events
         *
         * **Multi-Source Pause Behavior:**
         * This handler works alongside combat pause to provide comprehensive pause management:
         *
         * **When Game is Paused:**
         * - Pauses time advancement if currently active
         * - Sets wasActiveBeforePause flag for later resume
         * - Shows notification to all users
         *
         * **When Game is Unpaused:**
         * - Only GMs can trigger auto-resume (security measure)
         * - Checks if time advancement was active before the pause
         * - Only resumes if NO other blocking conditions exist (combat, etc.)
         * - Clears wasActiveBeforePause flag to prevent duplicate resumes
         *
         * **Interaction with Combat Pause:**
         * - Game pause + Combat active: Time stays paused until BOTH are cleared
         * - Game unpause while combat active: Time remains paused
         * - Combat end while game paused: Time remains paused
         * - Both conditions cleared: Time resumes automatically (GM only)
         *
         * **Setting Control:**
         * - Controlled by 'syncWithGamePause' world setting
         * - When disabled, game pause/unpause events are ignored
         * - Combat pause continues to work independently
         *
         * @param paused Current pause state (true = game paused, false = game unpaused)
         * @param options Hook options with broadcast and userId info
         * @private
         */
        this.handleGamePause = (paused, options) => {
            Logger.debug(`Game pause hook fired: ${paused ? 'paused' : 'unpaused'}, syncEnabled=${this.shouldSyncWithGamePause()}`, options);
            if (!this.shouldSyncWithGamePause()) {
                Logger.debug('Ignoring game pause because syncWithGamePause setting is disabled');
                return;
            }
            if (paused) {
                // Game was paused - pause time advancement if it's running
                if (this._isActive) {
                    this.wasActiveBeforePause = true;
                    this.pauseAutomatic();
                    ui.notifications?.info('Time advancement paused (game paused)');
                    Logger.info('Time advancement paused due to game pause');
                }
                // Notify UI about pause state change even if time advancement wasn't active
                this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
            }
            else {
                // Game was unpaused - resume if was active before and no other blocks
                if (!game.user?.isGM) {
                    Logger.debug('Non-GM user cannot auto-resume time advancement');
                    return;
                }
                if (this.wasActiveBeforePause && !this._isActive && !this.isBlockedByOtherReasons()) {
                    this.wasActiveBeforePause = false;
                    this.play().catch(error => {
                        Logger.error('Failed to resume time advancement after game unpause', error);
                        ui.notifications?.error('Failed to resume time advancement after game unpause');
                    });
                    ui.notifications?.info('Time advancement resumed (game unpaused)');
                    Logger.info('Time advancement resumed after game unpause');
                }
                // Notify UI about pause state change
                this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
            }
        };
        Logger.debug('TimeAdvancementService instance created');
        // Register hooks once - they'll check settings when triggered
        Hooks.on('combatStart', this.handleCombatStart.bind(this));
        Hooks.on('deleteCombat', this.handleCombatEnd.bind(this));
        Hooks.on('pauseGame', this.handleGamePause.bind(this));
    }
    /**
     * Get the singleton instance of TimeAdvancementService
     *
     * This method ensures only one instance of the TimeAdvancementService exists
     * throughout the application lifetime. The instance is created lazily on first access.
     *
     * @returns The singleton TimeAdvancementService instance
     *
     * @example Getting the service instance
     * ```javascript
     * // Always use getInstance() - never instantiate directly
     * const timeService = TimeAdvancementService.getInstance();
     *
     * // The same instance is returned on subsequent calls
     * const sameInstance = TimeAdvancementService.getInstance();
     * console.log(timeService === sameInstance); // true
     * ```
     *
     * @example Checking service availability
     * ```javascript
     * // Check if the service is available before using
     * try {
     *   const timeService = TimeAdvancementService.getInstance();
     *   if (timeService.isActive) {
     *     console.log('Time advancement is currently running');
     *   }
     * } catch (error) {
     *   console.error('TimeAdvancementService not available:', error);
     * }
     * ```
     */
    static getInstance() {
        if (!TimeAdvancementService.instance) {
            TimeAdvancementService.instance = new TimeAdvancementService();
        }
        return TimeAdvancementService.instance;
    }
    /**
     * Reset the singleton instance (for testing purposes)
     * @internal
     */
    static resetInstance() {
        if (TimeAdvancementService.instance) {
            TimeAdvancementService.instance.destroy();
            TimeAdvancementService.instance = null;
        }
    }
    /**
     * Get the current active state
     */
    get isActive() {
        return this._isActive;
    }
    /**
     * Get the effective UI state - what the user interface should show
     * This differs from isActive when time advancement was running but got auto-paused
     *
     * @returns true if UI should show pause button, false if UI should show play button
     */
    get shouldShowPauseButton() {
        // If time advancement is active, always show pause button
        if (this._isActive) {
            return true;
        }
        // If time advancement is inactive but was active before being auto-paused,
        // show pause button so user can "lock in" the paused state
        if (this.wasActiveBeforePause) {
            return true;
        }
        // Otherwise show play button
        return false;
    }
    /**
     * Get the current pause state and reason for UI display
     *
     * @returns Object with pause state and human-readable reason
     */
    getPauseState() {
        // Check external blocking conditions first, even if not currently active
        if (this.isBlockedByOtherReasons()) {
            const reasons = [];
            if (this.shouldSyncWithGamePause() && game.paused) {
                reasons.push('Game paused');
            }
            if (this.getSettingValue('pauseOnCombat', true) && (game.combat?.started ?? false)) {
                reasons.push('Combat active');
            }
            return {
                isPaused: true,
                reason: reasons.length > 1 ? reasons.join(' & ') : reasons[0] || 'Blocked',
                canResume: false, // Can't manually resume while blocked by external factors
            };
        }
        if (!this._isActive) {
            return {
                isPaused: true,
                reason: 'Time advancement stopped',
                canResume: game.user?.isGM || false,
            };
        }
        return {
            isPaused: false,
            reason: null,
            canResume: true,
        };
    }
    /**
     * Initialize the service (hooks are already registered in constructor)
     */
    initialize() {
        Logger.debug('TimeAdvancementService ready (hooks already registered)');
    }
    /**
     * Start automatic time advancement
     *
     * Begins automated time progression using the current advancement ratio setting.
     * The service will advance game time at regular intervals until paused or stopped.
     * Combat integration will automatically pause advancement if configured.
     *
     * @throws {Error} If game is not ready or calendar manager is unavailable
     * @throws {Error} If time advancement fails to start due to system state
     *
     * @example Basic time advancement
     * ```javascript
     * const timeService = TimeAdvancementService.getInstance();
     *
     * try {
     *   await timeService.play();
     *   console.log('Time advancement started successfully');
     * } catch (error) {
     *   console.error('Failed to start time advancement:', error);
     * }
     * ```
     *
     * @example Starting with custom ratio
     * ```javascript
     * const timeService = TimeAdvancementService.getInstance();
     *
     * // Set 2x speed before starting
     * timeService.updateRatio(2.0);
     * await timeService.play();
     * console.log('Time advancing at 2x speed');
     * ```
     *
     * @example Integration with module controls
     * ```javascript
     * // In your module's control panel
     * class TimeControlPanel {
     *   async startTimeAdvancement() {
     *     const timeService = TimeAdvancementService.getInstance();
     *
     *     if (timeService.isActive) {
     *       ui.notifications.warn('Time advancement already active');
     *       return;
     *     }
     *
     *     try {
     *       await timeService.play();
     *       this.updateButtonStates();
     *       ui.notifications.info('Time advancement started');
     *     } catch (error) {
     *       ui.notifications.error('Failed to start time advancement');
     *     }
     *   }
     * }
     * ```
     *
     * @fires seasons-stars:timeAdvancementStarted When advancement starts successfully
     */
    async play() {
        if (!this.validateState() || this._isActive) {
            return;
        }
        try {
            Logger.info('Starting time advancement');
            this._isActive = true;
            await this.startAdvancement();
            this.callHookSafely('seasons-stars:timeAdvancementStarted', this.advancementRatio);
            this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
        }
        catch (error) {
            this._isActive = false;
            ui.notifications?.error('Failed to start time advancement');
            Logger.error('Failed to start time advancement', error);
            throw error;
        }
    }
    /**
     * Pause automatic time advancement
     *
     * Stops the current time advancement without destroying the service.
     * The advancement can be resumed later by calling play() again.
     * This method is safe to call even if advancement is not currently active.
     *
     * @example Basic pause operation
     * ```javascript
     * const timeService = TimeAdvancementService.getInstance();
     *
     * // Pause advancement (safe even if not running)
     * timeService.pause();
     * console.log('Time advancement paused');
     * ```
     *
     * @example Toggle advancement state
     * ```javascript
     * const timeService = TimeAdvancementService.getInstance();
     *
     * if (timeService.isActive) {
     *   timeService.pause();
     *   ui.notifications.info('Time advancement paused');
     * } else {
     *   await timeService.play();
     *   ui.notifications.info('Time advancement started');
     * }
     * ```
     *
     * @example Module integration with cleanup
     * ```javascript
     * // In your module's shutdown/cleanup code
     * class WeatherModule {
     *   onModuleDisable() {
     *     const timeService = TimeAdvancementService.getInstance();
     *
     *     // Ensure time advancement is paused when module is disabled
     *     if (timeService.isActive) {
     *       timeService.pause();
     *       console.log('Weather module disabled - time advancement paused');
     *     }
     *   }
     * }
     * ```
     *
     * @fires seasons-stars:timeAdvancementPaused When advancement is successfully paused
     */
    pause() {
        // Always clear wasActiveBeforePause when user manually pauses
        // This prevents auto-resume even if advancement was already paused by external factors
        this.wasActiveBeforePause = false;
        Logger.debug(`Manual pause called: _isActive=${this._isActive}, blocked=${this.isAdvancementBlocked()}`);
        if (!this._isActive) {
            // Already paused, but we still cleared the auto-resume flag above
            Logger.info('Time advancement already paused, cleared auto-resume flag');
            this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
            return;
        }
        // If advancement is active but blocked by external factors (game pause, combat),
        // user clicking pause should fully stop it, not just clear the auto-resume flag
        Logger.info('Pausing time advancement (manual)');
        this._isActive = false;
        this.stopAdvancement();
        this.callHookSafely('seasons-stars:timeAdvancementPaused');
        this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
    }
    /**
     * Pause time advancement due to automatic/external condition (game pause, combat, etc.)
     * Does NOT clear wasActiveBeforePause flag so auto-resume can work
     * @private
     */
    pauseAutomatic() {
        if (!this._isActive) {
            return;
        }
        Logger.info('Pausing time advancement (automatic)');
        this._isActive = false;
        this.stopAdvancement();
        // DO NOT clear wasActiveBeforePause - needed for auto-resume
        this.callHookSafely('seasons-stars:timeAdvancementPaused');
        this.callHookSafely('seasons-stars:pauseStateChanged', this.getPauseState());
    }
    /**
     * Update the advancement ratio and restart if currently active
     *
     * Changes the speed of time advancement. The ratio represents game seconds
     * advanced per real-world second. Values are clamped between 0.1 and 100.
     * If advancement is currently active, it will be restarted with the new ratio.
     *
     * @param ratio The new ratio (game seconds per real second)
     *   - 1.0 = real time (1 game second per real second)
     *   - 2.0 = double speed (2 game seconds per real second)
     *   - 0.5 = half speed (0.5 game seconds per real second)
     *   - Clamped to range [0.1, 100]
     *
     * @example Setting different advancement speeds
     * ```javascript
     * const timeService = TimeAdvancementService.getInstance();
     *
     * // Real-time advancement
     * timeService.updateRatio(1.0);
     *
     * // Double speed for fast travel
     * timeService.updateRatio(2.0);
     *
     * // Slow motion for detailed events
     * timeService.updateRatio(0.1);
     *
     * // Very fast for long rests (10x speed)
     * timeService.updateRatio(10.0);
     * ```
     *
     * @example Dynamic speed adjustment
     * ```javascript
     * class TimeControlWidget {
     *   setupSpeedControls() {
     *     const timeService = TimeAdvancementService.getInstance();
     *
     *     // Speed selector
     *     const speeds = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0];
     *     speeds.forEach(speed => {
     *       const button = document.createElement('button');
     *       button.textContent = `${speed}x`;
     *       button.onclick = () => {
     *         timeService.updateRatio(speed);
     *         this.updateActiveSpeed(speed);
     *       };
     *       this.speedContainer.appendChild(button);
     *     });
     *   }
     * }
     * ```
     *
     * @example Integration with settings
     * ```javascript
     * // Sync with Foundry settings
     * game.settings.register('my-module', 'timeSpeed', {
     *   name: 'Time Advancement Speed',
     *   scope: 'world',
     *   config: true,
     *   type: Number,
     *   default: 1.0,
     *   onChange: (value) => {
     *     const timeService = TimeAdvancementService.getInstance();
     *     timeService.updateRatio(value);
     *   }
     * });
     * ```
     */
    updateRatio(ratio) {
        const wasActive = this._isActive;
        if (wasActive) {
            this.pause();
        }
        this.advancementRatio = Math.max(0.1, Math.min(100, ratio));
        Logger.debug(`Updated advancement ratio to ${this.advancementRatio}`);
        if (wasActive) {
            this.play().catch(error => {
                Logger.error('Failed to restart after ratio update', error);
            });
        }
    }
    /**
     * Clean up all resources (hooks remain registered)
     */
    destroy() {
        Logger.debug('Destroying TimeAdvancementService');
        this.stopAdvancement();
        this._isActive = false;
        this.wasActiveBeforePause = false; // Reset pause state for clean testing
    }
    /**
     * Calculate optimal interval based on advancement ratio
     * Ensures minimum 10000ms real time and dynamic scaling for slow ratios
     * @param ratio The advancement ratio (game seconds per real second)
     * @returns Interval in milliseconds
     * @private
     */
    calculateOptimalInterval(ratio) {
        // Formula: Math.max(10000, Math.ceil(1000 / ratio))
        // This ensures:
        // - Never advance more frequently than every 10000ms real time
        // - Always scales appropriately for very slow ratios
        return Math.max(10000, Math.ceil(1000 / ratio));
    }
    /**
     * Start the advancement timer
     * @private
     */
    async startAdvancement() {
        // Clear any existing interval first
        this.stopAdvancement();
        const interval = this.calculateOptimalInterval(this.advancementRatio);
        Logger.debug(`Starting advancement with ${interval}ms interval (ratio: ${this.advancementRatio})`);
        // Track when the last advancement tick occurred so we can maintain the
        // correct real-time to game-time ratio regardless of interval frequency
        this.lastAdvancement = Date.now();
        this.intervalId = setInterval(() => {
            try {
                // Check if advancement should be blocked before advancing
                if (this.isAdvancementBlocked()) {
                    // Logger.debug('Time advancement temporarily blocked, skipping interval');
                    // Update the last advancement timestamp so paused time doesn't accumulate
                    this.lastAdvancement = Date.now();
                    return;
                }
                this.advanceTime();
            }
            catch (error) {
                Logger.error('Time advancement error, auto-pausing', error);
                this.pause();
            }
        }, interval);
    }
    /**
     * Stop the advancement timer
     * @private
     */
    stopAdvancement() {
        if (this.intervalId !== null) {
            clearInterval(this.intervalId);
            this.intervalId = null;
            Logger.debug('Stopped advancement timer');
        }
    }
    /**
     * Advance time by the current ratio
     * @private
     */
    advanceTime() {
        const manager = game.seasonsStars?.manager;
        if (!manager) {
            throw new Error('Calendar manager not available');
        }
        const now = Date.now();
        const elapsedSeconds = (now - this.lastAdvancement) / 1000;
        const secondsToAdvance = this.advancementRatio * elapsedSeconds;
        // Skip debug logging during automatic advancement to reduce console spam
        // Logger.debug(`Advancing ${secondsToAdvance} game seconds over ${elapsedSeconds}s real time`);
        manager.advanceSeconds(secondsToAdvance);
        this.lastAdvancement = now;
    }
    /**
     * Validate that the game state allows time advancement
     * @returns true if advancement is allowed
     * @private
     */
    validateState() {
        if (!game.seasonsStars?.manager) {
            Logger.warn('Seasons & Stars manager not available for time advancement');
            return false;
        }
        // Allow manual start even when game is paused - user should have control
        // Blocking will happen during interval advancement via isAdvancementBlocked()
        return true;
    }
    /**
     * Safely call a Foundry hook with error handling
     * @param hookName The hook name to call
     * @param args Arguments to pass to the hook
     * @private
     */
    callHookSafely(hookName, ...args) {
        try {
            Hooks.callAll(hookName, ...args);
        }
        catch (error) {
            Logger.error(`Failed to call hook ${hookName}`, error);
            // Don't re-throw - hook failures shouldn't break the service
        }
    }
    /**
     * Get a setting value with safe fallback
     * @param key The setting key
     * @param defaultValue The fallback value
     * @returns The setting value or fallback
     * @private
     */
    getSettingValue(key, defaultValue) {
        try {
            const value = game.settings?.get('seasons-and-stars', key);
            return value !== undefined ? value : defaultValue;
        }
        catch (error) {
            Logger.warn(`Failed to get setting ${key}, using default`, error);
            return defaultValue;
        }
    }
    /**
     * Check if time advancement should sync with game pause state
     * @returns true if should sync with game pause
     * @private
     */
    shouldSyncWithGamePause() {
        return this.getSettingValue('syncWithGamePause', true);
    }
    /**
     * Check if advancement is blocked by other conditions (game pause or combat)
     *
     * **Multi-Source Blocking Logic:**
     * This method ensures that time advancement only resumes when ALL blocking
     * conditions are cleared, preventing premature resume when multiple pause
     * sources are active.
     *
     * **Checked Blocking Conditions:**
     * 1. **Game Pause**: Foundry's global pause state (if sync enabled)
     * 2. **Active Combat**: Any combat encounter in progress
     *
     * **Usage Scenarios:**
     * - Called before auto-resume in game pause handler
     * - Called before auto-resume in combat end handler
     * - Prevents resume when one condition clears but others remain
     *
     * **Examples:**
     * - Game unpauses but combat is active: Returns true (blocked by combat)
     * - Combat ends but game is paused: Returns true (blocked by game pause)
     * - Both game unpaused and no combat: Returns false (not blocked)
     *
     * @returns true if blocked by any condition, false if safe to resume
     * @private
     */
    isBlockedByOtherReasons() {
        const gamePauseBlocking = this.shouldSyncWithGamePause() && game.paused;
        const combatBlocking = this.getSettingValue('pauseOnCombat', true) && (game.combat?.started ?? false);
        return gamePauseBlocking || combatBlocking;
    }
    /**
     * Check if time advancement should be blocked on current interval tick
     *
     * This method checks real-time blocking conditions that might change between
     * interval ticks, allowing the interval to continue running but skip actual
     * time advancement when temporarily blocked.
     *
     * @returns true if advancement should be skipped this tick, false to proceed
     * @private
     */
    isAdvancementBlocked() {
        return this.isBlockedByOtherReasons();
    }
}
TimeAdvancementService.instance = null;

/**
 * Calendar Widget - Compact date/time display for Seasons & Stars
 */
class CalendarWidget extends foundry.applications.api.HandlebarsApplicationMixin(foundry.applications.api.ApplicationV2) {
    constructor() {
        super(...arguments);
        this.updateInterval = null;
        this.sidebarButtons = [];
    }
    /**
     * Prepare rendering context for template
     */
    async _prepareContext(options = {}) {
        const context = await super._prepareContext(options);
        const manager = game.seasonsStars?.manager;
        if (!manager) {
            return Object.assign(context, {
                error: 'Calendar manager not initialized',
                calendar: null,
                currentDate: null,
                formattedDate: 'Not Available',
                canAdvanceTime: false,
            });
        }
        const activeCalendar = manager.getActiveCalendar();
        const currentDate = manager.getCurrentDate();
        if (!activeCalendar || !currentDate) {
            return Object.assign(context, {
                error: 'No active calendar',
                calendar: null,
                currentDate: null,
                formattedDate: 'No Calendar Active',
            });
        }
        const calendarInfo = CalendarLocalization.getLocalizedCalendarInfo(activeCalendar);
        // Check if SmallTime is available and active
        const hasSmallTime = this.detectSmallTime();
        // Check the always show quick time buttons setting
        const alwaysShowQuickTimeButtons = game.settings?.get('seasons-and-stars', 'alwaysShowQuickTimeButtons') || false;
        // Get time advancement state for GM users
        let timeAdvancementActive = false;
        let advancementRatioDisplay = '1.0x speed';
        let timeAdvancementStatus = 'Paused';
        let pauseOnCombat = true;
        let resumeAfterCombat = false;
        let playPauseButtonClass = '';
        let playPauseButtonIcon = 'fa-play';
        let playPauseButtonText = 'Play';
        if (game.user?.isGM) {
            try {
                const timeService = TimeAdvancementService.getInstance();
                timeAdvancementActive = timeService?.shouldShowPauseButton || false;
                const ratio = game.settings?.get('seasons-and-stars', 'timeAdvancementRatio') || 1.0;
                advancementRatioDisplay = `${ratio.toFixed(1)}x speed`;
                // Get settings
                pauseOnCombat = game.settings?.get('seasons-and-stars', 'pauseOnCombat') || true;
                resumeAfterCombat = game.settings?.get('seasons-and-stars', 'resumeAfterCombat') || false;
                // Set status and button state based on advancement activity
                if (timeAdvancementActive) {
                    timeAdvancementStatus = 'Active';
                    playPauseButtonClass = 'active';
                    playPauseButtonIcon = 'fa-pause';
                    playPauseButtonText = 'Pause';
                }
                else {
                    timeAdvancementStatus = 'Paused';
                    playPauseButtonClass = '';
                    playPauseButtonIcon = 'fa-play';
                    playPauseButtonText = 'Play';
                }
            }
            catch (error) {
                Logger.warn('Failed to get time advancement state', error);
            }
        }
        return Object.assign(context, {
            calendar: calendarInfo,
            currentDate: currentDate.toObject(),
            formattedDate: currentDate.toLongString(),
            shortDate: currentDate.toDateString(),
            timeString: currentDate.toTimeString(),
            isGM: game.user?.isGM || false,
            canAdvanceTime: game.user?.isGM || false,
            hasSmallTime: hasSmallTime,
            showTimeControls: (!hasSmallTime || alwaysShowQuickTimeButtons) && (game.user?.isGM || false),
            // Time advancement context
            timeAdvancementActive: timeAdvancementActive,
            advancementRatioDisplay: advancementRatioDisplay,
            timeAdvancementStatus: timeAdvancementStatus,
            showTimeAdvancementSection: game.user?.isGM || false,
            // Time advancement settings
            pauseOnCombat: pauseOnCombat,
            resumeAfterCombat: resumeAfterCombat,
            // Button states and styling
            playPauseButtonClass: playPauseButtonClass,
            playPauseButtonIcon: playPauseButtonIcon,
            playPauseButtonText: playPauseButtonText,
            sidebarButtons: this.sidebarButtons, // Include sidebar buttons for template
        });
    }
    /**
     * Attach event listeners to rendered parts
     */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        // Register this as the active instance
        CalendarWidget.activeInstance = this;
        // Start auto-update after rendering
        this.startAutoUpdate();
    }
    /**
     * Instance action handler for opening calendar selection dialog
     */
    async _onOpenCalendarSelection(event, _target) {
        event.preventDefault();
        if (!game.user?.isGM) {
            return;
        }
        CalendarSelectionDialog.show();
    }
    /**
     * Instance action handler for opening detailed view dialog
     */
    async _onOpenDetailedView(event, _target) {
        event.preventDefault();
        const manager = game.seasonsStars?.manager;
        if (!manager) {
            ui.notifications?.error('Calendar manager not available');
            return;
        }
        // Open the calendar grid widget
        CalendarWidgetManager.showWidget('grid');
    }
    /**
     * Instance action handler for date advancement
     */
    async _onAdvanceDate(event, target) {
        event.preventDefault();
        const amount = parseInt(target.dataset.amount || '0');
        const unit = target.dataset.unit || 'days';
        const manager = game.seasonsStars?.manager;
        if (!manager)
            return;
        Logger.info(`Advancing date: ${amount} ${unit}`);
        try {
            switch (unit) {
                case 'minutes':
                    await manager.advanceMinutes(amount);
                    break;
                case 'hours':
                    await manager.advanceHours(amount);
                    break;
                case 'days':
                    await manager.advanceDays(amount);
                    break;
                case 'weeks':
                    await manager.advanceWeeks(amount);
                    break;
                case 'months':
                    await manager.advanceMonths(amount);
                    break;
                case 'years':
                    await manager.advanceYears(amount);
                    break;
                default:
                    Logger.warn(`Unknown date unit: ${unit}`);
                    return;
            }
            // Show success notification for larger advances
            if ((unit === 'weeks' && amount >= 2) ||
                (unit === 'months' && amount >= 1) ||
                (unit === 'years' && amount >= 1)) {
                ui.notifications?.info(`Time advanced by ${amount} ${unit}`);
            }
        }
        catch (error) {
            Logger.error('Error advancing date', error);
            ui.notifications?.error('Failed to advance date');
        }
    }
    /**
     * Instance action handler for opening bulk advance dialog
     */
    async _onOpenBulkAdvance(event, _target) {
        event.preventDefault();
        // Show placeholder for now - will implement proper dialog later
        ui.notifications?.info('Bulk time advancement coming soon!');
    }
    /**
     * Handle sidebar button clicks
     */
    async _onClickSidebarButton(event, target) {
        event.preventDefault();
        const buttonName = target.dataset.buttonName;
        if (!buttonName) {
            Logger.warn('Sidebar button clicked without button name');
            return;
        }
        // Find the button in our array and execute its callback
        const button = this.sidebarButtons.find(btn => btn.name === buttonName);
        if (button && typeof button.callback === 'function') {
            try {
                button.callback();
            }
            catch (error) {
                Logger.error(`Error executing sidebar button "${buttonName}" callback`, error);
            }
        }
        else {
            Logger.warn(`Sidebar button "${buttonName}" not found or has invalid callback`);
        }
    }
    /**
     * Handle toggling time advancement on/off
     */
    async _onToggleTimeAdvancement(event, _target) {
        event.preventDefault();
        try {
            const service = TimeAdvancementService.getInstance();
            if (!service) {
                ui.notifications?.error('Time advancement service not available');
                return;
            }
            if (service.shouldShowPauseButton) {
                service.pause();
                Logger.info('Main widget: Paused time advancement');
            }
            else {
                await service.play();
                Logger.info('Main widget: Started time advancement');
            }
            // Re-render to update button state
            this.render();
        }
        catch (error) {
            ui.notifications?.error('Failed to toggle time advancement');
            Logger.error('Main widget time advancement toggle failed', error);
        }
    }
    /**
     * Handle ratio setting changes from external sources
     */
    _onRatioSettingChanged(newRatio) {
        try {
            const service = TimeAdvancementService.getInstance();
            if (service) {
                service.updateRatio(newRatio);
                Logger.info(`Main widget: Updated time advancement ratio to ${newRatio}`);
            }
        }
        catch (error) {
            Logger.error('Failed to update time advancement ratio', error);
        }
    }
    /**
     * Switch to mini widget
     */
    async _onSwitchToMini(event, _target) {
        event.preventDefault();
        Logger.debug('Switching from main widget to mini widget');
        try {
            // Close current widget
            this.close();
            // Open mini widget
            CalendarWidgetManager.showWidget('mini');
        }
        catch (error) {
            Logger.error('Failed to switch to mini widget', error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Switch to grid widget
     */
    async _onSwitchToGrid(event, _target) {
        event.preventDefault();
        Logger.debug('Switching from main widget to grid widget');
        try {
            // Close current widget
            this.close();
            // Open grid widget
            CalendarWidgetManager.showWidget('grid');
        }
        catch (error) {
            Logger.error('Failed to switch to grid widget', error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Detect if SmallTime module is available and active
     */
    detectSmallTime() {
        // Check if SmallTime module is installed and enabled
        const smallTimeModule = game.modules?.get('smalltime');
        if (!smallTimeModule?.active) {
            return false;
        }
        // Check if SmallTime UI elements are present in the DOM
        const selectors = [
            '#smalltime-app',
            '.smalltime-app',
            '#timeDisplay',
            '#slideContainer',
            '[id*="smalltime"]',
            '.form:has(#timeDisplay)',
        ];
        for (const selector of selectors) {
            try {
                if (document.querySelector(selector)) {
                    return true;
                }
            }
            catch {
                // Skip invalid selectors
                continue;
            }
        }
        return false;
    }
    /**
     * Start automatic updates
     */
    startAutoUpdate() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        // Update every 30 seconds
        this.updateInterval = window.setInterval(() => {
            if (this.rendered) {
                this.render();
            }
        }, 30000);
    }
    /**
     * Stop automatic updates
     */
    stopAutoUpdate() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
    /**
     * Handle closing the widget
     */
    async close(options = {}) {
        this.stopAutoUpdate();
        // Clear active instance if this is it
        if (CalendarWidget.activeInstance === this) {
            CalendarWidget.activeInstance = null;
        }
        return super.close(options);
    }
    /**
     * Handle Foundry hooks for real-time updates
     */
    static registerHooks() {
        // Update widget when time changes
        Hooks.on('seasons-stars:dateChanged', () => {
            if (CalendarWidget.activeInstance?.rendered) {
                CalendarWidget.activeInstance.render();
            }
        });
        // Update widget when calendar changes
        Hooks.on('seasons-stars:calendarChanged', () => {
            if (CalendarWidget.activeInstance?.rendered) {
                CalendarWidget.activeInstance.render();
            }
        });
        // Update widget when settings change (especially quick time buttons)
        Hooks.on('seasons-stars:settingsChanged', (settingName) => {
            if ((settingName === 'quickTimeButtons' ||
                settingName === 'miniWidgetQuickTimeButtons' ||
                settingName === 'alwaysShowQuickTimeButtons') &&
                CalendarWidget.activeInstance?.rendered) {
                CalendarWidget.activeInstance.render();
            }
        });
    }
    /**
     * Toggle widget visibility
     */
    static toggle() {
        if (CalendarWidget.activeInstance) {
            if (CalendarWidget.activeInstance.rendered) {
                CalendarWidget.activeInstance.close();
            }
            else {
                CalendarWidget.activeInstance.render(true);
            }
        }
        else {
            new CalendarWidget().render(true);
        }
    }
    /**
     * Show the widget
     */
    static show() {
        if (CalendarWidget.activeInstance) {
            if (!CalendarWidget.activeInstance.rendered) {
                CalendarWidget.activeInstance.render(true);
            }
        }
        else {
            new CalendarWidget().render(true);
        }
    }
    /**
     * Hide the widget
     */
    static hide() {
        if (CalendarWidget.activeInstance?.rendered) {
            CalendarWidget.activeInstance.close();
        }
    }
    /**
     * Get the current widget instance
     */
    static getInstance() {
        return CalendarWidget.activeInstance;
    }
    /**
     * Add a sidebar button for integration with other modules (like Simple Weather)
     */
    addSidebarButton(name, icon, tooltip, callback) {
        // Check if button already exists
        const existingButton = this.sidebarButtons.find(btn => btn.name === name);
        if (existingButton) {
            Logger.debug(`Button "${name}" already exists in widget`);
            return;
        }
        // Store the button
        this.sidebarButtons.push({ name, icon, tooltip, callback });
        // If rendered, re-render to include the new button
        if (this.rendered) {
            this.render();
        }
    }
    /**
     * Remove a sidebar button by name
     */
    removeSidebarButton(name) {
        const index = this.sidebarButtons.findIndex(btn => btn.name === name);
        if (index !== -1) {
            this.sidebarButtons.splice(index, 1);
            // Re-render to remove the button
            if (this.rendered) {
                this.render();
            }
        }
    }
    /**
     * Check if a sidebar button exists
     */
    hasSidebarButton(name) {
        return this.sidebarButtons.some(btn => btn.name === name);
    }
}
CalendarWidget.activeInstance = null;
CalendarWidget.DEFAULT_OPTIONS = {
    id: 'seasons-stars-widget',
    classes: ['seasons-stars', 'calendar-widget'],
    tag: 'div',
    window: {
        frame: true,
        positioned: true,
        title: 'SEASONS_STARS.calendar.current_date',
        icon: 'fa-solid fa-calendar-alt',
        minimizable: false,
        resizable: false,
    },
    position: {
        width: 280,
        height: 'auto',
    },
    actions: {
        openCalendarSelection: CalendarWidget.prototype._onOpenCalendarSelection,
        openDetailedView: CalendarWidget.prototype._onOpenDetailedView,
        advanceDate: CalendarWidget.prototype._onAdvanceDate,
        openBulkAdvance: CalendarWidget.prototype._onOpenBulkAdvance,
        clickSidebarButton: CalendarWidget.prototype._onClickSidebarButton,
        switchToMini: CalendarWidget.prototype._onSwitchToMini,
        switchToGrid: CalendarWidget.prototype._onSwitchToGrid,
        toggleTimeAdvancement: CalendarWidget.prototype._onToggleTimeAdvancement,
    },
};
CalendarWidget.PARTS = {
    main: {
        id: 'main',
        template: 'modules/seasons-and-stars/templates/calendar-widget.hbs',
    },
};

/**
 * Base widget manager to handle common widget patterns
 * Eliminates repeated code across calendar widgets
 */
/**
 * SmallTime integration utility
 */
class SmallTimeUtils {
    /**
     * Check if SmallTime module is installed and active
     */
    static isSmallTimeAvailable() {
        const smallTimeModule = game.modules?.get('smalltime');
        return smallTimeModule?.active === true;
    }
    /**
     * Get SmallTime element for positioning (only if module is active)
     */
    static getSmallTimeElement() {
        if (!this.isSmallTimeAvailable()) {
            return null;
        }
        // Only search for the element if the module is actually active
        const selectors = ['#smalltime-app', '.smalltime-app', '#timeDisplay', '#slideContainer'];
        for (const selector of selectors) {
            const element = document.querySelector(selector);
            if (element) {
                Logger.debug(`SmallTime element found: ${selector}`);
                return element;
            }
        }
        Logger.debug('SmallTime module active but element not found');
        return null;
    }
}

/**
 * Calendar Mini Widget - Compact date display that pairs with SmallTime
 */
class CalendarMiniWidget extends foundry.applications.api.HandlebarsApplicationMixin(foundry.applications.api.ApplicationV2) {
    constructor(options = {}) {
        // Check if widget is pinned and get saved position
        const pinned = game.settings?.get('seasons-and-stars', 'miniWidgetPinned');
        const pos = game.settings?.get('seasons-and-stars', 'miniWidgetPosition');
        // If pinned and we have a valid position, apply it to options
        if (pinned &&
            pos &&
            typeof pos.top === 'number' &&
            typeof pos.left === 'number' &&
            Number.isFinite(pos.top) &&
            Number.isFinite(pos.left)) {
            options = foundry.utils.mergeObject(options, {
                position: {
                    top: pos.top,
                    left: pos.left,
                },
            });
        }
        super(options);
        this.isClosing = false;
        this.sidebarButtons = [];
        this.hasBeenPositioned = false;
    }
    /**
     * Prepare rendering context for template
     */
    async _prepareContext(options = {}) {
        const context = (await super._prepareContext(options));
        const manager = game.seasonsStars?.manager;
        if (!manager) {
            return Object.assign(context, {
                error: 'Calendar not available',
                shortDate: 'N/A',
                hasSmallTime: false,
                showTimeControls: false,
                calendar: null,
                currentDate: null,
                formattedDate: 'N/A',
                isGM: game.user?.isGM || false,
            });
        }
        const activeCalendar = manager.getActiveCalendar();
        const currentDate = manager.getCurrentDate();
        if (!activeCalendar || !currentDate) {
            return Object.assign(context, {
                error: 'No calendar active',
                shortDate: 'N/A',
                hasSmallTime: false,
                showTimeControls: false,
                calendar: null,
                currentDate: null,
                formattedDate: 'N/A',
                isGM: game.user?.isGM || false,
            });
        }
        // Check if SmallTime is available and active
        const hasSmallTime = SmallTimeUtils.isSmallTimeAvailable();
        // Check if time should be displayed in mini widget
        const showTime = game.settings?.get('seasons-and-stars', 'miniWidgetShowTime') || false;
        // Check if day of week should be displayed in mini widget
        const showDayOfWeek = game.settings?.get('seasons-and-stars', 'miniWidgetShowDayOfWeek') || false;
        // Get weekday name/abbreviation with enhanced null safety
        // Don't show weekday for intercalary days that don't count for weekdays
        let weekdayDisplay = '';
        if (showDayOfWeek &&
            activeCalendar?.weekdays?.length > 0 &&
            currentDate.weekday !== undefined &&
            currentDate.countsForWeekdays()) {
            const weekdayIndex = currentDate.weekday;
            if (weekdayIndex >= 0 && weekdayIndex < activeCalendar.weekdays.length) {
                const weekday = activeCalendar.weekdays[weekdayIndex];
                weekdayDisplay = weekday?.abbreviation || weekday?.name?.substring(0, 3) || '';
            }
        }
        // Check the always show quick time buttons setting
        const alwaysShowQuickTimeButtons = game.settings?.get('seasons-and-stars', 'alwaysShowQuickTimeButtons') || false;
        // Get time advancement state for GM users
        let timeAdvancementActive = false;
        let advancementRatioDisplay = '1.0x speed';
        if (game.user?.isGM) {
            try {
                const timeService = TimeAdvancementService.getInstance();
                timeAdvancementActive = timeService?.shouldShowPauseButton || false;
                const ratio = game.settings?.get('seasons-and-stars', 'timeAdvancementRatio') || 1.0;
                advancementRatioDisplay = `${ratio}x speed`;
            }
            catch (error) {
                Logger.warn('Failed to get time advancement state', error);
            }
        }
        // Determine if compact mode should be applied based on active features
        const showTimeControlsValue = (!hasSmallTime || alwaysShowQuickTimeButtons) && (game.user?.isGM || false);
        const compactMode = showDayOfWeek && showTimeControlsValue;
        return Object.assign(context, {
            shortDate: currentDate.toShortString(),
            hasSmallTime: hasSmallTime,
            showTimeControls: showTimeControlsValue,
            isGM: game.user?.isGM || false,
            showTime: showTime,
            timeString: showTime && currentDate.time
                ? this.getTimeDisplayString(currentDate.time, activeCalendar)
                : '',
            showDayOfWeek: showDayOfWeek,
            weekdayDisplay: weekdayDisplay,
            timeAdvancementActive: timeAdvancementActive,
            advancementRatioDisplay: advancementRatioDisplay,
            compactMode: compactMode,
            calendar: {
                id: activeCalendar.id || 'unknown',
                label: activeCalendar.label || activeCalendar.name || 'Unknown Calendar',
                description: activeCalendar.description,
            },
            currentDate: currentDate.toObject(),
            formattedDate: currentDate.toLongString(),
        });
    }
    /**
     * Format time for compact display in mini widget - supports canonical hours
     */
    getTimeDisplayString(time, calendar) {
        // Get canonical mode setting
        const canonicalMode = game.settings?.get('seasons-and-stars', 'miniWidgetCanonicalMode') || 'auto';
        // If exact mode or no calendar, always show exact time
        if (canonicalMode === 'exact' || !calendar) {
            return this.formatExactTime(time);
        }
        // Check for canonical hours
        const canonicalHours = calendar.canonicalHours;
        if (!canonicalHours || canonicalHours.length === 0) {
            return this.formatExactTime(time);
        }
        // Look for matching canonical hour
        const canonicalHour = this.findCanonicalHour(canonicalHours, time.hour, time.minute, calendar);
        if (canonicalHour) {
            // Truncate long names for mini widget space constraints
            return this.truncateCanonicalName(canonicalHour.name);
        }
        // No canonical hour found
        if (canonicalMode === 'canonical') {
            // Hide time when canonical mode is forced but no canonical hour available
            return '';
        }
        // Fallback to exact time for auto mode
        return this.formatExactTime(time);
    }
    /**
     * Format exact time as HH:MM
     */
    formatExactTime(time) {
        const hour = time.hour.toString().padStart(2, '0');
        const minute = time.minute.toString().padStart(2, '0');
        return `${hour}:${minute}`;
    }
    /**
     * Find canonical hour that matches the given time
     */
    findCanonicalHour(canonicalHours, hour, minute, calendar) {
        // Use DateFormatter's static method for consistency
        return DateFormatter.findCanonicalHour(canonicalHours, hour, minute, calendar);
    }
    /**
     * Truncate canonical hour names for mini widget display
     */
    truncateCanonicalName(name) {
        // Allow longer names (18 chars) since canonical hours are more meaningful than exact time
        if (name.length <= 18) {
            return name;
        }
        return name.substring(0, 15) + '...';
    }
    /**
     * Simple post-render positioning like SmallTime
     */
    async _onRender(context, options) {
        await super._onRender(context, options);
        // Register this as the active instance
        CalendarMiniWidget.activeInstance = this;
        // Add click handlers for mini-date element
        const miniDateElement = this.element?.querySelector('.mini-date');
        if (miniDateElement) {
            // Handle single click
            miniDateElement.addEventListener('click', event => {
                event.preventDefault();
                event.stopPropagation();
                Logger.debug('Mini widget: Single click - opening larger view');
                this._onOpenLargerView(event, miniDateElement);
            });
            // Handle double click (browser automatically handles timing and cancellation)
            miniDateElement.addEventListener('dblclick', event => {
                event.preventDefault();
                event.stopPropagation();
                Logger.debug('Mini widget: Double-click detected, opening calendar selection');
                this._onOpenCalendarSelection(event, miniDateElement);
            });
        }
        // Render any existing sidebar buttons
        this.renderExistingSidebarButtons();
        this.element?.addEventListener('contextmenu', event => {
            event.preventDefault();
            if (game.settings?.get('seasons-and-stars', 'miniWidgetPinned')) {
                this.unpin();
            }
        });
        const pinned = game.settings?.get('seasons-and-stars', 'miniWidgetPinned');
        if (pinned) {
            this.applyPinnedPosition();
        }
        else {
            this.positionWidget();
        }
        // Setup dragging after positioning
        this.setupDragging();
    }
    /**
     * Position widget - simplified approach like SmallTime
     */
    positionWidget() {
        if (!this.element || this.isClosing) {
            if (this.isClosing) {
                Logger.debug('Mini widget: Skipping positioning during close');
            }
            return;
        }
        // Skip repositioning if already positioned (reduces spam during time advancement)
        if (this.hasBeenPositioned) {
            return;
        }
        Logger.debug('Mini widget: Positioning widget');
        const smallTimeElement = SmallTimeUtils.getSmallTimeElement();
        if (smallTimeElement) {
            // Check if SmallTime is pinned/docked in DOM or floating
            if (this.isSmallTimeDocked(smallTimeElement)) {
                Logger.debug('Mini widget: SmallTime is docked - using DOM positioning');
                this.dockAboveSmallTime(smallTimeElement);
            }
            else {
                Logger.debug('Mini widget: SmallTime is floating - using fixed positioning');
                this.positionAboveSmallTime(smallTimeElement);
            }
        }
        else if (document.getElementById('players')) {
            Logger.debug('Mini widget: No SmallTime - docking to player list');
            this.dockToPlayerList();
        }
        else {
            Logger.debug('Mini widget: No SmallTime or player list - using standalone positioning');
            this.positionStandalone();
        }
        // Mark as positioned to avoid repeated repositioning during time advancement
        this.hasBeenPositioned = true;
    }
    /**
     * Apply pinned position styling
     */
    applyPinnedPosition() {
        if (!this.element)
            return;
        // ApplicationV2 has the position but doesn't automatically apply it to the DOM
        // We need to manually apply the position from ApplicationV2's position property
        if (this.position.top !== undefined && this.position.left !== undefined) {
            this.element.style.position = 'fixed';
            this.element.style.top = `${this.position.top}px`;
            this.element.style.left = `${this.position.left}px`;
        }
        // Apply the visual styling for pinned mode
        this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
        this.element.classList.add('standalone-mode');
        this.element.classList.remove('docked-mode', 'above-smalltime', 'below-smalltime', 'beside-smalltime');
        this.hasBeenPositioned = true;
    }
    /**
     * Setup dragging using Foundry's built-in Draggable class
     */
    setupDragging() {
        if (!this.element)
            return;
        // Create a Draggable instance and wrap the drag end method
        const draggable = new foundry.applications.ux.Draggable(this, // app
        this.element, // element (outer)
        this.element, // handle (drag element - use the whole widget)
        false // resizable
        );
        // Store the original drag start method and wrap it
        const originalOnDragMouseDown = draggable._onDragMouseDown;
        draggable._onDragMouseDown = function (event) {
            // Switch to fixed positioning for free dragging
            const rect = this.app.element.getBoundingClientRect();
            this.app.element.style.position = 'fixed';
            this.app.element.style.top = `${rect.top}px`;
            this.app.element.style.left = `${rect.left}px`;
            this.app.element.style.margin = '0';
            return originalOnDragMouseDown.call(this, event);
        };
        // Store the original drag end method and wrap it
        const originalOnDragMouseUp = draggable._onDragMouseUp;
        draggable._onDragMouseUp = async function (event) {
            // Call the original method first
            const result = originalOnDragMouseUp.call(this, event);
            // Apply pinned styling and save position
            const rect = this.app.element.getBoundingClientRect();
            this.app.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
            this.app.element.classList.add('standalone-mode');
            this.app.element.classList.remove('docked-mode', 'above-smalltime', 'below-smalltime', 'beside-smalltime');
            await game.settings?.set('seasons-and-stars', 'miniWidgetPinned', true);
            await game.settings?.set('seasons-and-stars', 'miniWidgetPosition', {
                top: rect.top,
                left: rect.left,
            });
            return result;
        };
    }
    /**
     * Unpin the widget and reset to automatic positioning
     */
    async unpin() {
        await game.settings?.set('seasons-and-stars', 'miniWidgetPinned', false);
        await game.settings?.set('seasons-and-stars', 'miniWidgetPosition', {
            top: null,
            left: null,
        });
        this.hasBeenPositioned = false;
        this.positionWidget();
    }
    /**
     * Attach event listeners to rendered parts
     */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        // Add proper action handling for data-action elements
        htmlElement.addEventListener('click', this._onClickAction.bind(this));
    }
    /**
     * Handle click actions on elements with data-action attributes
     */
    _onClickAction(event) {
        const target = event.target;
        const actionElement = target.closest('[data-action]');
        if (!actionElement)
            return;
        const action = actionElement.dataset.action;
        if (!action)
            return;
        // Skip openCalendarSelection on mini-date to let double-click handler manage it
        if (action === 'openCalendarSelection' && actionElement.classList.contains('mini-date')) {
            return; // Let the custom double-click handler manage mini-date clicks
        }
        // Prevent default for all other actions
        event.preventDefault();
        event.stopPropagation();
        Logger.debug(`Mini widget action triggered: ${action}`);
        // Call the appropriate action handler
        switch (action) {
            case 'advanceTime':
                this._onAdvanceTime(event, actionElement);
                break;
            case 'toggleTimeAdvancement':
                this._onToggleTimeAdvancement(event, actionElement);
                break;
            case 'openCalendarSelection':
                this._onOpenCalendarSelection(event, actionElement);
                break;
            case 'openLargerView':
                this._onOpenLargerView(event, actionElement);
                break;
            default:
                Logger.warn(`Unknown action: ${action}`);
                break;
        }
    }
    /**
     * Hide widget with smooth animation (SmallTime approach)
     */
    hideWithAnimation() {
        if (!this.element || !this.rendered || this.isClosing)
            return;
        Logger.debug('Mini widget: Starting hide animation');
        // Mark as closing to prevent positioning changes
        this.isClosing = true;
        // Capture current position before animation to prevent movement
        const rect = this.element.getBoundingClientRect();
        Logger.debug('Mini widget: Captured position before hide', {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height,
        });
        // Lock the position using fixed positioning
        this.element.style.position = 'fixed';
        this.element.style.top = `${rect.top}px`;
        this.element.style.left = `${rect.left}px`;
        this.element.style.width = `${rect.width}px`;
        this.element.style.height = `${rect.height}px`;
        // Stop any existing animations and apply custom fade-out
        $(this.element).stop();
        $(this.element).css({
            animation: 'seasons-stars-fade-out 0.2s ease-out',
            opacity: '0',
        });
        // Delay the actual close until after fade completes
        setTimeout(() => {
            Logger.debug('Mini widget: Animation complete, closing');
            this.close();
        }, WIDGET_POSITIONING.FADE_ANIMATION_DURATION);
    }
    /**
     * Handle closing the widget
     */
    async close(options = {}) {
        // Clear active instance if this is it
        if (CalendarMiniWidget.activeInstance === this) {
            CalendarMiniWidget.activeInstance = null;
        }
        // Clean up mutation observer
        const observer = this._playerListObserver;
        if (observer) {
            observer.disconnect();
            delete this._playerListObserver;
        }
        // Reset closing flag and positioning state
        this.isClosing = false;
        this.hasBeenPositioned = false;
        return super.close(options);
    }
    /**
     * Handle Foundry hooks for real-time updates
     */
    static registerHooks() {
        // Update widget when date changes
        Hooks.on('seasons-stars:dateChanged', () => {
            if (CalendarMiniWidget.activeInstance?.rendered) {
                CalendarMiniWidget.activeInstance.render();
            }
        });
        // Update widget when calendar changes
        Hooks.on('seasons-stars:calendarChanged', () => {
            if (CalendarMiniWidget.activeInstance?.rendered) {
                CalendarMiniWidget.activeInstance.render();
            }
        });
        // Update widget when settings change (especially quick time buttons and time display)
        Hooks.on('seasons-stars:settingsChanged', (settingName) => {
            if ((settingName === 'quickTimeButtons' ||
                settingName === 'miniWidgetQuickTimeButtons' ||
                settingName === 'miniWidgetShowTime' ||
                settingName === 'miniWidgetShowDayOfWeek' ||
                settingName === 'miniWidgetCanonicalMode' ||
                settingName === 'alwaysShowQuickTimeButtons') &&
                CalendarMiniWidget.activeInstance?.rendered) {
                CalendarMiniWidget.activeInstance.render();
            }
        });
    }
    /**
     * Show the mini widget
     * Creates a new instance if none exists, or renders existing instance if not already visible.
     * The widget will automatically position itself relative to SmallTime or the player list.
     *
     * @example
     * ```typescript
     * CalendarMiniWidget.show();
     * ```
     */
    static show() {
        if (CalendarMiniWidget.activeInstance) {
            if (!CalendarMiniWidget.activeInstance.rendered) {
                CalendarMiniWidget.activeInstance.render(true);
            }
        }
        else {
            new CalendarMiniWidget().render(true);
        }
    }
    /**
     * Hide the mini widget with smooth animation
     * Uses a fade-out animation before closing to provide visual feedback.
     * Safe to call even if no widget is currently displayed.
     *
     * @example
     * ```typescript
     * CalendarMiniWidget.hide();
     * ```
     */
    static hide() {
        if (CalendarMiniWidget.activeInstance?.rendered) {
            CalendarMiniWidget.activeInstance.hideWithAnimation();
        }
    }
    /**
     * Get the current active instance of the mini widget
     * Returns null if no widget is currently instantiated.
     * Useful for external modules that need to interact with the widget.
     *
     * @returns The active CalendarMiniWidget instance, or null if none exists
     * @example
     * ```typescript
     * const widget = CalendarMiniWidget.getInstance();
     * if (widget) {
     *   widget.addSidebarButton('my-button', 'fas fa-cog', 'Settings', () => {});
     * }
     * ```
     */
    static getInstance() {
        return CalendarMiniWidget.activeInstance;
    }
    /**
     * Add a sidebar button to the mini widget
     * Provides generic API for integration with other modules via compatibility bridges
     */
    addSidebarButton(name, icon, tooltip, callback) {
        // Check if button already exists
        const existingButton = this.sidebarButtons.find(btn => btn.name === name);
        if (existingButton) {
            Logger.debug(`Button "${name}" already exists in mini widget`);
            return;
        }
        // Add to buttons array
        this.sidebarButtons.push({ name, icon, tooltip, callback });
        Logger.debug(`Added sidebar button "${name}" to mini widget`);
        // If widget is rendered, add button to DOM immediately
        if (this.rendered && this.element) {
            this.renderSidebarButton(name, icon, tooltip, callback);
        }
    }
    /**
     * Remove a sidebar button by name
     */
    removeSidebarButton(name) {
        const index = this.sidebarButtons.findIndex(btn => btn.name === name);
        if (index !== -1) {
            this.sidebarButtons.splice(index, 1);
            Logger.debug(`Removed sidebar button "${name}" from mini widget`);
            // Remove from DOM if rendered
            if (this.rendered && this.element) {
                const buttonId = `mini-sidebar-btn-${name.toLowerCase().replace(/\s+/g, '-')}`;
                const buttonElement = this.element.querySelector(`#${buttonId}`);
                if (buttonElement) {
                    buttonElement.remove();
                }
            }
        }
    }
    /**
     * Check if a sidebar button exists
     */
    hasSidebarButton(name) {
        return this.sidebarButtons.some(btn => btn.name === name);
    }
    /**
     * Render a sidebar button in the mini widget DOM
     */
    renderSidebarButton(name, icon, tooltip, callback) {
        if (!this.element)
            return;
        const buttonId = `mini-sidebar-btn-${name.toLowerCase().replace(/\s+/g, '-')}`;
        // Don't add if already exists in DOM
        if (this.element.querySelector(`#${buttonId}`)) {
            return;
        }
        // Find or create header area for buttons
        let headerArea = this.element.querySelector('.mini-widget-header');
        if (!headerArea) {
            // Create header if it doesn't exist
            headerArea = document.createElement('div');
            headerArea.className = 'mini-widget-header';
            headerArea.style.cssText =
                'display: flex; justify-content: flex-end; align-items: center; padding: 2px 4px; background: rgba(0,0,0,0.1); border-bottom: 1px solid var(--color-border-light-tertiary);';
            // Insert at the beginning of the widget
            this.element.insertBefore(headerArea, this.element.firstChild);
        }
        // Create button element
        const button = document.createElement('button');
        button.id = buttonId;
        button.className = 'mini-sidebar-button';
        button.title = tooltip;
        button.innerHTML = `<i class="fas ${icon}"></i>`;
        button.style.cssText = `
      background: var(--color-bg-btn, #f0f0f0);
      border: 1px solid var(--color-border-dark, #999);
      border-radius: 2px;
      padding: 2px 4px;
      margin-left: 2px;
      cursor: pointer;
      font-size: 10px;
      color: var(--color-text-primary, #000);
      transition: background-color 0.15s ease;
    `;
        // Add click handler
        button.addEventListener('click', event => {
            event.preventDefault();
            event.stopPropagation();
            try {
                callback();
            }
            catch (error) {
                Logger.error(`Error in mini widget sidebar button "${name}"`, error);
            }
        });
        // Add hover effects
        button.addEventListener('mouseenter', () => {
            button.style.background = 'var(--color-bg-btn-hover, #e0e0e0)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.background = 'var(--color-bg-btn, #f0f0f0)';
        });
        headerArea.appendChild(button);
        Logger.debug(`Rendered sidebar button "${name}" in mini widget DOM`);
    }
    /**
     * Render all existing sidebar buttons (called after widget render)
     */
    renderExistingSidebarButtons() {
        this.sidebarButtons.forEach(button => {
            this.renderSidebarButton(button.name, button.icon, button.tooltip, button.callback);
        });
    }
    /**
     * Toggle mini widget visibility
     * Shows the widget if hidden, hides it if currently displayed.
     * This is the primary method used by keyboard shortcuts and scene controls.
     *
     * @example
     * ```typescript
     * // Toggle widget from a macro or keybinding
     * CalendarMiniWidget.toggle();
     *
     * // Can also be called from the global API
     * game.seasonsStars.widgets.toggleMini();
     * ```
     */
    static toggle() {
        if (CalendarMiniWidget.activeInstance?.rendered) {
            CalendarMiniWidget.activeInstance.hideWithAnimation();
        }
        else {
            CalendarMiniWidget.show();
        }
    }
    /**
     * Instance action handler for time advancement
     */
    async _onAdvanceTime(event, target) {
        event.preventDefault();
        const amount = parseInt(target.dataset.amount || '0');
        const unit = target.dataset.unit || 'hours';
        const manager = game.seasonsStars?.manager;
        if (!manager)
            return;
        Logger.info(`Mini widget advancing time: ${amount} ${unit}`);
        try {
            switch (unit) {
                case 'minutes':
                    await manager.advanceMinutes(amount);
                    break;
                case 'hours':
                    await manager.advanceHours(amount);
                    break;
                default:
                    Logger.warn(`Unknown time unit: ${unit}`);
                    return;
            }
        }
        catch (error) {
            Logger.error('Error advancing time', error);
            ui.notifications?.error('Failed to advance time');
        }
    }
    /**
     * Handle toggling time advancement on/off
     */
    async _onToggleTimeAdvancement(event, _target) {
        event.preventDefault();
        try {
            const service = TimeAdvancementService.getInstance();
            if (!service) {
                ui.notifications?.error('Time advancement service not available');
                return;
            }
            if (service.shouldShowPauseButton) {
                service.pause();
                Logger.info('Mini widget: Paused time advancement');
            }
            else {
                await service.play();
                Logger.info('Mini widget: Started time advancement');
            }
            // Re-render to update button state
            this.render();
        }
        catch (error) {
            ui.notifications?.error('Failed to toggle time advancement');
            Logger.error('Mini widget time advancement toggle failed', error);
        }
    }
    /**
     * Handle opening calendar selection dialog
     */
    async _onOpenCalendarSelection(event, _target) {
        event.preventDefault();
        const manager = game.seasonsStars?.manager;
        if (!manager)
            return;
        try {
            const calendars = manager.getAllCalendars();
            const activeCalendar = manager.getActiveCalendar();
            const currentCalendarId = activeCalendar?.id || 'gregorian';
            const { CalendarSelectionDialog } = await Promise.resolve().then(function () { return calendarSelectionDialog; });
            new CalendarSelectionDialog(calendars, currentCalendarId).render(true);
        }
        catch (error) {
            Logger.error('Error opening calendar selection', error);
            ui.notifications?.error('Failed to open calendar selection');
        }
    }
    /**
     * Detect if SmallTime module is available and active
     */
    /**
     * Auto-position the mini widget relative to SmallTime or find optimal standalone position
     */
    autoPositionRelativeToSmallTime() {
        if (this.isClosing)
            return;
        if (game.settings?.get('seasons-and-stars', 'miniWidgetPinned')) {
            this.applyPinnedPosition();
            return;
        }
        // Reset positioning flag to force repositioning when SmallTime moves
        this.hasBeenPositioned = false;
        // Wait for both our element and SmallTime to be ready
        const attemptPositioning = (attempts = 0) => {
            if (this.isClosing)
                return; // Check again in case close started during attempts
            const maxAttempts = WIDGET_POSITIONING.MAX_POSITIONING_ATTEMPTS;
            const smallTimeElement = SmallTimeUtils.getSmallTimeElement();
            if (smallTimeElement && this.element && this.rendered) {
                // Both elements exist and we're rendered, proceed with positioning
                Logger.debug(`Auto-positioning mini widget relative to SmallTime (attempt ${attempts + 1})`);
                this.positionRelativeToSmallTime('above'); // Default to above instead of below
            }
            else if (attempts < maxAttempts) {
                // Retry after a short delay
                Logger.debug(`Retrying positioning (attempt ${attempts + 1} of ${maxAttempts})`);
                setTimeout(() => attemptPositioning(attempts + 1), WIDGET_POSITIONING.POSITIONING_RETRY_DELAY);
            }
            else {
                // SmallTime not found - use standalone positioning
                Logger.debug('SmallTime not found, using standalone positioning');
                this.positionStandalone();
            }
        };
        // Start the positioning attempt
        requestAnimationFrame(() => attemptPositioning());
    }
    /**
     * Position mini widget in standalone mode (when SmallTime is not available)
     * First try to dock to player list, then fallback to fixed positioning
     */
    positionStandalone() {
        if (!this.element)
            return;
        // First attempt: Try SmallTime-style docking to player list
        const playerList = document.getElementById('players');
        if (playerList) {
            this.positionRelativeToPlayerList();
            return;
        }
        // Fallback: Fixed positioning if player list not found
        let position = this.getFallbackPosition();
        // Check if fallback position is within viewport bounds
        const bounds = this.isPositionOutsideViewport(position);
        if (bounds.outsideTop || bounds.outsideBottom || bounds.outsideLeft || bounds.outsideRight) {
            position = this.correctPositionForViewport(position);
        }
        // Apply the fixed position as last resort
        this.element.style.position = 'fixed';
        this.element.style.top = `${position.top}px`;
        this.element.style.left = `${position.left}px`;
        this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
        this.element.style.margin = '0';
        // Add a class to indicate standalone mode
        this.element.classList.add('standalone-mode');
        this.element.classList.remove('above-smalltime', 'below-smalltime', 'beside-smalltime', 'docked-mode');
    }
    /**
     * Find SmallTime element using multiple strategies
     */
    /**
     * Position the mini widget relative to SmallTime
     */
    positionRelativeToSmallTime(position = 'below') {
        const smallTimeElement = SmallTimeUtils.getSmallTimeElement();
        if (!smallTimeElement || !this.element) {
            Logger.debug('SmallTime not found, using standalone positioning');
            // Use standalone positioning instead of basic fallback
            this.positionStandalone();
            return;
        }
        Logger.debug(`Found SmallTime, positioning mini widget ${position}`);
        // Wait for the mini widget to be properly rendered before getting dimensions
        requestAnimationFrame(() => {
            const smallTimeRect = smallTimeElement.getBoundingClientRect();
            // Use standardized mini widget height
            const estimatedMiniHeight = WIDGET_POSITIONING.MINI_WIDGET_HEIGHT;
            Logger.debug('SmallTime rect', smallTimeRect);
            Logger.debug(`Using estimated mini height: ${estimatedMiniHeight}`);
            let newPosition;
            switch (position) {
                case 'above':
                    newPosition = {
                        top: smallTimeRect.top - estimatedMiniHeight - 8,
                        left: smallTimeRect.left,
                    };
                    this.element?.classList.add('above-smalltime');
                    this.element?.classList.remove('below-smalltime', 'beside-smalltime');
                    break;
                case 'beside':
                    newPosition = {
                        top: smallTimeRect.top,
                        left: smallTimeRect.right + 8,
                    };
                    this.element?.classList.add('beside-smalltime');
                    this.element?.classList.remove('above-smalltime', 'below-smalltime');
                    break;
                case 'below':
                default:
                    newPosition = {
                        top: smallTimeRect.bottom + 8,
                        left: smallTimeRect.left,
                    };
                    this.element?.classList.add('below-smalltime');
                    this.element?.classList.remove('above-smalltime', 'beside-smalltime');
                    break;
            }
            // Check if calculated position would be outside viewport
            const bounds = this.isPositionOutsideViewport(newPosition);
            if (bounds.outsideTop || bounds.outsideBottom || bounds.outsideLeft || bounds.outsideRight) {
                newPosition = this.correctPositionForViewport(newPosition);
            }
            Logger.debug('Positioning mini widget at', newPosition);
            // Apply positioning directly via CSS (more reliable than setPosition for frameless windows)
            if (this.element) {
                this.element.style.position = 'fixed';
                this.element.style.top = `${newPosition.top}px`;
                this.element.style.left = `${newPosition.left}px`;
                this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
                // Try to match SmallTime's actual background color
                this.matchSmallTimeBackground(smallTimeElement);
                Logger.debug('Applied CSS positioning directly');
                // Verify final position
                setTimeout(() => {
                    const finalRect = this.element?.getBoundingClientRect();
                    Logger.debug('Final position', finalRect);
                }, WIDGET_POSITIONING.POSITIONING_RETRY_DELAY);
            }
        });
    }
    /**
     * Match SmallTime's actual background styling
     */
    matchSmallTimeBackground(smallTimeElement) {
        try {
            // Find SmallTime's content area
            const smallTimeContent = smallTimeElement.querySelector('.window-content') ||
                smallTimeElement.querySelector('form') ||
                smallTimeElement;
            if (smallTimeContent && this.element) {
                const computedStyle = getComputedStyle(smallTimeContent);
                const miniContent = this.element.querySelector('.calendar-mini-content');
                if (miniContent) {
                    // Try to match the background
                    const background = computedStyle.backgroundColor;
                    const backgroundImage = computedStyle.backgroundImage;
                    Logger.debug('SmallTime background', { background, backgroundImage });
                    if (background && background !== 'rgba(0, 0, 0, 0)') {
                        miniContent.style.background = background;
                    }
                    if (backgroundImage && backgroundImage !== 'none') {
                        miniContent.style.backgroundImage = backgroundImage;
                    }
                }
            }
        }
        catch (error) {
            Logger.debug('Could not match SmallTime background', error);
        }
    }
    /**
     * Public positioning methods
     */
    static positionAboveSmallTime() {
        if (CalendarMiniWidget.activeInstance?.rendered) {
            CalendarMiniWidget.activeInstance.positionRelativeToSmallTime('above');
        }
    }
    static positionBelowSmallTime() {
        if (CalendarMiniWidget.activeInstance?.rendered) {
            CalendarMiniWidget.activeInstance.positionRelativeToSmallTime('below');
        }
    }
    static positionBesideSmallTime() {
        if (CalendarMiniWidget.activeInstance?.rendered) {
            CalendarMiniWidget.activeInstance.positionRelativeToSmallTime('beside');
        }
    }
    /**
     * Listen for SmallTime position changes and update accordingly
     */
    static registerSmallTimeIntegration() {
        // Listen for SmallTime app rendering/movement
        Hooks.on('renderApplication', (app) => {
            if (app.id === 'smalltime-app' &&
                CalendarMiniWidget.activeInstance?.rendered &&
                !CalendarMiniWidget.activeInstance.isClosing) {
                // Delay to ensure SmallTime positioning is complete
                setTimeout(() => {
                    CalendarMiniWidget.activeInstance?.autoPositionRelativeToSmallTime();
                }, WIDGET_POSITIONING.POSITIONING_RETRY_DELAY);
            }
        });
        // Listen for player list changes that might affect positioning
        Hooks.on('renderPlayerList', () => {
            if (CalendarMiniWidget.activeInstance?.rendered &&
                !CalendarMiniWidget.activeInstance.isClosing) {
                setTimeout(() => {
                    CalendarMiniWidget.activeInstance?.handlePlayerListChange();
                }, 50);
            }
        });
        // Also listen for general UI updates that might affect player list
        Hooks.on('renderSidebar', () => {
            if (CalendarMiniWidget.activeInstance?.rendered &&
                !CalendarMiniWidget.activeInstance.isClosing) {
                setTimeout(() => {
                    CalendarMiniWidget.activeInstance?.handlePlayerListChange();
                }, WIDGET_POSITIONING.POSITIONING_RETRY_DELAY);
            }
        });
        // Use MutationObserver to watch for player list changes in real-time
        const playerList = document.getElementById('players');
        if (playerList && CalendarMiniWidget.activeInstance) {
            const observer = new MutationObserver(() => {
                if (CalendarMiniWidget.activeInstance?.rendered &&
                    !CalendarMiniWidget.activeInstance.isClosing) {
                    CalendarMiniWidget.activeInstance.handlePlayerListChange();
                }
            });
            observer.observe(playerList, {
                attributes: true,
                attributeFilter: ['class', 'style'],
                childList: true,
                subtree: true,
            });
            // Store observer for cleanup
            CalendarMiniWidget.activeInstance._playerListObserver = observer;
        }
        // Listen for window resize to maintain positioning
        window.addEventListener('resize', () => {
            if (CalendarMiniWidget.activeInstance?.rendered &&
                !CalendarMiniWidget.activeInstance.isClosing) {
                // Re-evaluate positioning on resize
                CalendarMiniWidget.activeInstance.autoPositionRelativeToSmallTime();
            }
        });
    }
    /**
     * Check if a position would place the widget outside viewport boundaries
     */
    isPositionOutsideViewport(position) {
        if (!window) {
            return { outsideTop: false, outsideBottom: false, outsideLeft: false, outsideRight: false };
        }
        // Use standardized widget dimensions
        const widgetWidth = WIDGET_POSITIONING.MINI_WIDGET_WIDTH;
        const widgetHeight = WIDGET_POSITIONING.MINI_WIDGET_HEIGHT;
        const viewportHeight = window.innerHeight || 768;
        const viewportWidth = window.innerWidth || 1024;
        return {
            outsideTop: position.top < 0,
            outsideBottom: position.top + widgetHeight > viewportHeight,
            outsideLeft: position.left < 0,
            outsideRight: position.left + widgetWidth > viewportWidth,
        };
    }
    /**
     * Correct a position to ensure it stays within viewport boundaries
     */
    correctPositionForViewport(position) {
        if (!window) {
            return position;
        }
        // Handle invalid values
        if (!Number.isFinite(position.top) || !Number.isFinite(position.left)) {
            return this.getFallbackPosition();
        }
        const padding = WIDGET_POSITIONING.VIEWPORT_PADDING;
        const widgetWidth = WIDGET_POSITIONING.MINI_WIDGET_WIDTH;
        const widgetHeight = WIDGET_POSITIONING.MINI_WIDGET_HEIGHT;
        const viewportHeight = window.innerHeight || 768;
        const viewportWidth = window.innerWidth || 1024;
        let correctedTop = position.top;
        let correctedLeft = position.left;
        // Correct top boundary
        if (correctedTop < padding) {
            correctedTop = padding;
        }
        // Correct bottom boundary
        if (correctedTop + widgetHeight > viewportHeight - padding) {
            correctedTop = Math.max(padding, viewportHeight - widgetHeight - padding);
        }
        // Correct left boundary
        if (correctedLeft < padding) {
            correctedLeft = padding;
        }
        // Correct right boundary
        if (correctedLeft + widgetWidth > viewportWidth - padding) {
            correctedLeft = Math.max(padding, viewportWidth - widgetWidth - padding);
        }
        return { top: correctedTop, left: correctedLeft };
    }
    /**
     * Get a sensible fallback position for the widget
     */
    getFallbackPosition() {
        if (!window) {
            return { top: 80, left: 20 };
        }
        const viewportHeight = window.innerHeight || 768;
        // Position in lower-left area, typical for UI widgets
        return {
            top: viewportHeight - WIDGET_POSITIONING.STANDALONE_BOTTOM_OFFSET,
            left: 20,
        };
    }
    /**
     * Handle player list expansion/contraction
     */
    handlePlayerListChange() {
        if (this.isClosing)
            return;
        if (game.settings?.get('seasons-and-stars', 'miniWidgetPinned'))
            return;
        const playerList = document.getElementById('players');
        // Check if player list is expanded using the same approach as SmallTime
        const isExpanded = playerList?.classList.contains('expanded') || false;
        if (this.element) {
            this.element.classList.toggle('player-list-expanded', isExpanded);
            // Use SmallTime-style positioning - insert before player list when not with SmallTime
            if (!SmallTimeUtils.getSmallTimeElement()) {
                this.positionRelativeToPlayerList();
            }
        }
    }
    /**
     * Position widget relative to player list using SmallTime approach
     */
    positionRelativeToPlayerList() {
        if (!this.element)
            return;
        const playerList = document.getElementById('players');
        if (!playerList)
            return;
        try {
            // Check if player list position would put widget outside viewport
            const playerListRect = playerList.getBoundingClientRect();
            const testPosition = {
                top: playerListRect.top - WIDGET_POSITIONING.MINI_WIDGET_HEIGHT,
                left: playerListRect.left,
            };
            const bounds = this.isPositionOutsideViewport(testPosition);
            if (bounds.outsideTop || bounds.outsideLeft) {
                // Player list position would be outside viewport, using fallback
                this.positionStandalone();
                return;
            }
            // Use SmallTime's approach: insert before the player list in the DOM
            // This automatically moves with player list expansion/contraction
            const uiLeft = document.getElementById('ui-left');
            if (uiLeft && !uiLeft.contains(this.element)) {
                // Move to ui-left container and position before players list
                playerList.parentElement?.insertBefore(this.element, playerList);
                // Style as pinned/docked (similar to SmallTime)
                this.element.style.position = 'relative';
                this.element.style.top = 'auto';
                this.element.style.left = 'auto';
                this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
                this.element.style.margin = '0 0 8px 0'; // Small gap above player list
                this.element.classList.add('docked-mode');
                this.element.classList.remove('standalone-mode', 'above-smalltime', 'below-smalltime', 'beside-smalltime');
                Logger.debug('Mini widget docked above player list (SmallTime style)');
            }
        }
        catch (error) {
            Logger.warn('Error docking to player list, using fallback positioning', error);
            this.positionStandalone();
        }
    }
    /**
     * Simple positioning above SmallTime (like SmallTime's pinApp)
     */
    positionAboveSmallTime(smallTimeElement) {
        if (!this.element)
            return;
        const smallTimeRect = smallTimeElement.getBoundingClientRect();
        const estimatedMiniHeight = WIDGET_POSITIONING.MINI_WIDGET_HEIGHT;
        // Calculate position above SmallTime
        let position = {
            top: smallTimeRect.top - estimatedMiniHeight - 8,
            left: smallTimeRect.left,
        };
        // Check if position would be outside viewport
        const bounds = this.isPositionOutsideViewport(position);
        if (bounds.outsideTop || bounds.outsideBottom || bounds.outsideLeft || bounds.outsideRight) {
            // Position above SmallTime would be outside viewport, using fallback
            position = this.getFallbackPosition();
            position = this.correctPositionForViewport(position);
        }
        // Apply position
        this.element.style.position = 'fixed';
        this.element.style.top = `${position.top}px`;
        this.element.style.left = `${position.left}px`;
        this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
        this.element.classList.add('above-smalltime');
        this.element.classList.remove('below-smalltime', 'beside-smalltime', 'standalone-mode', 'docked-mode');
    }
    /**
     * Check if SmallTime is docked/pinned in the DOM hierarchy
     */
    isSmallTimeDocked(smallTimeElement) {
        // SmallTime adds 'pinned' class when docked
        if (smallTimeElement.classList.contains('pinned')) {
            return true;
        }
        // Also check if it's positioned in ui-left (where pinned widgets go)
        const uiLeft = document.getElementById('ui-left');
        if (uiLeft && uiLeft.contains(smallTimeElement)) {
            return true;
        }
        // Check if position is relative (docked) vs fixed (floating)
        const computedStyle = getComputedStyle(smallTimeElement);
        return computedStyle.position === 'relative';
    }
    /**
     * Dock above SmallTime in the DOM (when SmallTime is also docked)
     */
    dockAboveSmallTime(smallTimeElement) {
        if (!this.element)
            return;
        // Insert before SmallTime in the DOM (like SmallTime does with players)
        $(smallTimeElement).before(this.element);
        // Style for docked mode above SmallTime
        this.element.style.position = 'relative';
        this.element.style.top = 'auto';
        this.element.style.left = 'auto';
        this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
        this.element.style.margin = '0 0 8px 0'; // Small gap below us, above SmallTime
        this.element.classList.add('above-smalltime', 'docked-mode');
        this.element.classList.remove('below-smalltime', 'beside-smalltime', 'standalone-mode');
    }
    /**
     * Simple docking to player list (exactly like SmallTime's pinApp)
     */
    dockToPlayerList() {
        if (!this.element)
            return;
        const playerList = document.getElementById('players');
        if (!playerList)
            return;
        // Exactly like SmallTime: $('#players').before(app.element)
        $(playerList).before(this.element);
        // Style for docked mode
        this.element.style.position = 'relative';
        this.element.style.top = 'auto';
        this.element.style.left = 'auto';
        this.element.style.zIndex = WIDGET_POSITIONING.Z_INDEX.toString();
        this.element.style.margin = '0 0 8px 0';
        this.element.classList.add('docked-mode');
        this.element.classList.remove('standalone-mode', 'above-smalltime', 'below-smalltime', 'beside-smalltime');
    }
    /**
     * Open larger calendar view (default widget or grid based on setting)
     */
    async _onOpenLargerView(event, _target) {
        event.preventDefault();
        Logger.info('Opening larger view from mini widget');
        try {
            const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
            Logger.info(`Default widget setting: ${defaultWidget}`);
            // Open either the default widget or grid widget (both are larger than mini)
            if (defaultWidget === 'grid') {
                Logger.info('Opening grid widget');
                CalendarWidgetManager.showWidget('grid');
            }
            else {
                // For 'main' or anything else, show the main widget
                Logger.info('Opening main calendar widget');
                CalendarWidgetManager.showWidget('main');
            }
        }
        catch (error) {
            Logger.error('Failed to open larger view', error instanceof Error ? error : new Error(String(error)));
            // Fallback to main widget
            Logger.info('Fallback: Opening main calendar widget');
            CalendarWidgetManager.showWidget('main');
        }
    }
}
CalendarMiniWidget.activeInstance = null;
CalendarMiniWidget.DEFAULT_OPTIONS = {
    id: 'seasons-stars-mini-widget',
    classes: ['seasons-stars', 'calendar-mini-widget'],
    tag: 'div',
    window: {
        frame: false,
        positioned: true,
        minimizable: false,
        resizable: false,
    },
    position: {
        width: (function(){
  const el = document.querySelector('.calendar-mini-content');
  const rect = el?.getBoundingClientRect();
  return rect?.width ?? WIDGET_POSITIONING.MINI_WIDGET_WIDTH;
})(),
        height: 'auto',
        top: 100, // Start within viewport
        left: 20,
    },
    actions: {
        advanceTime: CalendarMiniWidget.prototype._onAdvanceTime,
        openCalendarSelection: CalendarMiniWidget.prototype._onOpenCalendarSelection,
        openLargerView: CalendarMiniWidget.prototype._onOpenLargerView,
        toggleTimeAdvancement: CalendarMiniWidget.prototype._onToggleTimeAdvancement,
    },
};
CalendarMiniWidget.PARTS = {
    main: {
        id: 'main',
        template: 'modules/seasons-and-stars/templates/calendar-mini-widget.hbs',
    },
};

/**
 * Calendar Grid Widget - Monthly calendar view for Seasons & Stars
 */
class CalendarGridWidget extends foundry.applications.api.HandlebarsApplicationMixin(foundry.applications.api.ApplicationV2) {
    constructor(initialDate) {
        super();
        this.sidebarButtons = [];
        // Use provided date or current date
        const manager = game.seasonsStars?.manager;
        if (initialDate) {
            this.viewDate = initialDate;
        }
        else {
            const currentDate = manager?.getCurrentDate();
            if (currentDate) {
                this.viewDate = currentDate;
            }
            else {
                // Fallback to default date
                this.viewDate = {
                    year: 2024,
                    month: 1,
                    day: 1,
                    weekday: 0,
                    time: { hour: 0, minute: 0, second: 0 },
                };
            }
        }
    }
    /**
     * Handle post-render setup
     */
    async _onRender(context, options) {
        await super._onRender(context, options);
        // Register as active instance
        CalendarGridWidget.activeInstance = this;
        // Render any existing sidebar buttons
        this.renderExistingSidebarButtons();
    }
    /**
     * Prepare rendering context for template
     */
    async _prepareContext(options = {}) {
        const context = await super._prepareContext(options);
        const manager = game.seasonsStars?.manager;
        if (!manager) {
            return Object.assign(context, {
                error: 'Calendar manager not initialized',
            });
        }
        const activeCalendar = manager.getActiveCalendar();
        const currentDate = manager.getCurrentDate();
        if (!activeCalendar || !currentDate) {
            return Object.assign(context, {
                error: 'No active calendar',
            });
        }
        const calendarInfo = CalendarLocalization.getLocalizedCalendarInfo(activeCalendar);
        const monthData = this.generateMonthData(activeCalendar, this.viewDate, currentDate);
        const clickBehavior = game.settings.get('seasons-and-stars', 'calendarClickBehavior');
        const isGM = game.user?.isGM || false;
        // Generate UI hint based on current settings
        let uiHint = '';
        if (isGM) {
            if (clickBehavior === 'viewDetails') {
                uiHint = 'Click dates to view details. Ctrl+Click to set current date.';
            }
            else {
                uiHint = 'Click dates to set current date.';
            }
        }
        else {
            uiHint = 'Click dates to view details.';
        }
        return Object.assign(context, {
            calendar: calendarInfo,
            viewDate: this.viewDate,
            currentDate: currentDate.toObject(),
            monthData: monthData,
            monthName: activeCalendar.months[this.viewDate.month - 1]?.name || 'Unknown',
            monthDescription: activeCalendar.months[this.viewDate.month - 1]?.description,
            yearDisplay: `${activeCalendar.year?.prefix || ''}${this.viewDate.year}${activeCalendar.year?.suffix || ''}`,
            isGM: isGM,
            clickBehavior: clickBehavior,
            uiHint: uiHint,
            weekdays: activeCalendar.weekdays.map(wd => ({
                name: wd.name,
                abbreviation: wd.abbreviation,
                description: wd.description,
            })),
        });
    }
    /**
     * Generate calendar month data with day grid and note indicators
     */
    generateMonthData(calendar, viewDate, currentDate) {
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return { weeks: [], totalDays: 0 };
        // Get month information
        const monthInfo = calendar.months[viewDate.month - 1];
        if (!monthInfo)
            return { weeks: [], totalDays: 0 };
        // Calculate month length (considering leap years)
        const monthLength = engine.getMonthLength(viewDate.month, viewDate.year);
        // Find the first day of the month and its weekday
        const firstDayData = {
            year: viewDate.year,
            month: viewDate.month,
            day: 1,
            weekday: engine.calculateWeekday(viewDate.year, viewDate.month, 1),
            time: { hour: 0, minute: 0, second: 0 },
        };
        const firstDay = new CalendarDate(firstDayData, calendar);
        // Get notes for this month for note indicators with category and tooltip information
        const notesManager = game.seasonsStars?.notes;
        const monthNotes = new Map(); // dateKey -> note data
        if (notesManager) {
            // Get all notes for the month
            // Get notes synchronously for UI performance
            try {
                for (let day = 1; day <= monthLength; day++) {
                    const dayDateData = {
                        year: viewDate.year,
                        month: viewDate.month,
                        day: day,
                        weekday: 0,
                        time: { hour: 0, minute: 0, second: 0 },
                    };
                    const dayDate = new CalendarDate(dayDateData, calendar);
                    const allNotes = notesManager.storage?.findNotesByDateSync(dayDate) || [];
                    const notes = allNotes.filter(note => {
                        // Use Foundry's native permission checking
                        if (!game.user)
                            return false; // No user logged in
                        if (game.user.isGM)
                            return true;
                        const ownership = note.ownership;
                        const userLevel = ownership[game.user.id] || ownership.default || CONST.DOCUMENT_OWNERSHIP_LEVELS.NONE;
                        return userLevel >= CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER;
                    });
                    if (notes.length > 0) {
                        const dateKey = this.formatDateKey(dayDate);
                        const dayCategories = new Set();
                        const noteDetails = [];
                        // Gather categories and details from all notes for this day
                        notes.forEach(note => {
                            const category = note.flags?.['seasons-and-stars']?.category || 'general';
                            const tags = note.flags?.['seasons-and-stars']?.tags || [];
                            dayCategories.add(category);
                            noteDetails.push({
                                title: note.name || 'Untitled Note',
                                tags: Array.isArray(tags) ? tags : [],
                            });
                        });
                        // Determine primary category (most common, or first if tied)
                        const categoryCount = new Map();
                        notes.forEach(note => {
                            const category = note.flags?.['seasons-and-stars']?.category || 'general';
                            categoryCount.set(category, (categoryCount.get(category) || 0) + 1);
                        });
                        const primaryCategory = Array.from(categoryCount.entries()).sort((a, b) => b[1] - a[1])[0]?.[0] || 'general';
                        monthNotes.set(dateKey, {
                            count: notes.length,
                            primaryCategory,
                            categories: dayCategories,
                            notes: noteDetails,
                        });
                    }
                }
            }
            catch (error) {
                Logger.warn('Error loading notes for calendar', error);
            }
        }
        // Build calendar grid
        const weeks = [];
        let currentWeek = [];
        // Fill in empty cells before month starts
        const startWeekday = firstDay.weekday || 0;
        for (let i = 0; i < startWeekday; i++) {
            currentWeek.push({
                day: 0,
                date: { year: 0, month: 0, day: 0, weekday: 0 },
                isCurrentMonth: false,
                isToday: false,
                hasNotes: false,
                isEmpty: true,
            });
        }
        // Fill in the days of the month
        for (let day = 1; day <= monthLength; day++) {
            const dayDateData = {
                year: viewDate.year,
                month: viewDate.month,
                day: day,
                weekday: engine.calculateWeekday(viewDate.year, viewDate.month, day),
                time: { hour: 0, minute: 0, second: 0 },
            };
            const dayDate = new CalendarDate(dayDateData, calendar);
            const isToday = this.isSameDate(dayDate, currentDate);
            const isViewDate = this.isSameDate(dayDate, viewDate);
            const dateKey = this.formatDateKey(dayDate);
            const noteData = monthNotes.get(dateKey);
            const noteCount = noteData?.count || 0;
            const hasNotes = noteCount > 0;
            // Determine category class for styling
            let categoryClass = '';
            if (hasNotes && noteData) {
                if (noteData.categories.size > 1) {
                    categoryClass = 'category-mixed';
                }
                else {
                    categoryClass = `category-${noteData.primaryCategory}`;
                }
            }
            // Create enhanced tooltip with note details
            let noteTooltip = '';
            if (hasNotes && noteData) {
                const notesList = noteData.notes
                    .map(note => {
                    const tagText = note.tags.length > 0 ? ` [${note.tags.join(', ')}]` : '';
                    return `${note.title}${tagText}`;
                })
                    .join('\n');
                noteTooltip = `${noteCount} note(s) (${noteData.primaryCategory}):\n${notesList}`;
            }
            // Calculate moon phases for this day
            let moonPhases = [];
            let primaryMoonPhase;
            let primaryMoonColor;
            let moonTooltip = '';
            let hasMultipleMoons = false;
            try {
                const moonPhaseInfo = engine.getMoonPhaseInfo?.(dayDate);
                if (moonPhaseInfo && moonPhaseInfo.length > 0) {
                    moonPhases = moonPhaseInfo.map(info => ({
                        moonName: info.moon.name,
                        phaseName: info.phase.name,
                        phaseIcon: info.phase.icon,
                        moonColor: info.moon.color,
                        dayInPhase: info.dayInPhase,
                        daysUntilNext: info.daysUntilNext,
                    }));
                    // Set primary moon (first moon) for simple display
                    const primaryMoon = moonPhaseInfo[0];
                    primaryMoonPhase = primaryMoon.phase.icon;
                    primaryMoonColor = primaryMoon.moon.color;
                    hasMultipleMoons = moonPhaseInfo.length > 1;
                    // Create moon tooltip
                    if (moonPhaseInfo.length === 1) {
                        const moon = moonPhaseInfo[0];
                        moonTooltip = `${moon.moon.name}: ${moon.phase.name}`;
                        if (moon.daysUntilNext > 0) {
                            moonTooltip += ` (${moon.daysUntilNext} days until next phase)`;
                        }
                    }
                    else {
                        moonTooltip = moonPhaseInfo
                            .map(info => `${info.moon.name}: ${info.phase.name}`)
                            .join('\n');
                    }
                }
            }
            catch (error) {
                // Silently handle moon calculation errors to avoid breaking calendar display
                console.debug('Error calculating moon phases for date:', dayDate, error);
            }
            currentWeek.push({
                day: day,
                date: {
                    year: dayDate.year,
                    month: dayDate.month,
                    day: dayDate.day,
                    weekday: dayDate.weekday,
                },
                isCurrentMonth: true,
                isToday: isToday,
                hasNotes: hasNotes,
                // Moon phase properties
                moonPhases: moonPhases,
                primaryMoonPhase: primaryMoonPhase,
                primaryMoonColor: primaryMoonColor,
                moonTooltip: moonTooltip,
                hasMultipleMoons: hasMultipleMoons,
                // Additional properties for template
                isSelected: isViewDate,
                isClickable: game.user?.isGM || false,
                weekday: dayDate.weekday,
                fullDate: `${viewDate.year}-${viewDate.month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`,
                noteCount: noteCount,
                noteMultiple: noteCount > 1,
                categoryClass: categoryClass,
                primaryCategory: noteData?.primaryCategory || 'general',
                noteTooltip: noteTooltip,
                canCreateNote: this.canCreateNote(),
            });
            // Start new week on last day of week
            if (currentWeek.length === calendar.weekdays.length) {
                weeks.push(currentWeek);
                currentWeek = [];
            }
        }
        // Fill in empty cells after month ends
        if (currentWeek.length > 0) {
            while (currentWeek.length < calendar.weekdays.length) {
                currentWeek.push({
                    day: 0,
                    date: { year: 0, month: 0, day: 0, weekday: 0 },
                    isCurrentMonth: false,
                    isToday: false,
                    hasNotes: false,
                    isEmpty: true,
                });
            }
            weeks.push(currentWeek);
        }
        // Add intercalary days as separate full-width rows
        const intercalaryDays = engine.getIntercalaryDaysAfterMonth(viewDate.year, viewDate.month);
        for (const intercalary of intercalaryDays) {
            // Find the month that this intercalary day comes after
            const afterMonthIndex = calendar.months.findIndex(m => m.name === intercalary.after);
            const intercalaryMonth = afterMonthIndex >= 0 ? afterMonthIndex + 1 : viewDate.month;
            const intercalaryDateData = {
                year: viewDate.year,
                month: intercalaryMonth, // Use the month it comes after (1-based)
                day: 1, // Intercalary days don't have regular day numbers
                weekday: 0, // Intercalary days don't have weekdays
                time: { hour: 0, minute: 0, second: 0 },
                intercalary: intercalary.name,
            };
            const intercalaryDate = new CalendarDate(intercalaryDateData, calendar);
            const isToday = this.isSameIntercalaryDate(intercalaryDate, currentDate);
            const isViewDate = this.isSameIntercalaryDate(intercalaryDate, viewDate);
            // Create intercalary day row as full-width cell
            const intercalaryRow = [
                {
                    day: intercalary.name,
                    date: intercalaryDate,
                    isToday: isToday,
                    isSelected: isViewDate,
                    isClickable: game.user?.isGM || false,
                    isCurrentMonth: true, // Intercalary days are always part of the current month
                    isIntercalary: true,
                    intercalaryName: intercalary.name,
                    intercalaryDescription: intercalary.description,
                    fullDate: `${viewDate.year}-${viewDate.month.toString().padStart(2, '0')}-${intercalary.name}`,
                    hasNotes: false, // TODO: Add intercalary note support in future
                    noteCount: 0,
                    categoryClass: '',
                    primaryCategory: 'general',
                    noteTooltip: '',
                    canCreateNote: this.canCreateNote(),
                },
            ];
            weeks.push(intercalaryRow);
        }
        return {
            weeks: weeks,
            totalDays: monthLength,
            monthName: monthInfo.name,
            monthDescription: monthInfo.description,
            intercalaryDays: intercalaryDays,
        };
    }
    /**
     * Format date as storage key
     */
    formatDateKey(date) {
        return `${date.year}-${date.month.toString().padStart(2, '0')}-${date.day.toString().padStart(2, '0')}`;
    }
    /**
     * Check if current user can create notes
     */
    canCreateNote() {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager)
            return false;
        // Use notes manager's canCreateNote method
        return notesManager.canCreateNote();
    }
    /**
     * Check if two dates are the same (ignoring time)
     */
    isSameDate(date1, date2) {
        // Basic date comparison
        const sameBasicDate = date1.year === date2.year && date1.month === date2.month && date1.day === date2.day;
        // Both must have the same intercalary status
        const bothIntercalary = !!date1.intercalary && !!date2.intercalary;
        const neitherIntercalary = !date1.intercalary && !date2.intercalary;
        const sameIntercalaryStatus = bothIntercalary || neitherIntercalary;
        // If both are intercalary, they must have the same intercalary name
        const sameIntercalaryName = bothIntercalary ? date1.intercalary === date2.intercalary : true;
        return sameBasicDate && sameIntercalaryStatus && sameIntercalaryName;
    }
    /**
     * Add ordinal suffix to a number (1st, 2nd, 3rd, etc.)
     */
    addOrdinalSuffix(num) {
        const lastDigit = num % 10;
        const lastTwoDigits = num % 100;
        // Handle special cases (11th, 12th, 13th)
        if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {
            return `${num}th`;
        }
        // Handle regular cases
        switch (lastDigit) {
            case 1:
                return `${num}st`;
            case 2:
                return `${num}nd`;
            case 3:
                return `${num}rd`;
            default:
                return `${num}th`;
        }
    }
    /**
     * Format a year with prefix and suffix from calendar configuration
     */
    formatYear(year) {
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar();
        if (!calendar)
            return year.toString();
        const prefix = calendar.year?.prefix || '';
        const suffix = calendar.year?.suffix || '';
        return `${prefix}${year}${suffix}`;
    }
    /**
     * Check if two intercalary dates are the same
     */
    isSameIntercalaryDate(date1, date2) {
        return (date1.year === date2.year &&
            date1.month === date2.month &&
            date1.intercalary === date2.intercalary &&
            !!date1.intercalary &&
            !!date2.intercalary);
    }
    /**
     * Navigate to previous month
     */
    async _onPreviousMonth(event, _target) {
        event.preventDefault();
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return;
        this.viewDate = engine.addMonths(this.viewDate, -1);
        this.render();
    }
    /**
     * Navigate to next month
     */
    async _onNextMonth(event, _target) {
        event.preventDefault();
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return;
        this.viewDate = engine.addMonths(this.viewDate, 1);
        this.render();
    }
    /**
     * Navigate to previous year
     */
    async _onPreviousYear(event, _target) {
        event.preventDefault();
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return;
        this.viewDate = engine.addYears(this.viewDate, -1);
        this.render();
    }
    /**
     * Navigate to next year
     */
    async _onNextYear(event, _target) {
        event.preventDefault();
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return;
        this.viewDate = engine.addYears(this.viewDate, 1);
        this.render();
    }
    /**
     * Select a specific date (GM only - sets world time) or view date details based on setting
     */
    async _onSelectDate(event, target) {
        event.preventDefault();
        const clickBehavior = game.settings.get('seasons-and-stars', 'calendarClickBehavior');
        const isGM = game.user?.isGM;
        const isCtrlClick = event.ctrlKey || event.metaKey;
        // Ctrl+Click always sets date (if GM)
        if (isCtrlClick && isGM) {
            return this.setCurrentDate(target);
        }
        // Regular click behavior based on setting
        if (clickBehavior === 'viewDetails') {
            return this.showDateInfo(target);
        }
        // Default behavior: set date (GM only)
        if (!isGM) {
            ui.notifications?.warn('Only GMs can change the current date');
            return;
        }
        return this.setCurrentDate(target);
    }
    /**
     * Set the current date (extracted from _onSelectDate for reuse)
     */
    async setCurrentDate(target) {
        const manager = game.seasonsStars?.manager;
        const engine = manager?.getActiveEngine();
        if (!manager || !engine)
            return;
        try {
            // Check if this is an intercalary day
            const calendarDay = target.closest('.calendar-day');
            const isIntercalary = calendarDay?.classList.contains('intercalary');
            let targetDate;
            const currentDate = manager.getCurrentDate();
            if (isIntercalary) {
                // Handle intercalary day selection
                const intercalaryName = target.dataset.day; // For intercalary days, day contains the name
                if (!intercalaryName)
                    return;
                // Find the intercalary day definition to determine which month it comes after
                const calendar = engine.getCalendar();
                const intercalaryDef = calendar.intercalary?.find(i => i.name === intercalaryName);
                if (!intercalaryDef)
                    return;
                // Find the month that this intercalary day comes after
                const afterMonthIndex = calendar.months.findIndex(m => m.name === intercalaryDef.after);
                if (afterMonthIndex === -1)
                    return;
                const targetDateData = {
                    year: this.viewDate.year,
                    month: afterMonthIndex + 1, // Use the month it comes after (1-based)
                    day: 1, // Intercalary days typically use day 1 as a placeholder
                    weekday: 0, // Intercalary days don't have weekdays
                    time: currentDate?.time || { hour: 0, minute: 0, second: 0 },
                    intercalary: intercalaryName,
                };
                targetDate = new CalendarDate(targetDateData, calendar);
                const afterMonthName = calendar.months[afterMonthIndex]?.name || 'Unknown';
                const yearDisplay = this.formatYear(this.viewDate.year);
                ui.notifications?.info(`Date set to ${intercalaryName} (intercalary day after ${afterMonthName} ${yearDisplay})`);
            }
            else {
                // Handle regular day selection
                const day = parseInt(target.dataset.day || '0');
                if (day < 1)
                    return;
                const targetDateData = {
                    year: this.viewDate.year,
                    month: this.viewDate.month,
                    day: day,
                    weekday: engine.calculateWeekday(this.viewDate.year, this.viewDate.month, day),
                    time: currentDate?.time || { hour: 0, minute: 0, second: 0 },
                };
                const calendar = engine.getCalendar();
                targetDate = new CalendarDate(targetDateData, calendar);
                const monthName = calendar.months[targetDate.month - 1]?.name || 'Unknown';
                const dayWithSuffix = this.addOrdinalSuffix(targetDate.day);
                const yearDisplay = this.formatYear(targetDate.year);
                ui.notifications?.info(`Date set to ${dayWithSuffix} of ${monthName}, ${yearDisplay}`);
            }
            // Set the target date
            await manager.setCurrentDate(targetDate);
            // Update view date to selected date
            this.viewDate = targetDate;
            this.render();
        }
        catch (error) {
            Logger.error('Failed to set date', error);
            ui.notifications?.error('Failed to set date');
        }
    }
    /**
     * Show information about a specific date without setting it
     */
    showDateInfo(target) {
        const manager = game.seasonsStars?.manager;
        const engine = manager?.getActiveEngine();
        if (!manager || !engine)
            return;
        try {
            // Check if this is an intercalary day
            const calendarDay = target.closest('.calendar-day');
            const isIntercalary = calendarDay?.classList.contains('intercalary');
            const calendar = engine.getCalendar();
            let dateInfo = '';
            if (isIntercalary) {
                // Handle intercalary day information
                const intercalaryName = target.dataset.day;
                if (!intercalaryName)
                    return;
                const intercalaryDef = calendar.intercalary?.find(i => i.name === intercalaryName);
                const afterMonthName = intercalaryDef?.after || 'Unknown';
                const yearDisplay = this.formatYear(this.viewDate.year);
                dateInfo = `${intercalaryName} (intercalary day after ${afterMonthName}, ${yearDisplay})`;
                if (intercalaryDef?.description) {
                    dateInfo += `\n${intercalaryDef.description}`;
                }
            }
            else {
                // Handle regular day information
                const day = parseInt(target.dataset.day || '0');
                if (day < 1)
                    return;
                const monthName = calendar.months[this.viewDate.month - 1]?.name || 'Unknown';
                const monthDesc = calendar.months[this.viewDate.month - 1]?.description;
                const dayWithSuffix = this.addOrdinalSuffix(day);
                const yearDisplay = this.formatYear(this.viewDate.year);
                dateInfo = `${dayWithSuffix} of ${monthName}, ${yearDisplay}`;
                if (monthDesc) {
                    dateInfo += `\n${monthDesc}`;
                }
            }
            // Show as notification
            ui.notifications?.info(dateInfo);
        }
        catch (error) {
            Logger.error('Failed to show date info', error);
            ui.notifications?.warn('Failed to load date information');
        }
    }
    /**
     * Go to current date
     */
    async _onGoToToday(event, _target) {
        event.preventDefault();
        const manager = game.seasonsStars?.manager;
        if (!manager)
            return;
        const currentDate = manager.getCurrentDate();
        if (currentDate) {
            this.viewDate = currentDate;
            this.render();
        }
    }
    /**
     * Set year via input dialog
     */
    async _onSetYear(event, _target) {
        event.preventDefault();
        const engine = game.seasonsStars?.manager?.getActiveEngine();
        if (!engine)
            return;
        // Create a simple input dialog
        const currentYear = this.viewDate.year;
        const newYear = await new Promise(resolve => {
            new Dialog({
                title: 'Set Year',
                content: `
          <form>
            <div class="form-group">
              <label>Enter Year:</label>
              <input type="number" name="year" value="${currentYear}" min="1" max="99999" step="1" autofocus />
            </div>
          </form>
        `,
                buttons: {
                    ok: {
                        icon: '<i class="fas fa-check"></i>',
                        label: 'Set Year',
                        callback: (html) => {
                            const yearInput = html.find('input[name="year"]').val();
                            const year = parseInt(yearInput);
                            if (!isNaN(year) && year > 0) {
                                resolve(year);
                            }
                            else {
                                ui.notifications?.error('Please enter a valid year');
                                resolve(null);
                            }
                        },
                    },
                    cancel: {
                        icon: '<i class="fas fa-times"></i>',
                        label: 'Cancel',
                        callback: () => resolve(null),
                    },
                },
                default: 'ok',
            }).render(true);
        });
        if (newYear !== null) {
            const viewDateData = this.viewDate.toObject
                ? this.viewDate.toObject()
                : this.viewDate;
            this.viewDate = { ...viewDateData, year: newYear };
            this.render();
        }
    }
    /**
     * Create a new note for the selected date
     */
    async _onCreateNote(event, target) {
        event.preventDefault();
        event.stopPropagation();
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            ui.notifications?.error('Notes system not available');
            return;
        }
        // Check permissions
        if (!this.canCreateNote()) {
            ui.notifications?.error("You don't have permission to create notes");
            return;
        }
        // Get the date from the clicked element
        const dayElement = target.closest('.calendar-day');
        if (!dayElement)
            return;
        const day = parseInt(dayElement.getAttribute('data-day') || '0');
        if (!day)
            return;
        const targetDateData = {
            year: this.viewDate.year,
            month: this.viewDate.month,
            day: day,
            weekday: 0, // Will be calculated by the engine
            time: { hour: 0, minute: 0, second: 0 },
        };
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar();
        if (!calendar)
            return;
        const targetDate = new CalendarDate(targetDateData, calendar);
        // Show note creation dialog
        const noteData = await this.showCreateNoteDialog(targetDate);
        if (!noteData)
            return;
        try {
            const note = await notesManager.createNote(noteData);
            ui.notifications?.info(`Created note: ${noteData.title}`);
            // Refresh the calendar to show the new note indicator
            this.render();
            // Emit hook for other modules
            Hooks.callAll('seasons-stars:noteCreated', note);
        }
        catch (error) {
            Logger.error('Failed to create note', error);
            ui.notifications?.error('Failed to create note');
        }
    }
    /**
     * Show note creation dialog with enhanced category and tag support
     */
    async showCreateNoteDialog(date) {
        const categories = game.seasonsStars?.categories;
        if (!categories) {
            ui.notifications?.error('Note categories system not available');
            return null;
        }
        return new Promise(resolve => {
            // Ensure we have valid date values
            const safeDate = {
                year: date.year || this.viewDate.year || 2024,
                month: date.month || this.viewDate.month || 1,
                day: date.day || 1,
            };
            // Format date using calendar system
            const manager = game.seasonsStars?.manager;
            const activeCalendar = manager?.getActiveCalendar();
            let dateDisplayStr = `${safeDate.year}-${safeDate.month.toString().padStart(2, '0')}-${safeDate.day.toString().padStart(2, '0')}`;
            let calendarInfo = '';
            if (activeCalendar) {
                const monthName = activeCalendar.months[safeDate.month - 1]?.name || `Month ${safeDate.month}`;
                const yearPrefix = activeCalendar.year?.prefix || '';
                const yearSuffix = activeCalendar.year?.suffix || '';
                dateDisplayStr = `${safeDate.day} ${monthName}, ${yearPrefix}${safeDate.year}${yearSuffix}`;
                calendarInfo = `<div style="text-align: center; margin-bottom: 16px; padding: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; font-weight: 600; color: var(--color-text-dark-primary);">${dateDisplayStr}</div>`;
            }
            // Build category options from the categories system
            const availableCategories = categories.getCategories();
            const categoryOptions = availableCategories
                .map(cat => `<option value="${cat.id}">${cat.name}</option>`)
                .join('');
            // Get predefined tags for suggestions
            const predefinedTags = categories.getPredefinedTags();
            const tagSuggestions = predefinedTags
                .map(tag => `<span class="tag-suggestion" data-tag="${tag}">${tag}</span>`)
                .join(' ');
            // Get existing tags from notes for autocompletion
            const notesManager = game.seasonsStars?.notes;
            const existingTags = new Set();
            if (notesManager && notesManager.storage) {
                try {
                    // Check if getAllNotes method exists and is callable
                    if (typeof notesManager.storage.getAllNotes === 'function') {
                        const allNotes = notesManager.storage.getAllNotes() || [];
                        allNotes.forEach(note => {
                            const noteTags = note.flags?.['seasons-and-stars']?.tags || [];
                            noteTags.forEach((tag) => existingTags.add(tag));
                        });
                    }
                    else {
                        // Fallback: try to get notes from game.journal if storage method unavailable
                        if (game.journal) {
                            for (const entry of game.journal.values()) {
                                if (entry.flags?.['seasons-and-stars']?.calendarNote === true) {
                                    const noteTags = entry.flags?.['seasons-and-stars']?.tags || [];
                                    noteTags.forEach((tag) => existingTags.add(tag));
                                }
                            }
                        }
                    }
                }
                catch (error) {
                    // Silent fallback - just use predefined tags if existing tags can't be loaded
                    Logger.debug('Could not load existing tags for autocompletion, using predefined tags only', error);
                }
            }
            // Combine predefined and existing tags for autocompletion
            const allAvailableTags = Array.from(new Set([...predefinedTags, ...existingTags]));
            new Dialog({
                title: `Create Note`,
                content: `
          <style>
            .seasons-stars-note-form {
              max-width: 600px;
              font-family: var(--font-primary);
              overflow: visible;
            }
            .seasons-stars-note-form .form-group {
              margin-bottom: 16px;
            }
            .seasons-stars-note-form .form-row {
              display: flex;
              gap: 12px;
            }
            .seasons-stars-note-form .form-group.half-width {
              flex: 1;
            }
            .seasons-stars-note-form label {
              display: block;
              margin-bottom: 4px;
              font-weight: 600;
              color: var(--color-text-dark-primary);
              font-size: 13px;
            }
            .seasons-stars-note-form input[type="text"],
            .seasons-stars-note-form textarea,
            .seasons-stars-note-form select {
              width: 100%;
              padding: 8px 10px;
              border: 1px solid var(--color-border-dark);
              border-radius: 4px;
              background: var(--color-bg-option);
              color: var(--color-text-dark-primary);
              font-size: 13px;
              transition: border-color 0.2s ease, box-shadow 0.2s ease;
              line-height: 1.4;
              min-height: 36px;
            }
            .seasons-stars-note-form select {
              padding: 6px 10px;
              height: auto;
              min-height: 34px;
            }
            .seasons-stars-note-form input[type="text"]:focus,
            .seasons-stars-note-form textarea:focus,
            .seasons-stars-note-form select:focus {
              border-color: var(--color-border-highlight);
              box-shadow: 0 0 0 2px rgba(var(--color-shadow-highlight), 0.2);
              outline: none;
            }
            .seasons-stars-note-form textarea {
              resize: vertical;
              min-height: 80px;
            }
            .seasons-stars-note-form .tag-suggestions {
              margin-top: 6px;
              max-height: 80px;
              overflow-y: auto;
              border: 1px solid var(--color-border-light);
              border-radius: 4px;
              padding: 8px;
              background: rgba(0, 0, 0, 0.1);
            }
            .seasons-stars-note-form .tag-suggestions small {
              display: block;
              margin-bottom: 6px;
              color: var(--color-text-dark-secondary);
              font-weight: 600;
              font-size: 11px;
            }
            .seasons-stars-note-form .tag-suggestion {
              display: inline-block;
              background: var(--color-bg-btn);
              border: 1px solid var(--color-border-dark);
              border-radius: 12px;
              padding: 4px 10px;
              margin: 2px 4px 2px 0;
              cursor: pointer;
              font-size: 11px;
              font-weight: 500;
              transition: all 0.2s ease;
              user-select: none;
            }
            .seasons-stars-note-form .tag-suggestion:hover {
              background: var(--color-bg-btn-hover);
              transform: translateY(-1px);
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }
            .seasons-stars-note-form .tag-autocomplete {
              position: relative;
            }
            .seasons-stars-note-form .tag-autocomplete-dropdown {
              position: absolute;
              top: 100%;
              left: 0;
              right: 0;
              background: var(--color-bg-option);
              border: 1px solid var(--color-border-dark);
              border-top: none;
              border-radius: 0 0 4px 4px;
              max-height: 120px;
              overflow-y: auto;
              z-index: 1000;
              display: none;
            }
            .seasons-stars-note-form .tag-autocomplete-item {
              padding: 6px 10px;
              cursor: pointer;
              font-size: 12px;
              border-bottom: 1px solid var(--color-border-light);
              transition: background-color 0.15s ease;
            }
            .seasons-stars-note-form .tag-autocomplete-item:hover,
            .seasons-stars-note-form .tag-autocomplete-item.selected {
              background: var(--color-bg-btn-hover);
            }
            .seasons-stars-note-form .tag-autocomplete-item:last-child {
              border-bottom: none;
            }
            .seasons-stars-note-form .tag-autocomplete-item .tag-match {
              font-weight: 600;
              color: var(--color-text-highlight);
            }
          </style>
          <form class="seasons-stars-note-form">
            ${calendarInfo}
            
            <div class="form-group">
              <label>Title:</label>
              <input type="text" name="title" placeholder="Note title" autofocus />
            </div>
            
            <div class="form-group">
              <label>Content:</label>
              <textarea name="content" rows="4" placeholder="Note content"></textarea>
            </div>
            
            <div class="form-row">
              <div class="form-group half-width">
                <label>Category:</label>
                <select name="category" class="category-select">
                  ${categoryOptions}
                </select>
              </div>
              <div class="form-group half-width">
                <label>
                  <input type="checkbox" name="allDay" checked />
                  All Day Event
                </label>
              </div>
            </div>
            
            <div class="form-group">
              <label>Tags (optional):</label>
              <div class="tag-autocomplete">
                <input type="text" name="tags" placeholder="Enter tags separated by commas" class="tags-input" autocomplete="off" />
                <div class="tag-autocomplete-dropdown"></div>
              </div>
              <div class="tag-suggestions">
                <small>Click to add:</small>
                ${tagSuggestions}
              </div>
            </div>
          </form>
          
          <style>
            .seasons-stars-note-form .form-row {
              display: flex;
              gap: 12px;
            }
            .seasons-stars-note-form .half-width {
              flex: 1;
            }
            .seasons-stars-note-form .category-select {
              width: 100%;
            }
            .seasons-stars-note-form .tags-input {
              width: 100%;
              margin-bottom: 5px;
            }
            .seasons-stars-note-form .tag-suggestions {
              display: flex;
              flex-wrap: wrap;
              gap: 4px;
              align-items: flex-start;
              padding-top: 2px;
            }
            .seasons-stars-note-form input[type="checkbox"] {
              margin-right: 6px;
            }
            .seasons-stars-note-form .category-select {
              appearance: none;
              -webkit-appearance: none;
              -moz-appearance: none;
              background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23666" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
              background-repeat: no-repeat;
              background-position: right 8px center;
              background-size: 12px;
              padding-right: 30px !important;
              vertical-align: top;
            }
            .seasons-stars-note-form .category-select option {
              padding: 4px 8px;
              line-height: 1.4;
              min-height: 20px;
            }
          </style>
        `,
                buttons: {
                    create: {
                        icon: '<i class="fas fa-plus"></i>',
                        label: 'Create Note',
                        callback: (html) => {
                            const form = html.find('form')[0];
                            const formData = new FormData(form);
                            const title = formData.get('title');
                            const content = formData.get('content');
                            const tagsString = formData.get('tags');
                            if (!title?.trim()) {
                                ui.notifications?.error('Note title is required');
                                resolve(null);
                                return;
                            }
                            // Parse tags
                            const tags = categories.parseTagString(tagsString);
                            const { valid: validTags, invalid: invalidTags } = categories.validateTags(tags);
                            if (invalidTags.length > 0) {
                                ui.notifications?.warn(`Some tags are not allowed: ${invalidTags.join(', ')}`);
                            }
                            resolve({
                                title: title.trim(),
                                content: content || '',
                                startDate: date,
                                allDay: formData.has('allDay'),
                                category: formData.get('category') || categories.getDefaultCategory().id,
                                tags: validTags,
                                playerVisible: false, // Default to private
                                recurring: undefined, // No recurring support for now
                            });
                        },
                    },
                    cancel: {
                        icon: '<i class="fas fa-times"></i>',
                        label: 'Cancel',
                        callback: () => resolve(null),
                    },
                },
                default: 'create',
                resizable: true,
                render: (html) => {
                    // Add click handlers for tag suggestions
                    html.find('.tag-suggestion').on('click', function () {
                        const tag = $(this).data('tag');
                        const tagsInput = html.find('input[name="tags"]');
                        const currentTags = tagsInput.val();
                        if (currentTags) {
                            tagsInput.val(currentTags + ', ' + tag);
                        }
                        else {
                            tagsInput.val(tag);
                        }
                        tagsInput.trigger('input'); // Trigger autocompletion update
                    });
                    // Update category select styling based on selection
                    html.find('.category-select').on('change', function () {
                        const selectedCat = categories.getCategory($(this).val());
                        if (selectedCat) {
                            $(this).css('border-left', `4px solid ${selectedCat.color}`);
                        }
                    });
                    // Tag autocompletion functionality
                    const tagsInput = html.find('input[name="tags"]');
                    const autocompleteDropdown = html.find('.tag-autocomplete-dropdown');
                    let selectedIndex = -1;
                    // Smart tag matching function
                    function matchTag(searchTerm, tagToMatch) {
                        const search = searchTerm.toLowerCase();
                        const tag = tagToMatch.toLowerCase();
                        // Direct match
                        if (tag.includes(search)) {
                            const index = tag.indexOf(search);
                            const highlighted = tagToMatch.substring(0, index) +
                                '<span class="tag-match">' +
                                tagToMatch.substring(index, index + search.length) +
                                '</span>' +
                                tagToMatch.substring(index + search.length);
                            return { matches: true, highlighted };
                        }
                        // Colon-separated tag matching
                        if (tag.includes(':')) {
                            const parts = tag.split(':');
                            for (const part of parts) {
                                if (part.trim().includes(search)) {
                                    const partIndex = part.trim().indexOf(search);
                                    const highlighted = tagToMatch.replace(part, part.substring(0, partIndex) +
                                        '<span class="tag-match">' +
                                        part.substring(partIndex, partIndex + search.length) +
                                        '</span>' +
                                        part.substring(partIndex + search.length));
                                    return { matches: true, highlighted };
                                }
                            }
                        }
                        return { matches: false, highlighted: tagToMatch };
                    }
                    // Function to get current typing context
                    function getCurrentTypingContext() {
                        const inputElement = tagsInput[0];
                        const cursorPos = inputElement.selectionStart || 0;
                        const fullText = tagsInput.val();
                        const beforeCursor = fullText.substring(0, cursorPos);
                        const afterCursor = fullText.substring(cursorPos);
                        // Find the current tag being typed
                        const lastCommaIndex = beforeCursor.lastIndexOf(',');
                        const currentTag = beforeCursor.substring(lastCommaIndex + 1).trim();
                        return { beforeCursor, afterCursor, currentTag };
                    }
                    // Function to show autocomplete suggestions
                    function showAutocomplete(searchTerm) {
                        if (searchTerm.length < 1) {
                            autocompleteDropdown.hide();
                            return;
                        }
                        const matches = [];
                        allAvailableTags.forEach(tag => {
                            const result = matchTag(searchTerm, tag);
                            if (result.matches) {
                                matches.push({ tag, highlighted: result.highlighted });
                            }
                        });
                        if (matches.length === 0) {
                            autocompleteDropdown.hide();
                            return;
                        }
                        // Limit to top 8 matches
                        const topMatches = matches.slice(0, 8);
                        const dropdownHtml = topMatches
                            .map((match, index) => `<div class="tag-autocomplete-item" data-tag="${match.tag}" data-index="${index}">${match.highlighted}</div>`)
                            .join('');
                        autocompleteDropdown.html(dropdownHtml).show();
                        selectedIndex = -1;
                    }
                    // Function to insert selected tag
                    function insertTag(tagToInsert) {
                        const context = getCurrentTypingContext();
                        const beforeCurrentTag = context.beforeCursor.substring(0, context.beforeCursor.lastIndexOf(',') + 1);
                        const newValue = (beforeCurrentTag ? beforeCurrentTag + ' ' : '') +
                            tagToInsert +
                            (context.afterCursor.startsWith(',') ? '' : ', ') +
                            context.afterCursor;
                        tagsInput.val(newValue.replace(/,\\s*$/, '')); // Remove trailing comma
                        autocompleteDropdown.hide();
                        tagsInput.focus();
                    }
                    // Input event for autocompletion
                    tagsInput.on('input', function () {
                        const context = getCurrentTypingContext();
                        showAutocomplete(context.currentTag);
                    });
                    // Keyboard navigation
                    tagsInput.on('keydown', function (e) {
                        const dropdown = autocompleteDropdown;
                        const items = dropdown.find('.tag-autocomplete-item');
                        if (!dropdown.is(':visible') || items.length === 0)
                            return;
                        switch (e.keyCode) {
                            case 38: // Up arrow
                                e.preventDefault();
                                selectedIndex = selectedIndex <= 0 ? items.length - 1 : selectedIndex - 1;
                                break;
                            case 40: // Down arrow
                                e.preventDefault();
                                selectedIndex = selectedIndex >= items.length - 1 ? 0 : selectedIndex + 1;
                                break;
                            case 13: // Enter
                                e.preventDefault();
                                if (selectedIndex >= 0) {
                                    const selectedTag = items.eq(selectedIndex).data('tag');
                                    insertTag(selectedTag);
                                }
                                return;
                            case 27: // Escape
                                dropdown.hide();
                                return;
                        }
                        // Update visual selection
                        items.removeClass('selected');
                        if (selectedIndex >= 0) {
                            items.eq(selectedIndex).addClass('selected');
                        }
                    });
                    // Click handlers for autocomplete items
                    autocompleteDropdown.on('click', '.tag-autocomplete-item', function () {
                        const tagToInsert = $(this).data('tag');
                        insertTag(tagToInsert);
                    });
                    // Hide dropdown when clicking outside
                    $(document).on('click', function (e) {
                        if (!$(e.target).closest('.tag-autocomplete').length) {
                            autocompleteDropdown.hide();
                        }
                    });
                    // Trigger initial styling
                    html.find('.category-select').trigger('change');
                },
            }).render(true);
        });
    }
    /**
     * View/edit notes for a specific date
     */
    async _onViewNotes(event, target) {
        event.preventDefault();
        event.stopPropagation();
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            ui.notifications?.error('Notes system not available');
            return;
        }
        // Get the date from the clicked element
        const dayElement = target.closest('.calendar-day');
        if (!dayElement)
            return;
        const day = parseInt(dayElement.getAttribute('data-day') || '0');
        if (!day)
            return;
        const targetDateData = {
            year: this.viewDate.year,
            month: this.viewDate.month,
            day: day,
            weekday: 0, // Will be calculated by the engine
            time: { hour: 0, minute: 0, second: 0 },
        };
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar();
        if (!calendar)
            return;
        const targetDate = new CalendarDate(targetDateData, calendar);
        try {
            // Get notes for this date
            const notes = notesManager.storage?.findNotesByDateSync?.(targetDate) || [];
            if (notes.length === 0) {
                ui.notifications?.info('No notes found for this date');
                return;
            }
            if (notes.length === 1) {
                // Single note - open directly
                const note = notes[0];
                note.sheet?.render(true);
            }
            else {
                // Multiple notes - show selection dialog
                await this.showNotesSelectionDialog(notes, targetDate);
            }
        }
        catch (error) {
            Logger.error('Failed to view notes', error);
            ui.notifications?.error('Failed to view notes');
        }
    }
    /**
     * Show selection dialog for multiple notes on the same date
     */
    async showNotesSelectionDialog(notes, date) {
        const manager = game.seasonsStars?.manager;
        const activeCalendar = manager?.getActiveCalendar();
        let dateDisplayStr = `${date.year}-${date.month.toString().padStart(2, '0')}-${date.day.toString().padStart(2, '0')}`;
        if (activeCalendar) {
            const monthName = activeCalendar.months[date.month - 1]?.name || `Month ${date.month}`;
            const yearPrefix = activeCalendar.year?.prefix || '';
            const yearSuffix = activeCalendar.year?.suffix || '';
            dateDisplayStr = `${date.day} ${monthName}, ${yearPrefix}${date.year}${yearSuffix}`;
        }
        const notesList = notes
            .map((note, index) => {
            const title = note.name || 'Untitled Note';
            const category = note.flags?.['seasons-and-stars']?.category || 'general';
            const preview = note.pages?.contents?.[0]?.text?.content?.substring(0, 100) || 'No content';
            const cleanPreview = preview.stripScripts().trim();
            return `
        <div class="note-item" data-note-id="${note.id}" data-index="${index}">
          <div class="note-header">
            <strong>${title}</strong>
            <span class="note-category">${category}</span>
          </div>
          <div class="note-preview">${cleanPreview}${cleanPreview.length >= 100 ? '...' : ''}</div>
        </div>
      `;
        })
            .join('');
        return new Promise(resolve => {
            new Dialog({
                title: `Notes for ${dateDisplayStr}`,
                content: `
          <style>
            .notes-selection {
              max-width: 500px;
            }
            .note-item {
              border: 1px solid var(--color-border-light);
              border-radius: 4px;
              padding: 10px;
              margin-bottom: 8px;
              cursor: pointer;
              transition: background-color 0.2s ease;
              background: rgba(255, 255, 255, 0.02);
            }
            .note-item:hover {
              background: rgba(255, 255, 255, 0.08);
              border-color: var(--color-border-highlight);
            }
            .note-item:last-child {
              margin-bottom: 0;
            }
            .note-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 4px;
            }
            .note-category {
              font-size: 11px;
              background: var(--color-bg-btn);
              padding: 2px 6px;
              border-radius: 3px;
              color: var(--color-text-light-heading);
            }
            .note-preview {
              font-size: 12px;
              color: var(--color-text-dark-secondary);
              font-style: italic;
            }
          </style>
          <div class="notes-selection">
            <p>Select a note to view/edit:</p>
            ${notesList}
          </div>
        `,
                buttons: {
                    cancel: {
                        icon: '<i class="fas fa-times"></i>',
                        label: 'Cancel',
                        callback: () => resolve(),
                    },
                },
                default: 'cancel',
                render: (html) => {
                    // Add click handlers for note items
                    html.find('.note-item').on('click', function () {
                        const noteIndex = parseInt($(this).data('index'));
                        const note = notes[noteIndex];
                        if (note && note.sheet) {
                            note.sheet.render(true);
                        }
                        resolve();
                    });
                },
            }).render(true);
        });
    }
    /**
     * Attach event listeners
     */
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        // Register this as the active instance
        CalendarGridWidget.activeInstance = this;
    }
    /**
     * Handle closing the widget
     */
    async close(options = {}) {
        // Clear active instance if this is it
        if (CalendarGridWidget.activeInstance === this) {
            CalendarGridWidget.activeInstance = null;
        }
        return super.close(options);
    }
    /**
     * Handle Foundry hooks for real-time updates
     */
    static registerHooks() {
        // Update widget when time changes
        Hooks.on('seasons-stars:dateChanged', () => {
            if (CalendarGridWidget.activeInstance?.rendered) {
                CalendarGridWidget.activeInstance.render();
            }
        });
        // Update widget when calendar changes
        Hooks.on('seasons-stars:calendarChanged', () => {
            if (CalendarGridWidget.activeInstance?.rendered) {
                // Reset to current date when calendar changes
                const manager = game.seasonsStars?.manager;
                if (manager) {
                    const currentDate = manager.getCurrentDate();
                    if (currentDate) {
                        CalendarGridWidget.activeInstance.viewDate = currentDate;
                    }
                }
                CalendarGridWidget.activeInstance.render();
            }
        });
    }
    /**
     * Show the widget
     */
    static show(initialDate) {
        if (CalendarGridWidget.activeInstance) {
            if (!CalendarGridWidget.activeInstance.rendered) {
                CalendarGridWidget.activeInstance.render(true);
            }
        }
        else {
            new CalendarGridWidget(initialDate).render(true);
        }
    }
    /**
     * Toggle widget visibility
     */
    static toggle(initialDate) {
        if (CalendarGridWidget.activeInstance) {
            if (CalendarGridWidget.activeInstance.rendered) {
                CalendarGridWidget.activeInstance.close();
            }
            else {
                CalendarGridWidget.activeInstance.render(true);
            }
        }
        else {
            new CalendarGridWidget(initialDate).render(true);
        }
    }
    /**
     * Hide the widget
     */
    static hide() {
        if (CalendarGridWidget.activeInstance?.rendered) {
            CalendarGridWidget.activeInstance.close();
        }
    }
    /**
     * Get the current widget instance
     */
    static getInstance() {
        return CalendarGridWidget.activeInstance;
    }
    /**
     * Add a sidebar button to the grid widget
     * Provides generic API for integration with other modules
     */
    addSidebarButton(name, icon, tooltip, callback) {
        // Check if button already exists
        const existingButton = this.sidebarButtons.find(btn => btn.name === name);
        if (existingButton) {
            Logger.debug(`Button "${name}" already exists in grid widget`);
            return;
        }
        // Add to buttons array
        this.sidebarButtons.push({ name, icon, tooltip, callback });
        Logger.debug(`Added sidebar button "${name}" to grid widget`);
        // If widget is rendered, add button to DOM immediately
        if (this.rendered && this.element) {
            this.renderSidebarButton(name, icon, tooltip, callback);
        }
    }
    /**
     * Render a sidebar button in the grid widget header
     */
    renderSidebarButton(name, icon, tooltip, callback) {
        if (!this.element)
            return;
        const buttonId = `grid-sidebar-btn-${name.toLowerCase().replace(/\s+/g, '-')}`;
        // Don't add if already exists in DOM
        if (this.element.querySelector(`#${buttonId}`)) {
            return;
        }
        // Find window controls area in header
        let windowControls = this.element.querySelector('.window-header .window-controls');
        if (!windowControls) {
            // Try to find window header and add controls area
            const windowHeader = this.element.querySelector('.window-header');
            if (windowHeader) {
                windowControls = document.createElement('div');
                windowControls.className = 'window-controls';
                windowControls.style.cssText = 'display: flex; align-items: center; margin-left: auto;';
                windowHeader.appendChild(windowControls);
            }
            else {
                Logger.warn('No window header found for grid widget sidebar button');
                return;
            }
        }
        // Create button element
        const button = document.createElement('button');
        button.id = buttonId;
        button.className = 'grid-sidebar-button';
        button.title = tooltip;
        button.innerHTML = `<i class="fas ${icon}"></i>`;
        button.style.cssText = `
      background: var(--color-bg-btn, #f0f0f0);
      border: 1px solid var(--color-border-dark, #999);
      border-radius: 3px;
      padding: 4px 6px;
      margin-left: 4px;
      cursor: pointer;
      font-size: 12px;
      color: var(--color-text-primary, #000);
      transition: background-color 0.15s ease;
    `;
        // Add click handler
        button.addEventListener('click', event => {
            event.preventDefault();
            event.stopPropagation();
            try {
                callback();
            }
            catch (error) {
                Logger.error(`Error in grid widget sidebar button "${name}"`, error);
            }
        });
        // Add hover effects
        button.addEventListener('mouseenter', () => {
            button.style.background = 'var(--color-bg-btn-hover, #e0e0e0)';
        });
        button.addEventListener('mouseleave', () => {
            button.style.background = 'var(--color-bg-btn, #f0f0f0)';
        });
        windowControls.appendChild(button);
        Logger.debug(`Rendered sidebar button "${name}" in grid widget header`);
    }
    /**
     * Render all existing sidebar buttons (called after widget render)
     */
    renderExistingSidebarButtons() {
        this.sidebarButtons.forEach(button => {
            this.renderSidebarButton(button.name, button.icon, button.tooltip, button.callback);
        });
    }
    /**
     * Switch to main widget
     */
    async _onSwitchToMain(event, _target) {
        event.preventDefault();
        Logger.debug('Switching from grid widget to main widget');
        try {
            // Close current widget
            this.close();
            // Open main widget
            CalendarWidgetManager.showWidget('main');
        }
        catch (error) {
            Logger.error('Failed to switch to main widget', error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Switch to mini widget
     */
    async _onSwitchToMini(event, _target) {
        event.preventDefault();
        Logger.debug('Switching from grid widget to mini widget');
        try {
            // Close current widget
            this.close();
            // Open mini widget
            CalendarWidgetManager.showWidget('mini');
        }
        catch (error) {
            Logger.error('Failed to switch to mini widget', error instanceof Error ? error : new Error(String(error)));
        }
    }
}
CalendarGridWidget.activeInstance = null;
CalendarGridWidget.DEFAULT_OPTIONS = {
    id: 'seasons-stars-grid-widget',
    classes: ['seasons-stars', 'calendar-grid-widget'],
    tag: 'div',
    window: {
        frame: true,
        positioned: true,
        title: 'SEASONS_STARS.calendar.monthly_view',
        icon: 'fa-solid fa-calendar',
        minimizable: false,
        resizable: false,
    },
    position: {
        width: 400,
        height: 'auto',
    },
    actions: {
        previousMonth: CalendarGridWidget.prototype._onPreviousMonth,
        nextMonth: CalendarGridWidget.prototype._onNextMonth,
        previousYear: CalendarGridWidget.prototype._onPreviousYear,
        nextYear: CalendarGridWidget.prototype._onNextYear,
        selectDate: CalendarGridWidget.prototype._onSelectDate,
        goToToday: CalendarGridWidget.prototype._onGoToToday,
        setYear: CalendarGridWidget.prototype._onSetYear,
        createNote: CalendarGridWidget.prototype._onCreateNote,
        viewNotes: CalendarGridWidget.prototype._onViewNotes,
        switchToMain: CalendarGridWidget.prototype._onSwitchToMain,
        switchToMini: CalendarGridWidget.prototype._onSwitchToMini,
    },
};
CalendarGridWidget.PARTS = {
    main: {
        id: 'main',
        template: 'modules/seasons-and-stars/templates/calendar-grid-widget.hbs',
    },
};

/**
 * Calendar Pack Migration Dialog for Seasons & Stars
 * Informs GMs that calendars have been moved to separate calendar packs
 */
class CalendarDeprecationDialog extends foundry.applications.api.HandlebarsApplicationMixin(foundry.applications.api.ApplicationV2) {
    /**
     * Show the calendar pack information dialog if it hasn't been dismissed by the GM
     */
    static async showWarningIfNeeded() {
        try {
            // Only show to GMs
            if (!game.user?.isGM) {
                return;
            }
            // Check if dialog was already shown and dismissed
            const warningShown = game.settings?.get('seasons-and-stars', 'calendarDeprecationWarningShown');
            if (warningShown) {
                Logger.debug('Calendar pack information dialog already dismissed, skipping');
                return;
            }
            Logger.info('Showing calendar pack information dialog to GM');
            new CalendarDeprecationDialog().render(true);
        }
        catch (error) {
            Logger.error('Failed to show calendar pack information dialog', error instanceof Error ? error : new Error(String(error)));
        }
    }
    async _prepareContext(_options) {
        return {
            isGM: game.user?.isGM,
            moduleName: 'Seasons & Stars',
        };
    }
    _attachPartListeners(partId, htmlElement, options) {
        super._attachPartListeners(partId, htmlElement, options);
        // Add click handler to the dismiss button
        htmlElement.querySelector('.dismiss-button')?.addEventListener('click', async () => {
            try {
                // Check if "don't remind" is checked
                const checkbox = htmlElement.querySelector('input[name="dontRemind"]');
                const dontRemind = checkbox?.checked === true;
                if (dontRemind) {
                    // Mark the dialog as shown so it won't appear again
                    await game.settings?.set('seasons-and-stars', 'calendarDeprecationWarningShown', true);
                    Logger.info('Calendar pack information dialog dismissed by GM');
                }
                // Close this dialog
                await this.close();
            }
            catch (error) {
                Logger.error('Failed to save calendar pack information dialog preference', error instanceof Error ? error : new Error(String(error)));
            }
        });
    }
}
CalendarDeprecationDialog.DEFAULT_OPTIONS = {
    tag: 'div',
    window: {
        frame: true,
        positioned: true,
        title: 'Seasons & Stars - Calendar Packs Available',
        icon: 'fas fa-info-circle',
        minimizable: false,
        resizable: false,
    },
    position: {
        width: 500,
        height: 650,
    },
};
CalendarDeprecationDialog.PARTS = {
    content: {
        id: 'content',
        template: 'modules/seasons-and-stars/templates/calendar-deprecation-warning.hbs',
    },
};

/**
 * Type guard functions for Seasons & Stars interfaces
 */
function isCalendarManager(obj) {
    return !!(obj &&
        typeof obj === 'object' &&
        'getCurrentDate' in obj &&
        'getActiveCalendar' in obj);
}

/**
 * Scene controls integration for Seasons & Stars
 */
class SeasonsStarsSceneControls {
    /**
     * Register scene controls
     */
    static registerControls() {
        Logger.debug('SeasonsStarsSceneControls.registerControls() called - registering getSceneControlButtons hook');
        Hooks.on('getSceneControlButtons', (controls) => {
            Logger.debug('getSceneControlButtons hook fired', {
                userExists: !!game.user,
                isGM: game.user?.isGM,
                controlsType: typeof controls,
                controlsKeys: Object.keys(controls),
                notesExists: !!controls.notes,
                notesToolsExists: !!controls.notes?.tools,
                notesToolsType: typeof controls.notes?.tools,
                notesToolsKeys: controls.notes?.tools ? Object.keys(controls.notes.tools) : null,
            });
            if (!game.user?.isGM) {
                Logger.debug('User is not GM, skipping scene control registration');
                return;
            }
            // Access notes controls directly (controls is an object, not array)
            if (controls.notes?.tools) {
                Logger.debug('Adding S&S scene control to notes.tools');
                // Use SmallTime's pattern of direct property assignment
                controls.notes.tools['seasons-stars-widget'] = {
                    name: 'seasons-stars-widget',
                    title: 'SEASONS_STARS.calendar.toggle_calendar',
                    icon: 'fas fa-calendar-alt',
                    onChange: () => SeasonsStarsSceneControls.toggleDefaultWidget(),
                    button: true,
                };
                Logger.debug('Added S&S scene control button, updated tools:', Object.keys(controls.notes.tools));
            }
            else {
                Logger.warn('Notes controls not available for scene button', {
                    notesExists: !!controls.notes,
                    notesToolsExists: !!controls.notes?.tools,
                    fullControlsStructure: controls,
                });
            }
        });
        // Update button state based on widget manager state
        Hooks.on('seasons-stars:widgetStateChanged', () => {
            const hasVisibleWidget = CalendarWidgetManager.getVisibleWidgets().length > 0;
            SeasonsStarsSceneControls.updateControlState(hasVisibleWidget);
        });
    }
    /**
     * Show the default widget based on user settings
     */
    static showDefaultWidget() {
        try {
            const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
            Logger.debug('Showing default widget', { defaultWidget });
            switch (defaultWidget) {
                case 'mini':
                    CalendarWidgetManager.showWidget('mini');
                    break;
                case 'grid':
                    CalendarWidgetManager.showWidget('grid');
                    break;
                case 'main':
                default:
                    CalendarWidgetManager.showWidget('main');
                    break;
            }
        }
        catch (error) {
            Logger.error('Failed to show default widget', error instanceof Error ? error : new Error(String(error)));
            // Fallback to main widget
            CalendarWidgetManager.showWidget('main');
        }
    }
    /**
     * Hide the default widget based on user settings
     */
    static hideDefaultWidget() {
        try {
            const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
            Logger.debug('Hiding default widget', { defaultWidget });
            switch (defaultWidget) {
                case 'mini':
                    CalendarWidgetManager.hideWidget('mini');
                    break;
                case 'grid':
                    CalendarWidgetManager.hideWidget('grid');
                    break;
                case 'main':
                default:
                    CalendarWidgetManager.hideWidget('main');
                    break;
            }
        }
        catch (error) {
            Logger.error('Failed to hide default widget', error instanceof Error ? error : new Error(String(error)));
            // Fallback to main widget
            CalendarWidgetManager.hideWidget('main');
        }
    }
    /**
     * Toggle the default widget based on user settings
     */
    static toggleDefaultWidget() {
        try {
            const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
            Logger.debug('Scene control toggling default widget', { defaultWidget });
            switch (defaultWidget) {
                case 'mini':
                    CalendarWidgetManager.toggleWidget('mini');
                    break;
                case 'grid':
                    CalendarWidgetManager.toggleWidget('grid');
                    break;
                case 'main':
                default:
                    CalendarWidgetManager.toggleWidget('main');
                    break;
            }
        }
        catch (error) {
            Logger.error('Failed to toggle default widget from scene control', error instanceof Error ? error : new Error(String(error)));
            // Fallback to main widget
            CalendarWidgetManager.toggleWidget('main');
        }
    }
    /**
     * Update the control button state
     */
    static updateControlState(active) {
        // Look for our tool button in the scene controls
        const control = document.querySelector('[data-tool="seasons-stars-widget"]');
        if (control) {
            control.classList.toggle('active', active);
        }
    }
    /**
     * Add macro support for calendar widget
     */
    static registerMacros() {
        // Extend the existing SeasonsStars object with macro functions
        window.SeasonsStars ?? (window.SeasonsStars = {});
        // Add macro functions to the existing object
        Object.assign(window.SeasonsStars, {
            // Widget controls - respect default widget setting
            showWidget: () => SeasonsStarsSceneControls.showDefaultWidget(),
            hideWidget: () => SeasonsStarsSceneControls.hideDefaultWidget(),
            toggleWidget: () => SeasonsStarsSceneControls.toggleDefaultWidget(),
            // Specific widget controls (for advanced users who want to override default)
            showMainWidget: () => {
                void CalendarWidgetManager.showWidget('main');
            },
            hideMainWidget: () => {
                void CalendarWidgetManager.hideWidget('main');
            },
            toggleMainWidget: () => {
                void CalendarWidgetManager.toggleWidget('main');
            },
            showMiniWidget: () => {
                void CalendarWidgetManager.showWidget('mini');
            },
            hideMiniWidget: () => {
                void CalendarWidgetManager.hideWidget('mini');
            },
            toggleMiniWidget: () => {
                void CalendarWidgetManager.toggleWidget('mini');
            },
            showGridWidget: () => {
                void CalendarWidgetManager.showWidget('grid');
            },
            hideGridWidget: () => {
                void CalendarWidgetManager.hideWidget('grid');
            },
            toggleGridWidget: () => {
                void CalendarWidgetManager.toggleWidget('grid');
            },
            // Mini widget positioning (legacy support)
            positionMiniAboveSmallTime: () => {
                const miniWidget = CalendarWidgetManager.getWidgetInstance('mini');
                miniWidget?.positionAboveSmallTime?.();
            },
            positionMiniBelowSmallTime: () => {
                const miniWidget = CalendarWidgetManager.getWidgetInstance('mini');
                miniWidget?.positionBelowSmallTime?.();
            },
            positionMiniBesideSmallTime: () => {
                const miniWidget = CalendarWidgetManager.getWidgetInstance('mini');
                miniWidget?.positionBesideSmallTime?.();
            },
            // Time advancement functions for macros
            advanceMinutes: async (minutes) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceMinutes(minutes);
            },
            advanceHours: async (hours) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceHours(hours);
            },
            advanceDays: async (days) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceDays(days);
            },
            advanceWeeks: async (weeks) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceWeeks(weeks);
            },
            advanceMonths: async (months) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceMonths(months);
            },
            advanceYears: async (years) => {
                const manager = game.seasonsStars?.manager;
                if (isCalendarManager(manager))
                    await manager.advanceYears(years);
            },
        });
        Logger.debug('Macro functions registered');
    }
}

/**
 * Keyboard shortcuts for Seasons & Stars
 */
class SeasonsStarsKeybindings {
    /**
     * Register all keyboard shortcuts
     */
    static registerKeybindings() {
        if (!game.keybindings) {
            Logger.warn('Keybindings API not available');
            return;
        }
        Logger.info('Registering keyboard shortcuts');
        // Alt+S - Toggle default widget
        game.keybindings.register('seasons-and-stars', 'toggleDefaultWidget', {
            name: 'SEASONS_STARS.keybindings.toggle_default_widget',
            hint: 'SEASONS_STARS.keybindings.toggle_default_widget_hint',
            editable: [
                {
                    key: 'KeyS',
                    modifiers: ['Alt'],
                },
            ],
            onDown: () => {
                Logger.debug('Default widget toggle shortcut pressed');
                SeasonsStarsKeybindings.toggleDefaultWidget();
                return true;
            },
            restricted: false, // Available to all users
            precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL,
        });
        // Alt+Shift+S - Toggle mini widget specifically
        game.keybindings.register('seasons-and-stars', 'toggleMiniWidget', {
            name: 'SEASONS_STARS.keybindings.toggle_mini_widget',
            hint: 'SEASONS_STARS.keybindings.toggle_mini_widget_hint',
            editable: [
                {
                    key: 'KeyS',
                    modifiers: ['Alt', 'Shift'],
                },
            ],
            onDown: () => {
                Logger.debug('Mini widget toggle shortcut pressed');
                CalendarMiniWidget.toggle();
                return true;
            },
            restricted: false,
            precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL,
        });
        // Alt+Ctrl+S - Toggle grid widget specifically
        game.keybindings.register('seasons-and-stars', 'toggleGridWidget', {
            name: 'SEASONS_STARS.keybindings.toggle_grid_widget',
            hint: 'SEASONS_STARS.keybindings.toggle_grid_widget_hint',
            editable: [
                {
                    key: 'KeyS',
                    modifiers: ['Alt', 'Control'],
                },
            ],
            onDown: () => {
                Logger.debug('Grid widget toggle shortcut pressed');
                CalendarGridWidget.toggle();
                return true;
            },
            restricted: false,
            precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL,
        });
        // Alt+Shift+Ctrl+S - Toggle main widget (future calendar management interface)
        game.keybindings.register('seasons-and-stars', 'toggleMainWidget', {
            name: 'SEASONS_STARS.keybindings.toggle_main_widget',
            hint: 'SEASONS_STARS.keybindings.toggle_main_widget_hint',
            editable: [
                {
                    key: 'KeyS',
                    modifiers: ['Alt', 'Shift', 'Control'],
                },
            ],
            onDown: () => {
                Logger.debug('Main widget toggle shortcut pressed');
                CalendarWidget.toggle();
                return true;
            },
            restricted: false,
            precedence: CONST.KEYBINDING_PRECEDENCE.NORMAL,
        });
        Logger.info('Keyboard shortcuts registered successfully');
    }
    /**
     * Toggle the default widget based on user settings
     */
    static toggleDefaultWidget() {
        try {
            const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
            Logger.debug('Toggling default widget', { defaultWidget });
            switch (defaultWidget) {
                case 'mini':
                    CalendarMiniWidget.toggle();
                    break;
                case 'grid':
                    CalendarGridWidget.toggle();
                    break;
                case 'main':
                default:
                    CalendarWidget.toggle();
                    break;
            }
        }
        catch (error) {
            Logger.error('Failed to toggle default widget', error instanceof Error ? error : new Error(String(error)));
            // Fallback to main widget
            CalendarWidget.toggle();
        }
    }
    /**
     * Check if keyboard shortcuts are working (for debugging)
     */
    static testKeybindings() {
        if (!game.keybindings) {
            Logger.warn('Keybindings API not available for testing');
            return false;
        }
        const registeredKeybindings = game.keybindings.actions.get('seasons-and-stars');
        const expectedKeybindings = [
            'toggleDefaultWidget',
            'toggleMiniWidget',
            'toggleGridWidget',
            'toggleMainWidget',
        ];
        const registeredNames = registeredKeybindings ? Array.from(registeredKeybindings.keys()) : [];
        const allRegistered = expectedKeybindings.every(name => registeredNames.includes(name));
        Logger.debug('Keybinding test results', {
            expected: expectedKeybindings,
            registered: registeredNames,
            allRegistered,
        });
        return allRegistered;
    }
}

/**
 * Bridge Integration Interface for Seasons & Stars
 *
 * Provides a clean, generic API for compatibility bridge modules to integrate
 * with S&S without requiring external calendar system knowledge in the core.
 */
var WidgetPreference;
(function (WidgetPreference) {
    WidgetPreference["MAIN"] = "main";
    WidgetPreference["MINI"] = "mini";
    WidgetPreference["GRID"] = "grid";
    WidgetPreference["ANY"] = "any";
})(WidgetPreference || (WidgetPreference = {}));
/**
 * Main integration class that bridges use to interact with S&S
 */
class SeasonsStarsIntegration {
    constructor(manager) {
        this.manager = manager;
        this.widgetManager = new IntegrationWidgetManager();
        this.hookManager = new IntegrationHookManager(manager);
    }
    /**
     * Detect and create integration instance
     */
    static detect() {
        if (this.instance) {
            return this.instance;
        }
        // Check if S&S is available
        const module = game.modules.get('seasons-and-stars');
        if (!module?.active) {
            return null;
        }
        // Check if manager is available
        const manager = game.seasonsStars?.manager;
        if (!manager || !isCalendarManager(manager)) {
            return null;
        }
        this.instance = new SeasonsStarsIntegration(manager);
        return this.instance;
    }
    /**
     * Get current version
     */
    get version() {
        const module = game.modules.get('seasons-and-stars');
        return module?.version || '0.0.0';
    }
    /**
     * Check if integration is available
     */
    get isAvailable() {
        return !!(this.manager && this.api);
    }
    /**
     * Get API interface
     */
    get api() {
        return new IntegrationAPI(this.manager); // TODO: Fix interface mismatches
    }
    /**
     * Get widgets interface
     */
    get widgets() {
        return this.widgetManager; // TODO: Fix interface mismatches
    }
    /**
     * Get hooks interface
     */
    get hooks() {
        return this.hookManager; // TODO: Fix interface mismatches
    }
    /**
     * Check if specific feature is available
     */
    hasFeature(feature) {
        return this.getFeatureVersion(feature) !== null;
    }
    /**
     * Get feature version for compatibility checking
     */
    getFeatureVersion(feature) {
        const version = this.version;
        // Use capability detection instead of version comparison for better compatibility
        switch (feature) {
            case 'basic-api':
                return this.manager ? version : null;
            case 'widget-system':
                return this.widgetManager.main || this.widgetManager.mini ? version : null;
            case 'sidebar-buttons': {
                // Check if widgets have addSidebarButton method
                const mainWidget = this.widgetManager.main;
                return mainWidget && typeof mainWidget.addSidebarButton === 'function' ? version : null;
            }
            case 'mini-widget':
                return this.widgetManager.mini ? version : null;
            case 'time-advancement':
                return typeof this.manager.advanceDays === 'function' &&
                    typeof this.manager.advanceHours === 'function'
                    ? version
                    : null;
            case 'multiple-calendars':
                return this.manager.getAvailableCalendars().length > 1 ? version : null;
            case 'grid-widget':
                return this.widgetManager.grid ? version : null;
            case 'bridge-interface':
                // This feature is available if we have the integration class
                return version;
            case 'notes-system':
                // Check if notes manager is available
                return game.seasonsStars?.notes ? version : null;
            case 'simple-calendar-notes-api': {
                // Check if notes API methods are available
                const notesManager = game.seasonsStars?.notes;
                return notesManager &&
                    typeof notesManager.createNote === 'function' &&
                    typeof notesManager.setNoteModuleData === 'function'
                    ? version
                    : null;
            }
            default:
                return null;
        }
    }
    compareVersions(version1, version2) {
        const v1Parts = version1.split('.').map(Number);
        const v2Parts = version2.split('.').map(Number);
        for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
            const v1Part = v1Parts[i] || 0;
            const v2Part = v2Parts[i] || 0;
            if (v1Part !== v2Part) {
                return v1Part - v2Part;
            }
        }
        return 0;
    }
    /**
     * Clean up integration resources
     */
    cleanup() {
        this.hookManager.cleanup();
        this.widgetManager.cleanup();
        SeasonsStarsIntegration.instance = null;
    }
}
SeasonsStarsIntegration.instance = null;
/**
 * API implementation that wraps the calendar manager
 */
class IntegrationAPI {
    constructor(manager) {
        this.manager = manager;
    }
    getCurrentDate(_calendarId) {
        // The actual manager method doesn't take a calendarId
        const currentDate = this.manager.getCurrentDate();
        if (!currentDate) {
            throw new Error('No active calendar or current date available');
        }
        return currentDate;
    }
    worldTimeToDate(timestamp, _calendarId) {
        // Use engine to convert world time to date
        const engine = this.manager.getActiveEngine();
        if (!engine) {
            throw new Error('No active calendar engine');
        }
        // Apply system-specific worldTime transformation if available
        let transformedWorldTime = timestamp;
        let systemTimeOffset;
        try {
            const transform = compatibilityManager.getSystemData(game.system.id, 'worldTimeTransform');
            if (transform) {
                [transformedWorldTime, systemTimeOffset] = transform(timestamp);
            }
        }
        catch (error) {
            Logger.warn(`Error applying ${game.system.id} worldTime transformation:`, error);
        }
        return engine.worldTimeToDate(transformedWorldTime, systemTimeOffset);
    }
    dateToWorldTime(date, _calendarId) {
        // Use engine to convert date to world time
        const engine = this.manager.getActiveEngine();
        if (!engine) {
            throw new Error('No active calendar engine');
        }
        // Apply system-specific worldTime transformation if available
        let systemTimeOffset;
        try {
            const transform = compatibilityManager.getSystemData(game.system.id, 'worldTimeTransform');
            if (transform) {
                // Get the system time offset (we don't need to transform the input here)
                [, systemTimeOffset] = transform(0);
            }
        }
        catch (error) {
            Logger.warn(`Error getting ${game.system.id} system time offset:`, error);
        }
        return engine.dateToWorldTime(date, systemTimeOffset);
    }
    formatDate(date, options) {
        // Use CalendarDate class to format date
        const calendar = this.manager.getActiveCalendar();
        if (!calendar) {
            throw new Error('No active calendar');
        }
        const calendarDate = new CalendarDate(date, calendar);
        return calendarDate.format(options || {});
    }
    getActiveCalendar() {
        const calendar = this.manager.getActiveCalendar();
        if (!calendar) {
            throw new Error('No active calendar');
        }
        return calendar;
    }
    async setActiveCalendar(calendarId) {
        const success = await this.manager.setActiveCalendar(calendarId);
        if (!success) {
            throw new Error(`Failed to set active calendar: ${calendarId}`);
        }
    }
    getAvailableCalendars() {
        return this.manager.getAvailableCalendars().map(calendar => calendar.id);
    }
    async advanceDays(days, _calendarId) {
        return this.manager.advanceDays(days);
    }
    async advanceHours(hours, _calendarId) {
        return this.manager.advanceHours(hours);
    }
    async advanceMinutes(minutes, _calendarId) {
        return this.manager.advanceMinutes(minutes);
    }
    getMonthNames(calendarId) {
        const calendar = calendarId
            ? this.manager.getCalendar(calendarId)
            : this.manager.getActiveCalendar();
        if (!calendar) {
            throw new Error('No calendar available');
        }
        return calendar.months.map(month => month.name);
    }
    getWeekdayNames(calendarId) {
        const calendar = calendarId
            ? this.manager.getCalendar(calendarId)
            : this.manager.getActiveCalendar();
        if (!calendar) {
            throw new Error('No calendar available');
        }
        return calendar.weekdays.map(weekday => weekday.name);
    }
    getSunriseSunset(_date, _calendarId) {
        // Default implementation - can be enhanced with calendar-specific data
        return {
            sunrise: 6, // 6 AM
            sunset: 18, // 6 PM
        };
    }
    getSeasonInfo(date, _calendarId) {
        // Default seasonal calculation - can be enhanced with calendar-specific data
        const month = date.month;
        if (month >= 3 && month <= 5) {
            return { name: 'Spring', icon: 'spring' };
        }
        else if (month >= 6 && month <= 8) {
            return { name: 'Summer', icon: 'summer' };
        }
        else if (month >= 9 && month <= 11) {
            return { name: 'Fall', icon: 'fall' };
        }
        else {
            return { name: 'Winter', icon: 'winter' };
        }
    }
    get notes() {
        return new IntegrationNotesAPI(this.manager);
    }
}
/**
 * Widget manager for bridge integration
 */
class IntegrationWidgetManager {
    constructor() {
        this.changeCallbacks = [];
    }
    get main() {
        const widget = CalendarWidget.getInstance();
        return widget ? new BridgeWidgetWrapper(widget, 'main') : null;
    }
    get mini() {
        const widget = CalendarMiniWidget.getInstance();
        return widget ? new BridgeWidgetWrapper(widget, 'mini') : null;
    }
    get grid() {
        const widget = CalendarGridWidget.getInstance();
        return widget ? new BridgeWidgetWrapper(widget, 'grid') : null;
    }
    getPreferredWidget(preference = WidgetPreference.ANY) {
        switch (preference) {
            case WidgetPreference.MAIN:
                return this.main;
            case WidgetPreference.MINI:
                return this.mini;
            case WidgetPreference.GRID:
                return this.grid;
            case WidgetPreference.ANY:
            default:
                return this.mini || this.main || this.grid;
        }
    }
    onWidgetChange(callback) {
        this.changeCallbacks.push(callback);
    }
    offWidgetChange(callback) {
        const index = this.changeCallbacks.indexOf(callback);
        if (index > -1) {
            this.changeCallbacks.splice(index, 1);
        }
    }
    notifyWidgetChange() {
        for (const callback of this.changeCallbacks) {
            try {
                callback(this); // TODO: Fix interface mismatch
            }
            catch (error) {
                Logger.error('Widget change callback error', error instanceof Error ? error : new Error(String(error)));
            }
        }
    }
    cleanup() {
        this.changeCallbacks.length = 0;
    }
}
/**
 * Wrapper for widget instances to provide bridge interface
 */
class BridgeWidgetWrapper {
    constructor(widget, widgetType) {
        this.widget = widget;
        this.widgetType = widgetType;
    }
    get id() {
        return `${this.widgetType}-widget`;
    }
    get isVisible() {
        return this.widget.rendered || false;
    }
    addSidebarButton(name, icon, tooltip, callback) {
        if (typeof this.widget.addSidebarButton === 'function') {
            this.widget.addSidebarButton(name, icon, tooltip, callback);
        }
        else {
            throw new Error(`Widget ${this.widgetType} does not support sidebar buttons`);
        }
    }
    removeSidebarButton(name) {
        if (typeof this.widget.removeSidebarButton === 'function') {
            this.widget.removeSidebarButton(name);
        }
    }
    hasSidebarButton(name) {
        if (typeof this.widget.hasSidebarButton === 'function') {
            return this.widget.hasSidebarButton(name);
        }
        return false;
    }
    getInstance() {
        return this.widget;
    }
}
/**
 * Hook manager for bridge integration
 */
class IntegrationHookManager {
    constructor(manager) {
        this.manager = manager;
        this.hookCallbacks = new Map();
        this.setupHookListeners();
    }
    setupHookListeners() {
        // Listen to internal S&S hooks and translate for bridges
        Hooks.on('seasons-stars:dateChanged', (data) => {
            this.emitToCallbacks('dateChanged', data);
        });
        Hooks.on('seasons-stars:calendarChanged', (data) => {
            this.emitToCallbacks('calendarChanged', data);
        });
        Hooks.on('seasons-stars:ready', (data) => {
            this.emitToCallbacks('ready', data);
        });
    }
    onDateChanged(callback) {
        this.addCallback('dateChanged', callback);
    }
    onCalendarChanged(callback) {
        this.addCallback('calendarChanged', callback);
    }
    onReady(callback) {
        this.addCallback('ready', callback);
    }
    off(hookName, callback) {
        const callbacks = this.hookCallbacks.get(hookName);
        if (callbacks) {
            const index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        }
    }
    addCallback(hookName, callback) {
        if (!this.hookCallbacks.has(hookName)) {
            this.hookCallbacks.set(hookName, []);
        }
        this.hookCallbacks.get(hookName).push(callback);
    }
    emitToCallbacks(hookName, data) {
        const callbacks = this.hookCallbacks.get(hookName);
        if (callbacks) {
            for (const callback of callbacks) {
                try {
                    callback(data);
                }
                catch (error) {
                    Logger.error(`Hook callback error for ${hookName}`, error instanceof Error ? error : new Error(String(error)));
                }
            }
        }
    }
    cleanup() {
        this.hookCallbacks.clear();
        // Note: We don't remove the Foundry hooks as other parts of S&S may still need them
    }
}
/**
 * Notes API implementation for bridge integration
 * Provides complete Simple Calendar API compatibility with full notes functionality
 */
class IntegrationNotesAPI {
    constructor(manager) {
        this.manager = manager;
    }
    // Simple Calendar API compatibility methods
    async addNote(title, content, startDate, endDate, allDay = true, playerVisible = true) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        // Convert Simple Calendar format (0-based) to S&S format (1-based)
        const convertedStartDate = this.convertSCDateToSS(startDate);
        const convertedEndDate = endDate ? this.convertSCDateToSS(endDate) : undefined;
        const noteData = {
            title,
            content,
            startDate: convertedStartDate,
            endDate: convertedEndDate,
            allDay,
            calendarId: this.manager.getActiveCalendar()?.id || 'default',
            playerVisible,
        };
        const note = await notesManager.createNote(noteData);
        // Return Simple Calendar compatible object
        return this.convertNoteToSCFormat(note);
    }
    async removeNote(noteId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        await notesManager.deleteNote(noteId);
    }
    getNotesForDay(year, month, day, _calendarId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            return [];
        }
        // Convert 0-based SC format to 1-based S&S format
        const engine = this.manager.getActiveEngine();
        const ssYear = year;
        const ssMonth = month + 1;
        const ssDay = day + 1;
        const weekday = engine ? engine.calculateWeekday(ssYear, ssMonth, ssDay) : 0;
        const dateData = {
            year: ssYear,
            month: ssMonth,
            day: ssDay,
            weekday,
        };
        const calendar = this.manager.getActiveCalendar();
        if (!calendar) {
            Logger.warn('No active calendar found for note conversion');
            return [];
        }
        const date = new CalendarDate(dateData, calendar);
        try {
            // Get notes synchronously from storage
            const storage = notesManager.storage;
            const notes = storage.findNotesByDateSync(date);
            return notes.map(note => this.convertNoteToSCFormat(note));
        }
        catch (error) {
            Logger.error('Error retrieving notes for day', error instanceof Error ? error : new Error(String(error)));
            return [];
        }
    }
    // Enhanced notes functionality (async versions)
    async createNote(data) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        return notesManager.createNote(data);
    }
    async updateNote(noteId, data) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        return notesManager.updateNote(noteId, data);
    }
    async deleteNote(noteId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        return notesManager.deleteNote(noteId);
    }
    async getNote(noteId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            return null;
        }
        return notesManager.getNote(noteId);
    }
    async getNotesForDate(date, _calendarId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            return [];
        }
        return notesManager.getNotesForDate(date);
    }
    async getNotesForDateRange(start, end, _calendarId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            return [];
        }
        return notesManager.getNotesForDateRange(start, end);
    }
    // Module integration methods
    async setNoteModuleData(noteId, moduleId, data) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            throw new Error('Notes system not available');
        }
        return notesManager.setNoteModuleData(noteId, moduleId, data);
    }
    getNoteModuleData(noteId, moduleId) {
        const notesManager = game.seasonsStars?.notes;
        if (!notesManager) {
            return null;
        }
        return notesManager.getNoteModuleData(noteId, moduleId);
    }
    // Date conversion utilities
    convertSCDateToSS(scDate) {
        // Simple Calendar uses 0-based months and days
        // Seasons & Stars uses 1-based months and days
        const engine = this.manager.getActiveEngine();
        const year = scDate.year;
        const month = (scDate.month || 0) + 1;
        const day = (scDate.day || 0) + 1;
        // Calculate weekday using engine
        const weekday = engine ? engine.calculateWeekday(year, month, day) : 0;
        const dateData = {
            year,
            month,
            day,
            weekday,
        };
        const calendar = this.manager.getActiveCalendar();
        if (!calendar) {
            throw new Error('No active calendar found for date conversion');
        }
        return new CalendarDate(dateData, calendar);
    }
    convertSSDateToSC(ssDate) {
        // Convert 1-based S&S format to 0-based SC format
        return {
            year: ssDate.year,
            month: ssDate.month - 1,
            day: ssDate.day - 1,
        };
    }
    convertNoteToSCFormat(note) {
        const flags = note.flags?.['seasons-and-stars'];
        if (!flags?.calendarNote) {
            throw new Error('Invalid calendar note');
        }
        const startDate = flags.startDate;
        const calendar = this.manager.getActiveCalendar();
        const engine = this.manager.getActiveEngine();
        if (!calendar || !engine) {
            throw new Error('No active calendar or engine available');
        }
        // Get month and weekday names
        const monthName = startDate.month >= 1 && startDate.month <= calendar.months.length
            ? calendar.months[startDate.month - 1]?.name || ''
            : '';
        // Calculate weekday and get name
        const weekdayIndex = engine.calculateWeekday(startDate.year, startDate.month, startDate.day);
        const weekdayName = weekdayIndex >= 0 && weekdayIndex < calendar.weekdays.length
            ? calendar.weekdays[weekdayIndex]?.name || ''
            : '';
        // Get ordinal suffix for day
        const daySuffix = this.getOrdinalSuffix(startDate.day);
        // Convert to 0-based for SC compatibility
        const scDate = this.convertSSDateToSC(startDate);
        return {
            // Core properties (0-based for SC compatibility)
            year: scDate.year,
            month: scDate.month,
            day: scDate.day,
            // Display data
            title: note.name,
            content: this.extractNoteContent(note),
            allDay: flags.allDay,
            // Foundry integration
            journalEntryId: note.id,
            // Enhanced display data (matching SmallTime expectations)
            display: {
                monthName: monthName,
                month: startDate.month.toString(),
                day: startDate.day.toString(),
                year: startDate.year.toString(),
                daySuffix: daySuffix,
                yearPrefix: calendar.year?.prefix || '',
                yearPostfix: calendar.year?.suffix || '',
                date: `${monthName} ${startDate.day}, ${startDate.year}`,
                time: '', // Notes don't have specific times
                weekday: weekdayName,
            },
            // Additional metadata
            startDate: startDate,
            endDate: flags.endDate,
            author: note.author?.name || '',
            playerVisible: note.ownership?.default === CONST.DOCUMENT_OWNERSHIP_LEVELS.OBSERVER,
        };
    }
    extractNoteContent(note) {
        // Extract content from the first text page
        const textPage = note.pages?.find(page => page.type === 'text');
        return textPage?.text?.content || '';
    }
    formatNoteDisplay(note) {
        // Convert note to display format for compatibility
        return this.convertNoteToSCFormat(note);
    }
    getOrdinalSuffix(day) {
        if (day >= 11 && day <= 13)
            return 'th';
        const lastDigit = day % 10;
        switch (lastDigit) {
            case 1:
                return 'st';
            case 2:
                return 'nd';
            case 3:
                return 'rd';
            default:
                return 'th';
        }
    }
}

/**
 * Validation utilities for API parameter checking
 */
// Validation utilities for API parameter checking
class ValidationUtils {
    /**
     * Validate calendar ID parameter
     */
    static validateCalendarId(calendarId) {
        if (calendarId !== undefined && (typeof calendarId !== 'string' || calendarId.trim() === '')) {
            throw new Error('Calendar ID must be a non-empty string');
        }
    }
    /**
     * Validate finite number parameter
     */
    static validateFiniteNumber(value, paramName) {
        if (typeof value !== 'number' || !isFinite(value)) {
            throw new Error(`${paramName} must be a finite number`);
        }
    }
    /**
     * Validate calendar date object
     */
    static validateCalendarDate(date, paramName) {
        if (!date || typeof date !== 'object') {
            throw new Error(`${paramName} must be a calendar date object`);
        }
        if (typeof date.year !== 'number' ||
            typeof date.month !== 'number' ||
            typeof date.day !== 'number') {
            throw new Error(`${paramName} must have numeric year, month, and day properties`);
        }
    }
    /**
     * Validate string parameter
     */
    static validateString(value, paramName, allowEmpty = true) {
        if (typeof value !== 'string') {
            throw new Error(`${paramName} must be a string`);
        }
        if (!allowEmpty && value.trim() === '') {
            throw new Error(`${paramName} cannot be empty`);
        }
    }
}

/**
 * API wrapper to consolidate repetitive validation and error handling patterns
 * Reduces boilerplate in module.ts API methods
 */
/**
 * Standardized API method wrapper
 */
class APIWrapper {
    /**
     * Wrap an API method with standardized logging, validation, and error handling
     */
    static async wrapAPIMethod(methodName, params, validator, implementation) {
        try {
            Logger.api(methodName, params);
            // Validate parameters
            validator(params);
            // Execute implementation
            const result = await implementation();
            Logger.api(methodName, params, result === undefined ? 'success' : result);
            return result;
        }
        catch (error) {
            Logger.error(`Failed to ${methodName}`, error instanceof Error ? error : new Error(String(error)));
            throw error;
        }
    }
    /**
     * Common validation helpers
     */
    static validateNumber(value, name) {
        if (typeof value !== 'number' || !isFinite(value)) {
            throw new Error(`${name} must be a finite number`);
        }
    }
    static validateString(value, name, allowEmpty = false) {
        if (typeof value !== 'string') {
            throw new Error(`${name} must be a string`);
        }
        if (!allowEmpty && value.trim() === '') {
            throw new Error(`${name} must not be empty`);
        }
    }
    static validateOptionalString(value, name) {
        if (value !== undefined && typeof value !== 'string') {
            throw new Error(`${name} must be a string if provided`);
        }
    }
    /**
     * Validate calendar ID with common pattern
     */
    static validateCalendarId(calendarId) {
        if (calendarId !== undefined) {
            this.validateString(calendarId, 'Calendar ID');
            // For now, calendar-specific operations are not implemented
            if (calendarId) {
                throw new Error('Calendar-specific operations not yet implemented');
            }
        }
    }
    /**
     * Validate calendar date object
     */
    static validateCalendarDate(date, name = 'Date') {
        if (!date || typeof date !== 'object') {
            throw new Error(`${name} must be a valid calendar date object`);
        }
        if (typeof date.year !== 'number' ||
            typeof date.month !== 'number' ||
            typeof date.day !== 'number') {
            throw new Error(`${name} must have valid year, month, and day numbers`);
        }
    }
}

/**
 * Quick Time Buttons utility functions for configurable time advancement
 */
/**
 * Parse quick time button setting string into minute values
 */
function parseQuickTimeButtons(settingValue, calendar) {
    if (!settingValue || typeof settingValue !== 'string') {
        Logger.warn('Invalid quick time buttons setting value, using default');
        return UI_CONSTANTS.DEFAULT_QUICK_TIME_BUTTONS.slice(); // Default values
    }
    const hoursPerDay = calendar?.time?.hoursInDay || 24;
    const minutesPerHour = calendar?.time?.minutesInHour || 60;
    const daysPerWeek = calendar?.weekdays?.length || 7;
    try {
        return settingValue
            .split(',')
            .map(val => {
            const trimmed = val.trim();
            if (!trimmed)
                return NaN;
            const match = trimmed.match(/^([+-]?\d+)([mhdw]?)$/);
            if (!match) {
                Logger.debug(`Invalid quick time button value: "${trimmed}"`);
                return NaN;
            }
            const [, amount, unit] = match;
            const num = parseInt(amount);
            if (!Number.isFinite(num)) {
                Logger.debug(`Non-finite number in quick time button value: "${trimmed}"`);
                return NaN;
            }
            switch (unit) {
                case 'w':
                    return num * daysPerWeek * hoursPerDay * minutesPerHour;
                case 'd':
                    return num * hoursPerDay * minutesPerHour;
                case 'h':
                    return num * minutesPerHour;
                case 'm':
                case '':
                    return num; // Default to minutes
                default:
                    Logger.debug(`Unknown unit in quick time button value: "${trimmed}"`);
                    return NaN;
            }
        })
            .filter(val => Number.isFinite(val))
            .sort((a, b) => a - b); // Sort numerically: negatives first, then positives
    }
    catch (error) {
        Logger.error('Error parsing quick time buttons setting', error);
        return UI_CONSTANTS.DEFAULT_QUICK_TIME_BUTTONS.slice(); // Fallback to default
    }
}
/**
 * Format minute values for button display using calendar-aware units
 */
function formatTimeButton(minutes, calendar) {
    if (!Number.isFinite(minutes)) {
        return '0m';
    }
    const minutesPerHour = calendar?.time?.minutesInHour || 60;
    const hoursPerDay = calendar?.time?.hoursInDay || 24;
    const daysPerWeek = calendar?.weekdays?.length || 7;
    const absMinutes = Math.abs(minutes);
    const sign = minutes < 0 ? '-' : '';
    // Calculate in calendar-specific units
    const minutesPerDay = hoursPerDay * minutesPerHour;
    const minutesPerWeek = daysPerWeek * minutesPerDay;
    if (absMinutes >= minutesPerWeek && absMinutes % minutesPerWeek === 0) {
        return `${sign}${absMinutes / minutesPerWeek}w`;
    }
    else if (absMinutes >= minutesPerDay && absMinutes % minutesPerDay === 0) {
        return `${sign}${absMinutes / minutesPerDay}d`;
    }
    else if (absMinutes >= minutesPerHour && absMinutes % minutesPerHour === 0) {
        return `${sign}${absMinutes / minutesPerHour}h`;
    }
    else {
        return `${sign}${absMinutes}m`;
    }
}
/**
 * Get quick time buttons appropriate for widget context
 */
function getQuickTimeButtons(allButtons, isMiniWidget = false) {
    if (!isMiniWidget || allButtons.length <= 3) {
        return allButtons;
    }
    // For mini widget, ensure both negative and positive buttons are available
    const sorted = [...allButtons].sort((a, b) => a - b);
    const negatives = sorted.filter(b => b < 0);
    const positives = sorted.filter(b => b > 0);
    // Take 1 largest negative + 2 smallest positives (or all if fewer available)
    const selectedNegative = negatives.length > 0 ? [negatives[negatives.length - 1]] : [];
    const selectedPositives = positives.slice(0, 3 - selectedNegative.length);
    return [...selectedNegative, ...selectedPositives];
}
/**
 * Get main quick time buttons and calendar context for fallback logic
 */
function getMainButtonsAndCalendar() {
    const mainSetting = game.settings?.get('seasons-and-stars', 'quickTimeButtons') ||
        UI_CONSTANTS.DEFAULT_QUICK_TIME_BUTTONS.join(',');
    const manager = game.seasonsStars?.manager;
    const calendar = manager?.getActiveCalendar() || null;
    const mainButtons = parseQuickTimeButtons(mainSetting, calendar);
    return { mainButtons, calendar };
}
/**
 * Get mini widget specific buttons from settings, returns null if should use fallback
 */
function getMiniWidgetButtonsFromSettings() {
    try {
        // Get mini widget specific setting
        const miniSetting = game.settings?.get('seasons-and-stars', 'miniWidgetQuickTimeButtons');
        // If empty or not set, return null to trigger fallback
        if (!miniSetting || miniSetting.trim() === '') {
            return null;
        }
        // Get calendar for parsing (we no longer need main buttons for validation)
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar() || null;
        // Parse mini buttons independently - no validation against main buttons required
        const parsedMiniButtons = parseQuickTimeButtons(miniSetting, calendar);
        // If no valid buttons could be parsed from the setting, return null for fallback
        if (parsedMiniButtons.length === 0) {
            Logger.warn('No valid mini widget buttons found in setting, using fallback');
            return null;
        }
        // Convert to template format
        return parsedMiniButtons.map(minutes => ({
            amount: minutes,
            unit: 'minutes',
            label: formatTimeButton(minutes, calendar),
        }));
    }
    catch (error) {
        Logger.error('Error getting mini widget buttons from settings', error);
        return null; // Fallback
    }
}
/**
 * Convert minute values to template format
 */
function convertButtonsToTemplateFormat(buttons, calendar) {
    return buttons.map(minutes => ({
        amount: minutes,
        unit: 'minutes',
        label: formatTimeButton(minutes, calendar),
    }));
}
/**
 * Get fallback buttons when no valid configuration is found
 */
function getFallbackButtons() {
    return convertButtonsToTemplateFormat([...UI_CONSTANTS.DEFAULT_QUICK_TIME_BUTTONS], null);
}
/**
 * Get quick time buttons from settings for specific widget type
 */
function getQuickTimeButtonsFromSettings(isMiniWidget = false) {
    try {
        // For mini widget, first try to get specific mini widget buttons
        if (isMiniWidget) {
            const miniButtons = getMiniWidgetButtonsFromSettings();
            if (miniButtons !== null) {
                return miniButtons;
            }
            // Fall through to auto-selection logic below
        }
        // Get main buttons and calendar for auto-selection
        const { mainButtons, calendar } = getMainButtonsAndCalendar();
        // Get appropriate subset for widget type
        const buttons = getQuickTimeButtons(mainButtons, isMiniWidget);
        // If no valid buttons, fall back to defaults
        if (buttons.length === 0) {
            Logger.warn('No valid buttons found in main setting, using fallback defaults');
            return getFallbackButtons();
        }
        // Convert to template format
        return convertButtonsToTemplateFormat(buttons, calendar);
    }
    catch (error) {
        Logger.error('Error getting quick time buttons from settings', error);
        // Fallback to default
        return getFallbackButtons();
    }
}
/**
 * Register Handlebars helper for template use
 */
function registerQuickTimeButtonsHelper() {
    // Access Handlebars from global scope
    const handlebars = globalThis.Handlebars;
    if (handlebars && typeof handlebars.registerHelper === 'function') {
        handlebars.registerHelper('getQuickTimeButtons', function (isMiniWidget = false) {
            return getQuickTimeButtonsFromSettings(isMiniWidget);
        });
        handlebars.registerHelper('formatTimeButton', function (minutes) {
            const manager = game.seasonsStars?.manager;
            const calendar = manager?.getActiveCalendar();
            return formatTimeButton(minutes, calendar);
        });
        Logger.debug('Registered quick time buttons Handlebars helpers');
    }
    else {
        Logger.warn('Handlebars not available for helper registration');
    }
}

/**
 * Settings Preview functionality for Quick Time Buttons and Time Advancement
 */
// Module-level state (replaces static class properties)
let previewContainer = null;
let timeAdvancementPreviewContainer = null;
// Debounced functions using Foundry's utility (with type assertion)
const debouncedTimeAdvancementUpdate = foundry.utils.debounce((ratio) => {
    updateTimeAdvancementExplanation(ratio);
}, 150);
/**
 * Register hooks for settings preview functionality
 */
function registerSettingsPreviewHooks() {
    // Hook into settings config rendering
    Hooks.on('renderSettingsConfig', (app, html) => {
        Logger.debug('Settings config rendered, attempting to enhance settings');
        enhanceButtonSettingsWithUnifiedPreview(html);
        enhanceTimeAdvancementRatioSetting(html);
    });
    Logger.debug('Settings preview hooks registered');
}
/**
 * Enhance both button settings with a unified preview system
 */
function enhanceButtonSettingsWithUnifiedPreview(html) {
    try {
        // Find both button inputs
        const quickTimeInput = html.querySelector('input[name="seasons-and-stars.quickTimeButtons"]');
        const miniWidgetInput = html.querySelector('input[name="seasons-and-stars.miniWidgetQuickTimeButtons"]');
        if (!quickTimeInput && !miniWidgetInput) {
            Logger.debug('No button settings found in settings form');
            return;
        }
        // Create single preview container (attach to the first available input)
        const referenceInput = quickTimeInput || miniWidgetInput;
        createPreviewContainer(referenceInput);
        // Debounced update function that handles both inputs
        const debouncedUnifiedUpdate = foundry.utils.debounce(() => {
            updateUnifiedPreview(quickTimeInput?.value || '', miniWidgetInput?.value || '');
        }, 300);
        // Add listeners to both inputs if they exist
        if (quickTimeInput) {
            quickTimeInput.addEventListener('input', () => debouncedUnifiedUpdate());
        }
        if (miniWidgetInput) {
            miniWidgetInput.addEventListener('input', () => debouncedUnifiedUpdate());
        }
        // Initial preview update
        updateUnifiedPreview(quickTimeInput?.value || '', miniWidgetInput?.value || '');
        Logger.debug('Added unified preview to button settings');
    }
    catch (error) {
        Logger.error('Failed to enhance button settings with unified preview', error);
    }
}
/**
 * Create the preview container HTML
 */
function createPreviewContainer(inputElement) {
    const previewHtml = `
    <div class="quick-time-preview" style="margin-top: 0.75rem; padding: 0.75rem; background: var(--color-bg-option); border: 1px solid var(--color-border-light-primary); border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
      <div class="preview-content">
        <div class="preview-header" style="margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border-light-tertiary);">
          <h4 style="margin: 0; font-size: 0.9rem; color: var(--color-text-dark-primary);">Button Preview</h4>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.8rem; color: var(--color-text-dark-secondary); font-style: italic;">Live preview of how your buttons will appear in each widget</p>
        </div>
        
        <div class="preview-section" style="margin-bottom: 0.75rem;">
          <div class="section-header" style="display: flex; align-items: center; margin-bottom: 0.5rem;">
            <label style="font-weight: bold; font-size: 0.85rem; color: var(--color-text-dark-primary); margin: 0;">Main Calendar Widget:</label>
            <span style="margin-left: 0.5rem; font-size: 0.75rem; color: var(--color-text-dark-secondary);">(Shows all configured buttons)</span>
          </div>
          <div class="preview-buttons main-widget" style="display: flex; gap: 6px; flex-wrap: wrap; min-height: 28px; padding: 0.25rem; background: var(--color-bg); border-radius: 3px; border: 1px solid var(--color-border-light-tertiary);"></div>
        </div>
        
        <div class="preview-section">
          <div class="section-header" style="display: flex; align-items: center; margin-bottom: 0.5rem;">
            <label style="font-weight: bold; font-size: 0.85rem; color: var(--color-text-dark-primary); margin: 0;">Mini Calendar Widget:</label>
            <span style="margin-left: 0.5rem; font-size: 0.75rem; color: var(--color-text-dark-secondary);">(Auto-selects up to 3 buttons)</span>
          </div>
          <div class="preview-buttons mini-widget" style="display: flex; gap: 6px; flex-wrap: wrap; min-height: 28px; padding: 0.25rem; background: var(--color-bg); border-radius: 3px; border: 1px solid var(--color-border-light-tertiary);"></div>
          <div class="mini-widget-note" style="margin-top: 0.25rem;"></div>
        </div>
      </div>
    </div>
  `;
    // Insert preview container after the input's parent form group
    const formGroup = inputElement.closest('.form-group');
    if (formGroup) {
        formGroup.insertAdjacentHTML('afterend', previewHtml);
        previewContainer = formGroup.nextElementSibling;
    }
}
/**
 * Update the unified preview display based on both input values
 */
function updateUnifiedPreview(mainValue, miniValue) {
    if (!previewContainer) {
        Logger.warn('Preview container not available for unified update');
        return;
    }
    try {
        // Get current calendar for parsing
        const manager = game.seasonsStars?.manager;
        const calendar = manager?.getActiveCalendar();
        if (!mainValue || typeof mainValue !== 'string') {
            showErrorPreview('Invalid main buttons input');
            return;
        }
        // Parse the main buttons input value to validate it
        const parsedMainButtons = parseQuickTimeButtons(mainValue, calendar);
        if (parsedMainButtons.length === 0) {
            showErrorPreview('No valid time values found in main buttons');
            return;
        }
        // Show preview with both settings
        showButtonPreview(parsedMainButtons, calendar, mainValue, miniValue);
    }
    catch (error) {
        Logger.error('Error updating unified preview', error);
        showErrorPreview('Error parsing input');
    }
}
/**
 * Show button preview using simple logic (no settings manipulation)
 */
function showButtonPreview(inputButtons, calendar, mainSetting, miniSetting) {
    if (!previewContainer)
        return;
    try {
        // Parse main setting if we have input buttons, otherwise parse main setting
        const mainButtons = inputButtons.length > 0 ? inputButtons : parseQuickTimeButtons(mainSetting, calendar);
        // Determine mini widget buttons using the updated permissive logic
        let miniButtons;
        let parseError = false;
        if (miniSetting && miniSetting.trim() !== '') {
            // Parse mini buttons independently - no validation against main buttons needed
            const parsedMiniButtons = parseQuickTimeButtons(miniSetting, calendar);
            if (parsedMiniButtons.length > 0) {
                // Use all parsed buttons - no filtering required
                miniButtons = parsedMiniButtons;
            }
            else {
                // No valid buttons could be parsed, fall back to auto-selection
                miniButtons = getQuickTimeButtons(mainButtons, true);
                parseError = true;
            }
        }
        else {
            // Auto-select from main buttons
            miniButtons = getQuickTimeButtons(mainButtons, true);
        }
        // Update main widget preview
        const mainContainer = previewContainer.querySelector('.preview-buttons.main-widget');
        if (mainContainer) {
            mainContainer.innerHTML = renderButtonPreview(mainButtons, calendar);
        }
        // Update mini widget preview
        const miniContainer = previewContainer.querySelector('.preview-buttons.mini-widget');
        const miniNoteContainer = previewContainer.querySelector('.mini-widget-note');
        if (miniContainer) {
            miniContainer.innerHTML = renderButtonPreview(miniButtons, calendar);
        }
        // Update mini widget note with updated logic
        if (miniNoteContainer) {
            updateMiniWidgetNoteWithUpdatedLogic(miniNoteContainer, mainButtons, miniButtons, miniSetting, parseError);
        }
    }
    catch (error) {
        Logger.error('Error showing button preview', error);
        showErrorPreview('Error showing preview');
    }
}
/**
 * Update mini widget note with updated permissive logic
 */
function updateMiniWidgetNoteWithUpdatedLogic(noteContainer, mainButtons, miniButtons, miniSetting, parseError) {
    if (miniSetting && miniSetting.trim() !== '') {
        // User has configured specific mini widget buttons
        if (parseError) {
            // Could not parse any valid buttons from the setting
            noteContainer.innerHTML = `
        <div style="font-size: 0.75rem; color: var(--color-text-light-warning); padding: 0.25rem; background: #fef2f2; border-radius: 3px; border-left: 3px solid #fecaca;">
          <i class="fas fa-exclamation-triangle" style="margin-right: 0.25rem;"></i>
          <strong>Parse Error:</strong> No valid time values found in mini widget setting. Using auto-selection fallback.
        </div>
      `;
        }
        else {
            // Successfully parsed custom mini widget buttons
            noteContainer.innerHTML = `
        <div style="font-size: 0.75rem; color: var(--color-text-dark-secondary); padding: 0.25rem; background: var(--color-bg-option); border-radius: 3px; border-left: 3px solid var(--color-border-light-highlight);">
          <i class="fas fa-cog" style="margin-right: 0.25rem;"></i>
          Custom mini widget configuration: ${miniButtons.length} button${miniButtons.length !== 1 ? 's' : ''}
        </div>
      `;
        }
    }
    else {
        // Auto-selection is being used
        if (mainButtons.length > 3 && miniButtons.length <= 3) {
            noteContainer.innerHTML = `
        <div style="font-size: 0.75rem; color: var(--color-text-dark-secondary); padding: 0.25rem; background: var(--color-bg-option); border-radius: 3px; border-left: 3px solid var(--color-border-light-highlight);">
          <i class="fas fa-info-circle" style="margin-right: 0.25rem;"></i>
          Auto-selected ${miniButtons.length} of ${mainButtons.length} buttons for mini widget
        </div>
      `;
        }
        else if (mainButtons.length <= 3) {
            noteContainer.innerHTML = `
        <div style="font-size: 0.75rem; color: var(--color-text-dark-secondary); padding: 0.25rem; background: var(--color-bg-option); border-radius: 3px; border-left: 3px solid var(--color-border-light-highlight);">
          <i class="fas fa-check-circle" style="margin-right: 0.25rem;"></i>
          All ${mainButtons.length} buttons will fit in mini widget
        </div>
      `;
        }
        else {
            noteContainer.innerHTML = '';
        }
    }
}
/**
 * Render button preview HTML for a set of buttons (legacy function for backwards compatibility)
 */
function renderButtonPreview(buttons, calendar) {
    if (buttons.length === 0) {
        return '<span style="font-style: italic; color: var(--color-text-dark-secondary); font-size: 0.8rem;">No buttons to display</span>';
    }
    return buttons
        .map(minutes => {
        const label = formatTimeButton(minutes, calendar);
        const cssClass = minutes < 0 ? 'rewind' : 'forward';
        const icon = minutes < 0 ? 'fa-backward' : 'fa-forward';
        // Enhanced styling to match actual widget buttons more closely
        return `<button type="button" class="preview-button ${cssClass}" style="
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.5rem;
        margin: 0;
        background: ${minutes < 0
            ? 'linear-gradient(135deg, #dc2626, #ef4444)'
            : 'linear-gradient(135deg, #10b981, #14b8a6)'};
        border: 1px solid ${minutes < 0 ? '#b91c1c' : '#059669'};
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 500;
        color: white;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        cursor: default;
        transition: none;
      "><i class="fas ${icon}" style="margin-right: 0.25rem; font-size: 0.7rem;"></i>${label}</button>`;
    })
        .join(' ');
}
/**
 * Show error state in preview
 */
function showErrorPreview(message) {
    if (!previewContainer)
        return;
    const mainContainer = previewContainer.querySelector('.preview-buttons.main-widget');
    const miniContainer = previewContainer.querySelector('.preview-buttons.mini-widget');
    const miniNoteContainer = previewContainer.querySelector('.mini-widget-note');
    const errorHtml = `
    <div style="display: flex; align-items: center; padding: 0.5rem; background: #fef2f2; border: 1px solid #fecaca; border-radius: 3px; color: #dc2626; font-size: 0.8rem;">
      <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
      ${message}
    </div>
  `;
    if (mainContainer)
        mainContainer.innerHTML = errorHtml;
    if (miniContainer)
        miniContainer.innerHTML = errorHtml;
    if (miniNoteContainer)
        miniNoteContainer.innerHTML = '';
}
/**
 * Enhance the time advancement ratio setting with live explanation
 */
function enhanceTimeAdvancementRatioSetting(html) {
    try {
        // Find the time advancement ratio range-picker element
        const rangePicker = html.querySelector('range-picker[name="seasons-and-stars.timeAdvancementRatio"]');
        if (!rangePicker) {
            Logger.debug('Time advancement ratio range-picker not found in settings form');
            return;
        }
        // Get the input elements inside the range-picker (we'll listen to both number and range)
        const rangeInput = rangePicker.querySelector('input[type="range"]');
        const numberInput = rangePicker.querySelector('input[type="number"]');
        if (!rangeInput && !numberInput) {
            Logger.debug('Time advancement ratio inputs not found inside range-picker');
            return;
        }
        // Create explanation container (use the range-picker as the reference element)
        createTimeAdvancementExplanationContainer(rangePicker);
        // Add input event listeners for live updates to both inputs
        const updateHandler = (event) => {
            const target = event.target;
            debouncedTimeAdvancementUpdate(parseFloat(target.value) || 1.0);
        };
        if (rangeInput) {
            rangeInput.addEventListener('input', updateHandler);
        }
        if (numberInput) {
            numberInput.addEventListener('input', updateHandler);
        }
        // Initial explanation (get current value from range-picker attribute or first available input)
        const currentValue = parseFloat(rangePicker.getAttribute('value') || rangeInput?.value || numberInput?.value || '1.0');
        updateTimeAdvancementExplanation(currentValue);
        Logger.debug('Added live explanation to time advancement ratio setting');
    }
    catch (error) {
        Logger.error('Failed to enhance time advancement ratio setting', error);
    }
}
/**
 * Create the time advancement explanation container HTML
 */
function createTimeAdvancementExplanationContainer(referenceElement) {
    const explanationHtml = `
    <div class="time-advancement-explanation" style="margin-top: 0.75rem; padding: 0.75rem; background: var(--color-bg-option); border: 1px solid var(--color-border-light-primary); border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
      <div class="explanation-content">
        <div class="explanation-header" style="margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--color-border-light-tertiary);">
          <h4 style="margin: 0; font-size: 0.9rem; color: var(--color-text-dark-primary);">Time Advancement Preview</h4>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.8rem; color: var(--color-text-dark-secondary); font-style: italic;">Live explanation of how this ratio affects game time flow</p>
        </div>
        <div class="ratio-explanation" style="margin-bottom: 0.75rem; padding: 0.5rem; background: var(--color-bg); border-radius: 3px; border-left: 3px solid var(--color-border-light-highlight);"></div>
        <div class="interval-explanation" style="font-size: 0.8rem; color: var(--color-text-dark-secondary); padding: 0.25rem; background: var(--color-bg); border-radius: 3px;"></div>
      </div>
    </div>
  `;
    // Insert explanation container after the reference element's parent form group
    const formGroup = referenceElement.closest('.form-group');
    if (formGroup) {
        formGroup.insertAdjacentHTML('afterend', explanationHtml);
        timeAdvancementPreviewContainer = formGroup.nextElementSibling;
    }
}
/**
 * Update the time advancement explanation based on current ratio
 */
function updateTimeAdvancementExplanation(ratio) {
    if (!timeAdvancementPreviewContainer) {
        Logger.warn('Time advancement explanation container not available for update');
        return;
    }
    try {
        // Validate ratio
        if (isNaN(ratio) || ratio <= 0) {
            showTimeAdvancementError('Invalid ratio value');
            return;
        }
        // Calculate interval using the same formula as TimeAdvancementService
        const interval = Math.max(10000, Math.ceil(1000 / ratio));
        // Generate explanations
        const ratioExplanation = generateRatioExplanation(ratio);
        const intervalExplanation = generateIntervalExplanation(ratio, interval);
        // Update explanation content
        const ratioContainer = timeAdvancementPreviewContainer.querySelector('.ratio-explanation');
        const intervalContainer = timeAdvancementPreviewContainer.querySelector('.interval-explanation');
        if (ratioContainer) {
            ratioContainer.innerHTML = ratioExplanation;
        }
        if (intervalContainer) {
            intervalContainer.innerHTML = intervalExplanation;
        }
    }
    catch (error) {
        Logger.error('Error updating time advancement explanation', error);
        showTimeAdvancementError('Error calculating explanation');
    }
}
/**
 * Generate human-readable ratio explanation
 */
function generateRatioExplanation(ratio) {
    if (ratio === 1.0) {
        return `<strong>Real Time:</strong> 1 second of real time = 1 second of game time`;
    }
    else if (ratio > 1.0) {
        if (ratio === Math.floor(ratio)) {
            return `<strong>Accelerated Time:</strong> 1 second of real time = ${ratio} seconds of game time (${ratio}x speed)`;
        }
        else {
            return `<strong>Accelerated Time:</strong> 1 second of real time = ${ratio} seconds of game time (${ratio}x speed)`;
        }
    }
    else {
        const realSecondsPerGameSecond = Math.round(1 / ratio);
        if (realSecondsPerGameSecond <= 60) {
            return `<strong>Slow Time:</strong> ${realSecondsPerGameSecond} seconds of real time = 1 second of game time`;
        }
        else {
            const realMinutesPerGameSecond = Math.round(realSecondsPerGameSecond / 60);
            return `<strong>Very Slow Time:</strong> ${realMinutesPerGameSecond} minutes of real time = 1 second of game time`;
        }
    }
}
/**
 * Generate technical interval explanation
 */
function generateIntervalExplanation(ratio, interval) {
    const intervalSeconds = interval / 1000;
    const gameSecondsAdvanced = ratio * intervalSeconds;
    return `Technical: Every ${intervalSeconds} seconds, game time advances by ${gameSecondsAdvanced} seconds`;
}
/**
 * Show error state in time advancement explanation
 */
function showTimeAdvancementError(message) {
    if (!timeAdvancementPreviewContainer)
        return;
    const ratioContainer = timeAdvancementPreviewContainer.querySelector('.ratio-explanation');
    const intervalContainer = timeAdvancementPreviewContainer.querySelector('.interval-explanation');
    const errorHtml = `
    <div style="display: flex; align-items: center; color: #dc2626;">
      <i class="fas fa-exclamation-triangle" style="margin-right: 0.5rem;"></i>
      ${message}
    </div>
  `;
    if (ratioContainer)
        ratioContainer.innerHTML = errorHtml;
    if (intervalContainer)
        intervalContainer.innerHTML = '';
}

/**
 * Seasons & Stars - Main Module Entry Point
 * A clean calendar and timekeeping module for Foundry VTT v13+
 */
// Import styles
// Import integrations (they register their own hooks independently)
// PF2e integration moved to separate pf2e-pack module
// Module instances
let calendarManager;
let notesManager;
// Track if we've already warned about missing seasons for the current active calendar
let hasWarnedAboutMissingSeasons = false;
/**
 * Reset the seasons warning state - exposed for testing and external calendar changes
 * This is called automatically when the seasons-stars:calendarChanged hook fires
 */
function resetSeasonsWarningState() {
    hasWarnedAboutMissingSeasons = false;
}
/**
 * Get the current seasons warning state - exposed for testing
 * @returns true if we've already warned about missing seasons for the active calendar
 */
function getSeasonsWarningState() {
    return hasWarnedAboutMissingSeasons;
}
/**
 * Set the seasons warning state - exposed for testing
 * @param warned true if we should consider the warning as having been shown
 */
function setSeasonsWarningState(warned) {
    hasWarnedAboutMissingSeasons = warned;
}
// Register scene controls at top level (critical timing requirement)
SeasonsStarsSceneControls.registerControls();
// Register Errors and Echoes hook at top level (RECOMMENDED - eliminates timing issues)
Hooks.once('errorsAndEchoesReady', (errorsAndEchoesAPI) => {
    // E&E is guaranteed to be ready when this hook is called
    try {
        Logger.debug('Registering with Errors and Echoes via hook');
        errorsAndEchoesAPI.register({
            moduleId: 'seasons-and-stars',
            // Context provider - adds useful debugging information
            contextProvider: () => {
                const context = {};
                // Add current calendar information - safe property access
                if (calendarManager) {
                    const currentDate = calendarManager.getCurrentDate();
                    const activeCalendar = calendarManager.getActiveCalendar();
                    context.currentDate = currentDate
                        ? `${currentDate.year}-${currentDate.month}-${currentDate.day}`
                        : 'unknown';
                    context.activeCalendarId = activeCalendar?.id || 'unknown';
                    context.calendarEngineAvailable = !!calendarManager.getActiveEngine();
                }
                // Add widget state - simple property checks don't need try-catch
                const activeWidgets = [];
                if (CalendarWidget.getInstance?.()?.rendered)
                    activeWidgets.push('main');
                if (CalendarMiniWidget.getInstance?.()?.rendered)
                    activeWidgets.push('mini');
                if (CalendarGridWidget.getInstance?.()?.rendered)
                    activeWidgets.push('grid');
                context.activeWidgets = activeWidgets;
                // Add system information - basic property access
                context.gameSystem = game.system?.id || 'unknown';
                context.foundryVersion = game.version || 'unknown';
                context.smallTimeDetected = !!document.querySelector('#smalltime-app');
                return context;
            },
            // Error filter - focus on errors relevant to S&S functionality
            errorFilter: (error) => {
                const stack = error.stack || '';
                const message = error.message || '';
                // Always report errors that mention our module explicitly
                if (stack.includes('seasons-and-stars') ||
                    message.includes('seasons-and-stars') ||
                    message.includes('S&S') ||
                    stack.includes('CalendarManager') ||
                    stack.includes('CalendarWidget') ||
                    stack.includes('CalendarEngine') ||
                    stack.includes('NotesManager')) {
                    return false; // Don't filter (report this error)
                }
                // Report time/calendar related errors that might affect us
                if (message.includes('worldTime') ||
                    message.includes('game.time') ||
                    message.includes('calendar') ||
                    message.includes('dateToWorldTime') ||
                    message.includes('worldTimeToDate') ||
                    (message.includes('time') && stack.includes('foundry'))) {
                    return false; // Don't filter (time system errors affect us)
                }
                // Report widget positioning and UI errors
                if (message.includes('widget') ||
                    message.includes('SmallTime') ||
                    message.includes('player list') ||
                    (message.includes('position') && stack.includes('ui')) ||
                    message.includes('ApplicationV2')) {
                    return false; // Don't filter (UI errors might affect our widgets)
                }
                // Report integration-related errors
                if (message.includes('Simple Calendar') ||
                    message.includes('simple-calendar') ||
                    message.includes('compatibility') ||
                    message.includes('bridge') ||
                    stack.includes('integration')) {
                    return false; // Don't filter (integration errors affect us)
                }
                // Report foundry core time system errors
                if (stack.includes('foundry.js') &&
                    (message.includes('time') || message.includes('world') || message.includes('scene'))) {
                    return false; // Don't filter (core time system issues)
                }
                // Filter out errors from unrelated modules (unless they mention calendar/time)
                const unrelatedModules = [
                    'dice-so-nice',
                    'lib-wrapper',
                    'socketlib',
                    'combat-utility-belt',
                    'enhanced-terrain-layer',
                    'token-action-hud',
                    'foundryvtt-forien-quest-log',
                ];
                for (const module of unrelatedModules) {
                    if (stack.includes(module) &&
                        !message.includes('calendar') &&
                        !message.includes('time') &&
                        !stack.includes('seasons-and-stars')) {
                        return true; // Filter out (unrelated module error)
                    }
                }
                // Default: filter out most other errors unless they seem time/calendar related
                if (message.includes('calendar') || message.includes('time') || message.includes('date')) {
                    return false; // Don't filter (might be related)
                }
                return true; // Filter out everything else
            },
        });
        Logger.debug('Successfully registered with Errors and Echoes via hook');
    }
    catch (error) {
        Logger.error('Failed to register with Errors and Echoes via hook', error instanceof Error ? error : new Error(String(error)));
    }
});
/**
 * Module initialization - MUST be synchronous to block until calendars are loaded
 */
function init() {
    try {
        Logger.debug('Initializing module (BLOCKING)');
        // Register module settings
        registerSettings();
        // Register Handlebars helpers
        registerQuickTimeButtonsHelper();
        // Register settings preview functionality
        registerSettingsPreviewHooks();
        // Register keyboard shortcuts (must be in init hook)
        Logger.debug('Registering keyboard shortcuts');
        SeasonsStarsKeybindings.registerKeybindings();
        // Note: Note editing hooks temporarily disabled - see KNOWN-ISSUES.md
        // registerNoteEditingHooks();
        // Initialize note categories after settings are available
        initializeNoteCategories();
        // Initialize managers first
        calendarManager = new CalendarManager();
        notesManager = new NotesManager();
        // Try to load active calendar synchronously from cached data first
        // This ensures compatibility bridges can access the API immediately
        Logger.debug('Attempting synchronous calendar initialization from cached data');
        const syncSuccess = calendarManager.initializeSync();
        if (syncSuccess) {
            Logger.debug('Successfully initialized active calendar synchronously');
        }
        else {
            Logger.debug('No cached calendar data available, will load asynchronously');
        }
        // Load all calendars during init - this MUST complete before setup hook
        Logger.debug('Loading calendars during init (BLOCKING)');
        // Start calendar loading immediately but don't block on it
        // The calendars will be loaded by the time setup runs
        calendarManager
            .loadBuiltInCalendars()
            .then(async () => {
            Logger.debug('Built-in calendars loaded successfully during init');
            // Also load calendar packs so all calendars are available during setup
            try {
                await calendarManager.autoLoadCalendarPacks();
                Logger.debug('Calendar packs loaded successfully during init');
            }
            catch (error) {
                Logger.error('Failed to load calendar packs during init:', error instanceof Error ? error : new Error(String(error)));
            }
        })
            .catch(error => {
            Logger.error('Failed to load calendars during init:', error instanceof Error ? error : new Error(String(error)));
        });
        Logger.debug('Module initialized - calendar loading initiated');
    }
    catch (error) {
        Logger.error('Module initialization failed:', error instanceof Error ? error : new Error(String(error)));
    }
}
Hooks.once('init', init);
/**
 * Core module setup during setup - exposes fully functional API before any module's ready hook
 * This ensures compatibility modules can access the S&S API immediately during ready
 * CRITICAL: This must be synchronous and block until complete
 * Calendars are already loaded from init hook - now we activate one and expose API
 */
function setup() {
    try {
        Logger.debug('Core setup during setup - calendars already loaded, setting up API (BLOCKING)');
        // Register calendar-specific settings now that calendars are loaded (from init hook)
        registerCalendarSettings();
        // Set active calendar from settings (synchronous since calendars are already loaded)
        // This creates the time converter needed for getCurrentDate() API calls
        try {
            // Get the active calendar setting and set it directly
            const activeCalendarId = game.settings?.get('seasons-and-stars', 'activeCalendar') || 'gregorian';
            // Set the active calendar synchronously (calendars already loaded in init)
            const success = calendarManager.setActiveCalendarSync(activeCalendarId);
            if (success) {
                Logger.debug(`Active calendar set to ${activeCalendarId} during setup`);
            }
            else {
                Logger.warn(`Failed to set active calendar ${activeCalendarId}, falling back to gregorian`);
                calendarManager.setActiveCalendarSync('gregorian');
            }
        }
        catch (error) {
            Logger.error('Failed to set active calendar during setup:', error instanceof Error ? error : new Error(String(error)));
            // Try to fall back to gregorian
            try {
                calendarManager.setActiveCalendarSync('gregorian');
            }
            catch (fallbackError) {
                Logger.error('Failed to set fallback gregorian calendar:', fallbackError instanceof Error ? fallbackError : new Error(String(fallbackError)));
            }
        }
        // Initialize time advancement service and register combat hooks
        const timeAdvancementService = TimeAdvancementService.getInstance();
        timeAdvancementService.initialize();
        // Reset seasons warning flag when calendar changes
        Hooks.on('seasons-stars:calendarChanged', () => {
            resetSeasonsWarningState();
        });
        // Initialize notes manager synchronously
        try {
            notesManager.initializeSync();
            Logger.debug('Notes manager initialized synchronously during setup');
        }
        catch (error) {
            Logger.error('Failed to initialize notes manager synchronously:', error instanceof Error ? error : new Error(String(error)));
            // Continue - notes functionality may be limited but API will still work
        }
        // Register notes cleanup hooks for external journal deletion
        registerNotesCleanupHooks();
        // Register with Memory Mage if available
        registerMemoryMageIntegration();
        // CRITICAL: Expose fully functional API - calendar and time converter should be ready now
        setupAPI();
        // Register UI component hooks
        CalendarWidget.registerHooks();
        CalendarMiniWidget.registerHooks();
        CalendarGridWidget.registerHooks();
        CalendarMiniWidget.registerSmallTimeIntegration();
        // Register widget factories for CalendarWidgetManager
        Logger.debug('Registering widget factories');
        CalendarWidgetManager.registerWidget('main', () => new WidgetWrapper(CalendarWidget, 'show', 'hide', 'toggle', 'getInstance', 'rendered'));
        CalendarWidgetManager.registerWidget('mini', () => new WidgetWrapper(CalendarMiniWidget, 'show', 'hide', 'toggle', 'getInstance', 'rendered'));
        CalendarWidgetManager.registerWidget('grid', () => new WidgetWrapper(CalendarGridWidget, 'show', 'hide', 'toggle', 'getInstance', 'rendered'));
        // Scene controls registered at top level for timing requirements
        Logger.debug('Registering macros');
        SeasonsStarsSceneControls.registerMacros();
        // Fire ready hook for compatibility modules - API is now fully functional
        Hooks.callAll('seasons-stars:ready', {
            manager: calendarManager,
            api: game.seasonsStars?.api,
        });
        Logger.info('Core module fully initialized synchronously during setup - API ready for compatibility modules');
    }
    catch (error) {
        Logger.error('Module setup failed:', error instanceof Error ? error : new Error(String(error)));
    }
}
Hooks.once('setup', setup);
/**
 * Complete setup after Foundry is ready
 * Core functionality and API are already available, now complete calendar selection
 */
Hooks.once('ready', async () => {
    Logger.debug('Completing setup during ready - setting active calendar from settings');
    // Migration: Cache existing active calendar data for synchronous loading
    // This is needed for users upgrading to the new settings-based caching system
    try {
        const activeCalendarId = game.settings?.get('seasons-and-stars', 'activeCalendar');
        const cachedCalendarData = game.settings?.get('seasons-and-stars', 'activeCalendarData');
        // If we have an active calendar but no cached data, show migration dialog
        if (activeCalendarId &&
            !cachedCalendarData &&
            calendarManager.calendars.has(activeCalendarId)) {
            const calendarData = calendarManager.calendars.get(activeCalendarId);
            if (calendarData && game.user?.isGM) {
                // Show migration dialog to GM
                const confirmed = await new Promise(resolve => {
                    const dialog = new foundry.applications.api.DialogV2({
                        window: {
                            title: 'Seasons & Stars: Calendar Data Migration',
                        },
                        content: `
              <h3>Calendar Data Migration Required</h3>
              <p>Seasons & Stars has been updated to improve compatibility with other calendar modules.</p>
              <p>This requires migrating your current calendar data to a new storage format.</p>
              <p><strong>This migration is safe and will not affect your calendar configuration.</strong></p>
              <p><em>A reload will be required after migration to activate compatibility improvements.</em></p>
              <p>Would you like to proceed with the migration now?</p>
            `,
                        buttons: [
                            {
                                action: 'yes',
                                icon: 'fas fa-check',
                                label: 'Migrate Now',
                                callback: () => resolve(true),
                            },
                            {
                                action: 'no',
                                icon: 'fas fa-times',
                                label: 'Cancel',
                                callback: () => resolve(false),
                            },
                        ],
                        default: 'yes',
                        close: () => resolve(false),
                    });
                    dialog.render(true);
                });
                if (confirmed) {
                    await game.settings.set('seasons-and-stars', 'activeCalendarData', calendarData);
                    Logger.info(`Migration: Successfully cached calendar data for ${activeCalendarId}`);
                    // Log calendar data structure for debugging
                    Logger.debug('Calendar data structure:', calendarData);
                    const calendarName = calendarData.name || calendarData.id || 'Unknown Calendar';
                    ui.notifications?.info(`Calendar data migration completed for "${calendarName}". Please reload Foundry for compatibility improvements to take effect.`);
                }
                else {
                    Logger.warn('Migration declined by user - calendar data not cached');
                    ui.notifications?.warn('Calendar data migration was declined. Some compatibility features may not work until migration is completed.');
                }
            }
            else if (calendarData && !game.user?.isGM) {
                // Non-GM users just see a notification
                Logger.debug(`Migration needed for ${activeCalendarId} but user is not GM`);
                ui.notifications?.info('A GM needs to complete a calendar data migration for full compatibility with other modules.');
            }
        }
    }
    catch (error) {
        Logger.warn('Migration failed to cache calendar data:', error instanceof Error ? error : new Error(String(error)));
        ui.notifications?.error('Calendar data migration failed. Please check the console for details.');
    }
    // Complete calendar manager initialization (read settings and set active calendar)
    // This must happen during ready hook since it sets world-level settings
    await calendarManager.completeInitialization();
    // Show default widget if enabled in settings
    if (game.settings?.get('seasons-and-stars', 'showTimeWidget')) {
        const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
        switch (defaultWidget) {
            case 'mini':
                CalendarMiniWidget.show();
                break;
            case 'grid':
                CalendarGridWidget.show();
                break;
            case 'main':
            default:
                CalendarWidget.show();
                break;
        }
    }
    // Show deprecation warning to GMs
    await CalendarDeprecationDialog.showWarningIfNeeded();
    Logger.info('UI setup complete - module fully ready');
});
/**
 * Register module settings
 */
function registerSettings() {
    if (!game.settings)
        return;
    // === CORE CALENDAR SETTINGS ===
    // Calendar setting registered early with basic choices, updated later when calendars load
    game.settings.register('seasons-and-stars', 'activeCalendar', {
        name: 'SEASONS_STARS.settings.active_calendar',
        hint: 'SEASONS_STARS.settings.active_calendar_hint',
        scope: 'world',
        config: true,
        type: String,
        default: 'gregorian',
        choices: { gregorian: 'Gregorian Calendar' }, // Basic default, updated later
        onChange: async (value) => {
            if (value && value.trim() !== '' && calendarManager) {
                // Clear file picker calendar when regular calendar is selected
                await game.settings.set('seasons-and-stars', 'activeCalendarFile', '');
                await calendarManager.setActiveCalendar(value);
            }
        },
    });
    // Store the full calendar JSON for the active calendar (for synchronous loading)
    game.settings.register('seasons-and-stars', 'activeCalendarData', {
        name: 'Active Calendar Data',
        hint: 'Cached calendar data for immediate loading',
        scope: 'world',
        config: false, // Hidden setting
        type: Object,
        default: null,
        requiresReload: true, // Changes require reload since this affects init hook behavior
    });
    // File picker calendar setting - allows users to load custom calendar files
    game.settings.register('seasons-and-stars', 'activeCalendarFile', {
        name: 'SEASONS_STARS.settings.active_calendar_file',
        hint: 'SEASONS_STARS.settings.active_calendar_file_hint',
        scope: 'world',
        config: false, // Hidden from settings UI - managed through dialog
        type: String,
        default: '',
        onChange: async (value) => {
            // File picker setting only stores the path - actual loading happens when user clicks select
            Logger.debug('File picker path updated:', value);
        },
    });
    // === WIDGET DISPLAY SETTINGS ===
    game.settings.register('seasons-and-stars', 'showTimeWidget', {
        name: 'Auto-Show Default Widget',
        hint: 'Automatically show the default calendar widget when the world loads. You can still manually open/close widgets using scene controls or keyboard shortcuts.',
        scope: 'client',
        config: true,
        type: Boolean,
        default: true,
        onChange: (enabled) => {
            if (enabled) {
                // Show the default widget
                const defaultWidget = game.settings?.get('seasons-and-stars', 'defaultWidget') || 'main';
                switch (defaultWidget) {
                    case 'mini':
                        CalendarMiniWidget.show();
                        break;
                    case 'grid':
                        CalendarGridWidget.show();
                        break;
                    case 'main':
                    default:
                        CalendarWidget.show();
                        break;
                }
                Logger.info(`Showing default widget: ${defaultWidget}`);
            }
            else {
                // Hide all widgets
                CalendarWidget.hide();
                CalendarMiniWidget.hide();
                CalendarGridWidget.hide();
                Logger.info('Hiding all calendar widgets');
            }
        },
    });
    game.settings.register('seasons-and-stars', 'miniWidgetShowTime', {
        name: 'Display Time in Mini Widget',
        hint: 'Show the current time alongside date in the mini calendar widget',
        scope: 'client',
        config: true,
        type: Boolean,
        default: false,
        onChange: () => {
            Hooks.callAll('seasons-stars:settingsChanged', 'miniWidgetShowTime');
        },
    });
    game.settings.register('seasons-and-stars', 'miniWidgetShowDayOfWeek', {
        name: 'Display Day of Week in Mini Widget',
        hint: 'Show abbreviated day name on the left side of the mini calendar widget',
        scope: 'client',
        config: true,
        type: Boolean,
        default: false,
        onChange: () => {
            Hooks.callAll('seasons-stars:settingsChanged', 'miniWidgetShowDayOfWeek');
        },
    });
    game.settings.register('seasons-and-stars', 'miniWidgetPosition', {
        name: 'Mini Widget Position',
        scope: 'client',
        config: false,
        type: Object,
        default: { top: null, left: null },
    });
    game.settings.register('seasons-and-stars', 'miniWidgetPinned', {
        name: 'Mini Widget Pinned',
        scope: 'client',
        config: false,
        type: Boolean,
        default: false,
    });
    game.settings.register('seasons-and-stars', 'miniWidgetCanonicalMode', {
        name: 'Canonical Hours Display Mode',
        hint: 'How to display time when canonical hours are available: Auto (canonical hours when available, exact time otherwise), Canonical Only (hide time when no canonical hour), or Exact Time (always show exact time)',
        scope: 'client',
        config: true,
        type: String,
        choices: {
            auto: 'Auto (canonical or exact)',
            canonical: 'Canonical hours only',
            exact: 'Exact time only',
        },
        default: 'auto',
        onChange: () => {
            Hooks.callAll('seasons-stars:settingsChanged', 'miniWidgetCanonicalMode');
        },
    });
    game.settings.register('seasons-and-stars', 'defaultWidget', {
        name: 'SEASONS_STARS.settings.default_widget',
        hint: 'SEASONS_STARS.settings.default_widget_hint',
        scope: 'client',
        config: true,
        type: String,
        default: 'main',
        choices: {
            main: 'SEASONS_STARS.settings.default_widget_main',
            mini: 'SEASONS_STARS.settings.default_widget_mini',
            grid: 'SEASONS_STARS.settings.default_widget_grid',
        },
    });
    game.settings.register('seasons-and-stars', 'calendarClickBehavior', {
        name: 'Calendar Click Behavior',
        hint: 'Choose what happens when you click on a date in the calendar grid. "Set Current Date" immediately changes the world time (current behavior). "View Date Details" shows date information and flavor text without changing the date.',
        scope: 'client',
        config: true,
        type: String,
        default: 'setDate',
        choices: {
            setDate: 'Set Current Date',
            viewDetails: 'View Date Details',
        },
    });
    // === QUICK TIME BUTTONS SETTINGS ===
    game.settings.register('seasons-and-stars', 'quickTimeButtons', {
        name: 'Quick Time Buttons',
        hint: 'Comma-separated time values for quick advancement buttons. Supports: 15, 30m, 1h, 2d, 1w. Negative values go backward. Examples: "10,30,60" or "-1h,15m,30m,1h"',
        scope: 'world',
        config: true,
        type: String,
        default: UI_CONSTANTS.DEFAULT_QUICK_TIME_BUTTONS.join(','),
        onChange: () => {
            // Trigger widget refresh when settings change
            try {
                if (game.seasonsStars?.manager) {
                    Hooks.callAll('seasons-stars:settingsChanged', 'quickTimeButtons');
                }
            }
            catch (error) {
                Logger.warn('Failed to trigger quick time buttons settings refresh:', error);
            }
        },
    });
    game.settings.register('seasons-and-stars', 'miniWidgetQuickTimeButtons', {
        name: 'Mini Widget Quick Time Buttons',
        hint: 'Specific buttons for mini widget (uses same syntax as main buttons). Leave empty to auto-select from main buttons. Example: "15,60" to show only 15 minutes and 1 hour buttons.',
        scope: 'world',
        config: true,
        type: String,
        default: '',
        onChange: () => {
            try {
                if (game.seasonsStars?.manager) {
                    Hooks.callAll('seasons-stars:settingsChanged', 'miniWidgetQuickTimeButtons');
                }
            }
            catch (error) {
                Logger.warn('Failed to trigger mini widget buttons settings refresh:', error);
            }
        },
    });
    game.settings.register('seasons-and-stars', 'alwaysShowQuickTimeButtons', {
        name: 'Always Display Quick Time Buttons',
        hint: 'Display quick time buttons in widgets even when SmallTime is available. Useful if you prefer S&S time controls over SmallTime.',
        scope: 'client',
        config: true,
        type: Boolean,
        default: false,
        onChange: () => {
            Hooks.callAll('seasons-stars:settingsChanged', 'alwaysShowQuickTimeButtons');
        },
    });
    // === TIME ADVANCEMENT SETTINGS ===
    game.settings.register('seasons-and-stars', 'timeAdvancementRatio', {
        name: 'Time Advancement Ratio',
        hint: 'Game time advancement ratio. 1.0 = real time (10s real = 10s game), 2.0 = 2x speed (10s real = 20s game), 0.5 = half speed (10s real = 5s game). Range: 0.1 to 100.',
        scope: 'world',
        config: true,
        type: Number,
        default: 1.0,
        range: {
            min: 0.1,
            max: 100.0,
            step: 0.1,
        },
        onChange: (value) => {
            try {
                const service = TimeAdvancementService.getInstance();
                service.updateRatio(value);
            }
            catch (error) {
                Logger.warn('Failed to update time advancement ratio:', error);
            }
        },
    });
    game.settings.register('seasons-and-stars', 'pauseOnCombat', {
        name: 'Pause Time on Combat',
        hint: 'Automatically pause time advancement when combat starts',
        scope: 'world',
        config: true,
        type: Boolean,
        default: true,
    });
    game.settings.register('seasons-and-stars', 'resumeAfterCombat', {
        name: 'Resume Time After Combat',
        hint: 'Automatically resume time advancement when combat ends (if it was running before)',
        scope: 'world',
        config: true,
        type: Boolean,
        default: false,
    });
    game.settings.register('seasons-and-stars', 'syncWithGamePause', {
        name: 'Sync with Game Pause',
        hint: "Automatically pause time advancement when Foundry's game is paused. Works alongside combat pause setting. Time will resume when ALL blocking conditions are cleared.",
        scope: 'world',
        config: true,
        type: Boolean,
        default: true,
    });
    // === NOTES SYSTEM SETTINGS ===
    game.settings.register('seasons-and-stars', 'allowPlayerNotes', {
        name: 'Allow Player Notes',
        hint: 'Allow players to create calendar notes',
        scope: 'world',
        config: true,
        type: Boolean,
        default: false,
    });
    game.settings.register('seasons-and-stars', 'defaultPlayerVisible', {
        name: 'Default Player Visibility',
        hint: 'Make new notes visible to players by default',
        scope: 'world',
        config: true,
        type: Boolean,
        default: false,
    });
    game.settings.register('seasons-and-stars', 'defaultPlayerEditable', {
        name: 'Default Player Editable',
        hint: 'Make new notes editable by players by default',
        scope: 'world',
        config: true,
        type: Boolean,
        default: false,
    });
    // === GENERAL UI SETTINGS ===
    game.settings.register('seasons-and-stars', 'showNotifications', {
        name: 'Show Notifications',
        hint: 'Display warning and error notifications in the UI',
        scope: 'client',
        config: true,
        type: Boolean,
        default: true,
    });
    // === INTERNAL SETTINGS (Hidden from UI) ===
    // Note categories configuration - stored as Object for complex data
    game.settings.register('seasons-and-stars', 'noteCategories', {
        name: 'Note Categories Configuration',
        hint: 'Configuration for note categories and tags',
        scope: 'world',
        config: false, // Not shown in config UI, managed by category system
        type: Object,
        default: null,
    });
    // External calendar settings
    game.settings.register('seasons-and-stars', 'seasons-stars.external-calendars', {
        name: 'External Calendar Cache',
        hint: 'Internal cache storage for external calendars',
        scope: 'world',
        config: false, // Hidden from config UI
        type: Object,
        default: {},
    });
    game.settings.register('seasons-and-stars', 'seasons-stars.external-sources', {
        name: 'External Calendar Sources',
        hint: 'Configuration for external calendar sources',
        scope: 'world',
        config: false, // Hidden from config UI
        type: Array,
        default: [],
    });
    // Hidden world settings for internal tracking
    game.settings.register('seasons-and-stars', 'calendarDeprecationWarningShown', {
        name: 'Calendar Deprecation Warning Shown',
        hint: 'Internal setting to track if the GM has dismissed the calendar deprecation warning',
        scope: 'world',
        config: false, // Hidden from config UI
        type: Boolean,
        default: false,
    });
    // === DEVELOPMENT SETTINGS ===
    game.settings.register('seasons-and-stars', 'debugMode', {
        name: 'Debug Mode',
        hint: 'Enable debug logging for troubleshooting (developers only)',
        scope: 'client',
        config: true,
        type: Boolean,
        default: false,
    });
}
/**
 * Update calendar setting choices after calendars are loaded
 */
function registerCalendarSettings() {
    if (!game.settings)
        return;
    // Get available calendars and create choices
    const calendars = calendarManager.getAllCalendars();
    const choices = CalendarLocalization.createCalendarChoices(calendars);
    // Re-register the setting with updated choices to overwrite the basic one
    game.settings.register('seasons-and-stars', 'activeCalendar', {
        name: 'SEASONS_STARS.settings.active_calendar',
        hint: 'SEASONS_STARS.settings.active_calendar_hint',
        scope: 'world',
        config: true,
        type: String,
        default: 'gregorian',
        choices: choices,
        onChange: async (value) => {
            if (value && value.trim() !== '' && calendarManager) {
                // Clear file picker calendar when regular calendar is selected
                await game.settings.set('seasons-and-stars', 'activeCalendarFile', '');
                await calendarManager.setActiveCalendar(value);
            }
        },
    });
    Logger.debug('Updated calendar setting with full choices', { choices });
}
/**
 * Setup the main Seasons & Stars API
 */
function setupAPI() {
    const api = {
        /**
         * Get the current calendar date from the active or specified calendar
         *
         * This is the primary method for retrieving the current game date. It converts
         * the current world time to a structured calendar date object with full date
         * and time information.
         *
         * @param calendarId Optional calendar ID to get date from specific calendar
         * @returns The current calendar date or null if unavailable
         * @throws {Error} If calendar validation fails or calendar not found
         *
         * @example Basic usage - get current date
         * ```javascript
         * // Get current date from active calendar
         * const currentDate = game.seasonsStars.api.getCurrentDate();
         *
         * if (currentDate) {
         *   console.log(`Current date: ${currentDate.year}-${currentDate.month}-${currentDate.day}`);
         *   console.log(`Time: ${currentDate.time?.hour}:${currentDate.time?.minute}`);
         * }
         * ```
         *
         * @example Weather module integration
         * ```javascript
         * class WeatherModule {
         *   updateWeatherDisplay() {
         *     const date = game.seasonsStars.api.getCurrentDate();
         *
         *     if (!date) {
         *       console.warn('No date available for weather calculation');
         *       return;
         *     }
         *
         *     const season = this.calculateSeason(date);
         *     const weather = this.generateWeather(season, date);
         *     this.displayWeather(weather);
         *   }
         * }
         * ```
         *
         * @example Journal entry with current date
         * ```javascript
         * async function createTimestampedEntry(title, content) {
         *   const currentDate = game.seasonsStars.api.getCurrentDate();
         *
         *   if (!currentDate) {
         *     throw new Error('Cannot create timestamped entry: no date available');
         *   }
         *
         *   const formattedDate = game.seasonsStars.api.formatDate(currentDate, {
         *     includeTime: true,
         *     format: 'long'
         *   });
         *
         *   const timestampedContent = `**${formattedDate}**\n\n${content}`;
         *
         *   return await JournalEntry.create({
         *     name: `${title} - ${formattedDate}`,
         *     content: timestampedContent
         *   });
         * }
         * ```
         */
        getCurrentDate: (calendarId) => {
            try {
                Logger.api('getCurrentDate', { calendarId });
                // Input validation using utility
                ValidationUtils.validateCalendarId(calendarId);
                if (calendarId) {
                    // Get date from specific calendar
                    const calendar = calendarManager.getCalendar(calendarId);
                    const engine = calendarManager.getActiveEngine();
                    if (!calendar || !engine) {
                        const error = new Error(`Calendar not found: ${calendarId}`);
                        Logger.error('Calendar not found in getCurrentDate', error);
                        throw error;
                    }
                    const worldTime = game.time?.worldTime || 0;
                    const result = engine.worldTimeToDate(worldTime);
                    Logger.api('getCurrentDate', { calendarId }, result);
                    return result;
                }
                // Get date from active calendar
                const currentDate = calendarManager.getCurrentDate();
                if (!currentDate) {
                    Logger.warn('No current date available from calendar manager');
                    return null;
                }
                const result = currentDate;
                Logger.api('getCurrentDate', undefined, result.toObject());
                return result;
            }
            catch (error) {
                Logger.error('Failed to get current date', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        setCurrentDate: async (date) => {
            try {
                Logger.api('setCurrentDate', { date });
                // Input validation
                if (!date || typeof date !== 'object') {
                    const error = new Error('Date must be a valid CalendarDate object');
                    Logger.error('Invalid date parameter', error);
                    throw error;
                }
                if (typeof date.year !== 'number' ||
                    typeof date.month !== 'number' ||
                    typeof date.day !== 'number') {
                    const error = new Error('Date must have numeric year, month, and day properties');
                    Logger.error('Invalid date structure', error);
                    throw error;
                }
                await calendarManager.setCurrentDate(date);
                Logger.api('setCurrentDate', { date }, 'success');
                return true;
            }
            catch (error) {
                Logger.error('Failed to set current date', error instanceof Error ? error : new Error(String(error)));
                return false;
            }
        },
        advanceTime: async (amount, unit) => {
            try {
                Logger.api('advanceTime', { amount, unit });
                // Input validation using utilities
                ValidationUtils.validateFiniteNumber(amount, 'amount');
                ValidationUtils.validateString(unit, 'unit', false); // Don't allow empty strings
                // Route to appropriate method based on unit
                switch (unit.toLowerCase()) {
                    case 'day':
                    case 'days':
                        await calendarManager.advanceDays(amount);
                        break;
                    case 'hour':
                    case 'hours':
                        await calendarManager.advanceHours(amount);
                        break;
                    case 'minute':
                    case 'minutes':
                        await calendarManager.advanceMinutes(amount);
                        break;
                    case 'week':
                    case 'weeks':
                        await calendarManager.advanceWeeks(amount);
                        break;
                    case 'month':
                    case 'months':
                        await calendarManager.advanceMonths(amount);
                        break;
                    case 'year':
                    case 'years':
                        await calendarManager.advanceYears(amount);
                        break;
                    default: {
                        const error = new Error(`Unsupported time unit: ${unit}`);
                        Logger.error('Unsupported time unit', error);
                        throw error;
                    }
                }
                Logger.api('advanceTime', { amount, unit }, 'success');
            }
            catch (error) {
                Logger.error('Failed to advance time', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        /**
         * Advance world time by specified number of days
         *
         * This method advances the game world time by the specified number of days,
         * taking into account the current calendar's day length and structure.
         * The advancement triggers the dateChanged hook for other modules.
         *
         * @param days Number of days to advance (can be negative to go backward)
         * @param calendarId Optional calendar ID (reserved for future use)
         * @throws {Error} If days is not a valid finite number
         * @throws {Error} If calendar operations fail
         *
         * @example Basic time advancement
         * ```javascript
         * // Advance one day
         * await game.seasonsStars.api.advanceDays(1);
         * console.log('Advanced to next day');
         *
         * // Go back three days
         * await game.seasonsStars.api.advanceDays(-3);
         * console.log('Went back 3 days');
         * ```
         *
         * @example Long rest implementation
         * ```javascript
         * class RestModule {
         *   async performLongRest(actor) {
         *     try {
         *       // Advance 8 hours for long rest
         *       await game.seasonsStars.api.advanceHours(8);
         *
         *       // Heal the actor
         *       await this.healActor(actor);
         *
         *       ui.notifications.info('Long rest completed - 8 hours passed');
         *     } catch (error) {
         *       ui.notifications.error('Failed to complete long rest');
         *       console.error(error);
         *     }
         *   }
         * }
         * ```
         *
         * @example Travel time calculation
         * ```javascript
         * async function simulateTravel(distanceMiles, speedMPH = 25) {
         *   const travelHours = distanceMiles / speedMPH;
         *   const travelDays = Math.ceil(travelHours / 8); // 8 hours travel per day
         *
         *   const startDate = game.seasonsStars.api.getCurrentDate();
         *
         *   await game.seasonsStars.api.advanceDays(travelDays);
         *
         *   const endDate = game.seasonsStars.api.getCurrentDate();
         *
         *   ui.notifications.info(
         *     `Travel completed! Departed ${startDate?.day}/${startDate?.month}, ` +
         *     `arrived ${endDate?.day}/${endDate?.month}`
         *   );
         * }
         * ```
         *
         * @fires seasons-stars:dateChanged When time advancement completes
         */
        advanceDays: async (days, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceDays', { days, calendarId }, params => {
                APIWrapper.validateNumber(params.days, 'Days');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceDays(days));
        },
        advanceHours: async (hours, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceHours', { hours, calendarId }, params => {
                APIWrapper.validateNumber(params.hours, 'Hours');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceHours(hours));
        },
        advanceMinutes: async (minutes, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceMinutes', { minutes, calendarId }, params => {
                APIWrapper.validateNumber(params.minutes, 'Minutes');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceMinutes(minutes));
        },
        advanceWeeks: async (weeks, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceWeeks', { weeks, calendarId }, params => {
                APIWrapper.validateNumber(params.weeks, 'Weeks');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceWeeks(weeks));
        },
        advanceMonths: async (months, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceMonths', { months, calendarId }, params => {
                APIWrapper.validateNumber(params.months, 'Months');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceMonths(months));
        },
        advanceYears: async (years, calendarId) => {
            return APIWrapper.wrapAPIMethod('advanceYears', { years, calendarId }, params => {
                APIWrapper.validateNumber(params.years, 'Years');
                APIWrapper.validateCalendarId(params.calendarId);
            }, () => calendarManager.advanceYears(years));
        },
        formatDate: (date, options) => {
            try {
                Logger.api('formatDate', { date, options });
                // Input validation using APIWrapper helpers
                APIWrapper.validateCalendarDate(date, 'Date');
                const activeCalendar = calendarManager.getActiveCalendar();
                if (!activeCalendar) {
                    throw new Error('No active calendar set');
                }
                const calendarDate = new CalendarDate(date, activeCalendar);
                const result = calendarDate.format(options);
                Logger.api('formatDate', { date, options }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to format date', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        dateToWorldTime: (date, calendarId) => {
            try {
                Logger.api('dateToWorldTime', { date, calendarId });
                // Input validation using APIWrapper helpers
                APIWrapper.validateCalendarDate(date, 'Date');
                APIWrapper.validateOptionalString(calendarId, 'Calendar ID');
                const engine = calendarId
                    ? calendarManager.engines?.get(calendarId)
                    : calendarManager.getActiveEngine();
                if (!engine) {
                    throw new Error(`No engine available for calendar: ${calendarId || 'active'}`);
                }
                const result = engine.dateToWorldTime(date);
                Logger.api('dateToWorldTime', {
                    date: 'toObject' in date && typeof date.toObject === 'function' ? date.toObject() : date,
                    calendarId,
                }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to convert date to world time', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        worldTimeToDate: (timestamp, calendarId) => {
            try {
                Logger.api('worldTimeToDate', { timestamp, calendarId });
                // Input validation using APIWrapper helpers
                APIWrapper.validateNumber(timestamp, 'Timestamp');
                APIWrapper.validateOptionalString(calendarId, 'Calendar ID');
                const engine = calendarId
                    ? calendarManager.engines?.get(calendarId)
                    : calendarManager.getActiveEngine();
                if (!engine) {
                    throw new Error(`No engine available for calendar: ${calendarId || 'active'}`);
                }
                const result = engine.worldTimeToDate(timestamp);
                Logger.api('worldTimeToDate', { timestamp, calendarId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to convert world time to date', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getActiveCalendar: () => {
            try {
                Logger.api('getActiveCalendar');
                const result = calendarManager.getActiveCalendar();
                Logger.api('getActiveCalendar', undefined, result?.id || 'none');
                return result;
            }
            catch (error) {
                Logger.error('Failed to get active calendar', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        setActiveCalendar: async (calendarId) => {
            try {
                Logger.api('setActiveCalendar', { calendarId });
                // Input validation
                if (typeof calendarId !== 'string' || calendarId.trim() === '') {
                    const error = new Error('Calendar ID must be a non-empty string');
                    Logger.error('Invalid calendar ID parameter', error);
                    throw error;
                }
                await calendarManager.setActiveCalendar(calendarId);
                Logger.api('setActiveCalendar', { calendarId }, 'success');
            }
            catch (error) {
                Logger.error('Failed to set active calendar', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getAvailableCalendars: () => {
            try {
                Logger.api('getAvailableCalendars');
                const calendars = calendarManager.getAvailableCalendars();
                const result = calendars.map(calendar => calendar.id);
                Logger.api('getAvailableCalendars', undefined, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get available calendars', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        loadCalendar: (data) => {
            try {
                Logger.api('loadCalendar', { calendarId: data?.id || 'unknown' });
                // Input validation
                if (!data || typeof data !== 'object') {
                    const error = new Error('Calendar data must be a valid object');
                    Logger.error('Invalid calendar data parameter', error);
                    throw error;
                }
                if (!data.id || typeof data.id !== 'string') {
                    const error = new Error('Calendar data must have a valid id string');
                    Logger.error('Invalid calendar data structure', error);
                    throw error;
                }
                calendarManager.loadCalendar(data);
                Logger.api('loadCalendar', { calendarId: data.id }, 'success');
            }
            catch (error) {
                Logger.error('Failed to load calendar', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        // Calendar metadata methods (required for compatibility bridge)
        getMonthNames: (calendarId) => {
            try {
                Logger.api('getMonthNames', { calendarId });
                // Input validation
                if (calendarId !== undefined && typeof calendarId !== 'string') {
                    const error = new Error('Calendar ID must be a string');
                    Logger.error('Invalid calendar ID parameter', error);
                    throw error;
                }
                const calendar = calendarId
                    ? calendarManager.getCalendar(calendarId)
                    : calendarManager.getActiveCalendar();
                if (!calendar?.months) {
                    Logger.warn(`No months found for calendar: ${calendarId || 'active'}`);
                    return [];
                }
                const result = calendar.months.map(month => month.name);
                Logger.api('getMonthNames', { calendarId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get month names', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getWeekdayNames: (calendarId) => {
            try {
                Logger.api('getWeekdayNames', { calendarId });
                // Input validation
                if (calendarId !== undefined && typeof calendarId !== 'string') {
                    const error = new Error('Calendar ID must be a string');
                    Logger.error('Invalid calendar ID parameter', error);
                    throw error;
                }
                const calendar = calendarId
                    ? calendarManager.getCalendar(calendarId)
                    : calendarManager.getActiveCalendar();
                if (!calendar?.weekdays) {
                    Logger.warn(`No weekdays found for calendar: ${calendarId || 'active'}`);
                    return [];
                }
                const result = calendar.weekdays.map(day => day.name);
                Logger.api('getWeekdayNames', { calendarId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get weekday names', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        // Optional enhanced features (basic implementations)
        getSunriseSunset: (date, calendarId) => {
            try {
                Logger.api('getSunriseSunset', { date, calendarId });
                // Input validation
                if (!date || typeof date !== 'object') {
                    const error = new Error('Date must be a valid ICalendarDate object');
                    Logger.error('Invalid date parameter', error);
                    throw error;
                }
                if (calendarId !== undefined && typeof calendarId !== 'string') {
                    const error = new Error('Calendar ID must be a string');
                    Logger.error('Invalid calendar ID parameter', error);
                    throw error;
                }
                // Basic implementation - can be enhanced with calendar-specific data later
                // For now, return reasonable defaults (6 AM sunrise, 6 PM sunset)
                const result = { sunrise: 6, sunset: 18 };
                Logger.api('getSunriseSunset', { date, calendarId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get sunrise/sunset', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getSeasonInfo: (date, calendarId) => {
            try {
                Logger.api('getSeasonInfo', { date, calendarId });
                // Input validation
                if (!date || typeof date !== 'object') {
                    const error = new Error('Date must be a valid ICalendarDate object');
                    Logger.error('Invalid date parameter', error);
                    throw error;
                }
                if (typeof date.year !== 'number' ||
                    typeof date.month !== 'number' ||
                    typeof date.day !== 'number') {
                    const error = new Error('Date must have valid year, month, and day numbers');
                    Logger.error('Invalid date structure', error);
                    throw error;
                }
                if (calendarId !== undefined && typeof calendarId !== 'string') {
                    const error = new Error('Calendar ID must be a string');
                    Logger.error('Invalid calendar ID parameter', error);
                    throw error;
                }
                const calendar = calendarId
                    ? calendarManager.getCalendar(calendarId)
                    : calendarManager.getActiveCalendar();
                if (!calendar ||
                    !calendar.seasons ||
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    calendar.seasons.length === 0) {
                    // Only log to console once per active calendar to prevent looping warnings
                    if (!hasWarnedAboutMissingSeasons && !calendarId) {
                        Logger.debug(`No seasons found for calendar: ${calendar?.id || 'active'}`);
                        hasWarnedAboutMissingSeasons = true;
                    }
                    const result = { name: 'Unknown', icon: 'none' };
                    Logger.api('getSeasonInfo', { date, calendarId }, result);
                    return result;
                }
                // Basic season detection - find season containing this date
                // This is a simple implementation that can be enhanced later
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const currentSeason = calendar.seasons.find(season => {
                    // Simple logic: match by rough month ranges
                    // This could be enhanced with proper calendar-aware season calculation
                    if (season.startMonth && season.endMonth) {
                        return date.month >= season.startMonth && date.month <= season.endMonth;
                    }
                    return false;
                });
                if (currentSeason) {
                    const result = {
                        name: currentSeason.name,
                        icon: currentSeason.icon || currentSeason.name.toLowerCase(),
                    };
                    Logger.api('getSeasonInfo', { date, calendarId }, result);
                    return result;
                }
                // Fallback: use first season or default
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const fallbackSeason = calendar.seasons[0];
                const result = {
                    name: fallbackSeason?.name || 'Unknown',
                    icon: fallbackSeason?.icon || fallbackSeason?.name?.toLowerCase() || 'none',
                };
                Logger.api('getSeasonInfo', { date, calendarId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get season info', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        // External Calendar Loading Methods
        loadCalendarFromUrl: async (url, options) => {
            return APIWrapper.wrapAPIMethod('loadCalendarFromUrl', { url, options }, params => {
                APIWrapper.validateString(params.url, 'URL');
            }, () => calendarManager.loadCalendarFromUrl(url, options));
        },
        loadCalendarCollection: async (url, options) => {
            return APIWrapper.wrapAPIMethod('loadCalendarCollection', { url, options }, params => {
                APIWrapper.validateString(params.url, 'URL');
            }, () => calendarManager.loadCalendarCollection(url, options));
        },
        addExternalSource: (source) => {
            try {
                Logger.api('addExternalSource', { source });
                if (!source || typeof source !== 'object') {
                    throw new Error('Source must be a valid object');
                }
                APIWrapper.validateString(source.name, 'Source name');
                APIWrapper.validateString(source.url, 'Source URL');
                if (typeof source.enabled !== 'boolean') {
                    throw new Error('Source enabled must be a boolean');
                }
                if (!['calendar', 'collection', 'variants'].includes(source.type)) {
                    throw new Error('Source type must be calendar, collection, or variants');
                }
                const result = calendarManager.addExternalSource(source);
                Logger.api('addExternalSource', { source }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to add external source', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        removeExternalSource: (sourceId) => {
            try {
                Logger.api('removeExternalSource', { sourceId });
                APIWrapper.validateString(sourceId, 'Source ID');
                const result = calendarManager.removeExternalSource(sourceId);
                Logger.api('removeExternalSource', { sourceId }, result);
                return result;
            }
            catch (error) {
                Logger.error('Failed to remove external source', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getExternalSources: () => {
            try {
                Logger.api('getExternalSources');
                const result = calendarManager.getExternalSources();
                Logger.api('getExternalSources', undefined, result.length);
                return result;
            }
            catch (error) {
                Logger.error('Failed to get external sources', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        getExternalSource: (sourceId) => {
            try {
                Logger.api('getExternalSource', { sourceId });
                APIWrapper.validateString(sourceId, 'Source ID');
                const result = calendarManager.getExternalSource(sourceId);
                Logger.api('getExternalSource', { sourceId }, result ? 'found' : 'not found');
                return result;
            }
            catch (error) {
                Logger.error('Failed to get external source', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        refreshExternalCalendar: async (sourceId) => {
            return APIWrapper.wrapAPIMethod('refreshExternalCalendar', { sourceId }, params => {
                APIWrapper.validateString(params.sourceId, 'Source ID');
            }, () => calendarManager.refreshExternalCalendar(sourceId));
        },
        refreshAllExternalCalendars: async () => {
            return APIWrapper.wrapAPIMethod('refreshAllExternalCalendars', {}, () => { }, () => calendarManager.refreshAllExternalCalendars());
        },
        clearExternalCalendarCache: () => {
            try {
                Logger.api('clearExternalCalendarCache');
                calendarManager.clearExternalCalendarCache();
                Logger.api('clearExternalCalendarCache', undefined, 'success');
            }
            catch (error) {
                Logger.error('Failed to clear external calendar cache', error instanceof Error ? error : new Error(String(error)));
                throw error;
            }
        },
        // Module Calendar Loading Methods
        loadModuleCalendars: async (moduleId) => {
            return APIWrapper.wrapAPIMethod('loadModuleCalendars', { moduleId }, params => {
                APIWrapper.validateString(params.moduleId, 'Module ID');
            }, () => calendarManager.loadModuleCalendars(moduleId));
        },
    };
    // Expose API to global game object
    if (game) {
        game.seasonsStars = {
            api,
            manager: calendarManager,
            notes: notesManager,
            categories: noteCategories, // Will be available by this point since ready runs after init
            integration: null, // Will be set after the object is fully created
            compatibilityManager, // Expose for debugging and external access
            // Expose warning state functions for debugging and external access
            resetSeasonsWarningState,
            getSeasonsWarningState,
            setSeasonsWarningState,
        };
        // Set integration after game.seasonsStars is fully assigned
        game.seasonsStars.integration = SeasonsStarsIntegration.detect();
    }
    // Expose API to window for debugging
    window.SeasonsStars = {
        api,
        manager: calendarManager,
        notes: notesManager,
        integration: SeasonsStarsIntegration.detect() || null,
        CalendarWidget,
        CalendarMiniWidget,
        CalendarGridWidget,
        CalendarSelectionDialog,
    };
    Logger.debug('API and bridge integration exposed');
    Logger.debug('Module initialization complete');
}
/**
 * Module cleanup
 */
Hooks.once('destroy', () => {
    Logger.debug('Module shutting down');
    // Clean up global references
    if (game.seasonsStars) {
        delete game.seasonsStars;
    }
    if (window.SeasonsStars) {
        delete window.SeasonsStars;
    }
});
/**
 * Register with Memory Mage module if available
 */
function registerMemoryMageIntegration() {
    try {
        // Check if Memory Mage is available (standard Foundry module pattern)
        const memoryMage = game.memoryMage || game.modules?.get('memory-mage')?.api;
        if (!memoryMage) {
            Logger.debug('Memory Mage not available - skipping memory monitoring integration');
            return;
        }
        Logger.debug('Registering with Memory Mage for memory monitoring');
        // Register self-reporting memory usage
        memoryMage.registerModule('seasons-and-stars', () => {
            const optimizer = notesManager?.getPerformanceOptimizer?.();
            const widgetMemory = calculateWidgetMemory();
            const calendarMemory = calculateCalendarMemory();
            return {
                estimatedMB: (optimizer?.getMemoryUsage() || 0) + widgetMemory + calendarMemory,
                details: {
                    notesCache: optimizer?.getMetrics()?.totalNotes || 0,
                    activeWidgets: getActiveWidgetCount(),
                    loadedCalendars: calendarManager?.getLoadedCalendars?.()?.length || 0,
                    cacheSize: optimizer?.getMetrics()?.cacheHitRate || 0,
                },
            };
        });
        // Register cleanup handler for memory pressure
        memoryMage.registerCleanupHandler?.(() => {
            Logger.info('Memory Mage triggered cleanup: memory pressure detected');
            // Perform memory cleanup
            const optimizer = notesManager?.getPerformanceOptimizer?.();
            if (optimizer) {
                optimizer.relieveMemoryPressure?.();
            }
            // Clear other caches if available
            if (calendarManager?.clearCaches) {
                calendarManager.clearCaches?.();
            }
            // Force close widgets if memory is critically low
            CalendarWidget.closeAll?.();
            CalendarGridWidget.closeAll?.();
        });
        Logger.debug('Memory Mage integration registered successfully');
    }
    catch (error) {
        Logger.warn('Failed to register with Memory Mage - module will continue without memory monitoring:', error);
    }
}
/**
 * Calculate estimated memory usage of active widgets
 */
function calculateWidgetMemory() {
    let memory = 0;
    // Base widget overhead (small)
    const activeWidgets = getActiveWidgetCount();
    memory += activeWidgets * 0.05; // 50KB per widget
    return memory;
}
/**
 * Calculate estimated memory usage of loaded calendars
 */
function calculateCalendarMemory() {
    const loadedCalendars = calendarManager?.getLoadedCalendars?.()?.length || 0;
    return loadedCalendars * 0.02; // 20KB per calendar
}
/**
 * Get count of active widgets
 */
function getActiveWidgetCount() {
    let count = 0;
    if (CalendarWidget.getInstance?.()?.rendered)
        count++;
    if (CalendarMiniWidget.getInstance?.()?.rendered)
        count++;
    if (CalendarGridWidget.getInstance?.()?.rendered)
        count++;
    return count;
}
/**
 * Register hooks to clean up notes when journals are deleted externally
 */
function registerNotesCleanupHooks() {
    // Hook into journal deletion to clean up our notes storage
    Hooks.on('deleteJournalEntry', async (journal, _options, _userId) => {
        Logger.debug('Journal deletion detected', {
            journalId: journal.id,
            journalName: journal.name,
            isCalendarNote: !!journal.flags?.['seasons-and-stars']?.calendarNote,
        });
        try {
            // Check if this was a calendar note
            const flags = journal.flags?.['seasons-and-stars'];
            if (flags?.calendarNote) {
                Logger.info('Calendar note deleted externally, cleaning up storage', {
                    noteId: journal.id,
                    noteName: journal.name,
                });
                // Remove from our storage system
                if (notesManager?.storage) {
                    await notesManager.storage.removeNote(journal.id);
                    Logger.debug('Note removed from storage');
                }
                // Emit our own deletion hook for UI updates
                Hooks.callAll('seasons-stars:noteDeleted', journal.id);
                // Refresh calendar widgets to remove the note from display
                const calendarWidget = CalendarWidget.getInstance?.();
                if (calendarWidget?.rendered) {
                    calendarWidget.render();
                }
                const miniWidget = CalendarMiniWidget.getInstance?.();
                if (miniWidget?.rendered) {
                    miniWidget.render();
                }
                const gridWidget = CalendarGridWidget.getInstance?.();
                if (gridWidget?.rendered) {
                    gridWidget.render();
                }
            }
        }
        catch (error) {
            Logger.error('Failed to clean up deleted calendar note', error instanceof Error ? error : new Error(String(error)));
        }
    });
    Logger.debug('Notes cleanup hooks registered');
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var ajv$3 = {exports: {}};

var core$3 = {};

var validate$1 = {};

var boolSchema$1 = {};

var errors$1 = {};

var codegen$1 = {};

var code$3 = {};

var hasRequiredCode$3;

function requireCode$3 () {
	if (hasRequiredCode$3) return code$3;
	hasRequiredCode$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$3));
	return code$3;
}

var scope$1 = {};

var hasRequiredScope$1;

function requireScope$1 () {
	if (hasRequiredScope$1) return scope$1;
	hasRequiredScope$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$3();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope$1));
	return scope$1;
}

var hasRequiredCodegen$1;

function requireCodegen$1 () {
	if (hasRequiredCodegen$1) return codegen$1;
	hasRequiredCodegen$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$3();
		const scope_1 = requireScope$1();
		var code_2 = requireCode$3();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope$1();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen$1));
	return codegen$1;
}

var util$1 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	Object.defineProperty(util$1, "__esModule", { value: true });
	util$1.checkStrictMode = util$1.getErrorPath = util$1.Type = util$1.useFunc = util$1.setEvaluated = util$1.evaluatedPropsToName = util$1.mergeEvaluated = util$1.eachItem = util$1.unescapeJsonPointer = util$1.escapeJsonPointer = util$1.escapeFragment = util$1.unescapeFragment = util$1.schemaRefOrVal = util$1.schemaHasRulesButRef = util$1.schemaHasRules = util$1.checkUnknownRules = util$1.alwaysValidSchema = util$1.toHash = void 0;
	const codegen_1 = requireCodegen$1();
	const code_1 = requireCode$3();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util$1.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util$1.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util$1.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util$1.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util$1.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util$1.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util$1.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util$1.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util$1.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util$1.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util$1.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util$1.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util$1.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util$1.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util$1.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util$1.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util$1.checkStrictMode = checkStrictMode;
	
	return util$1;
}

var names$1 = {};

var hasRequiredNames$1;

function requireNames$1 () {
	if (hasRequiredNames$1) return names$1;
	hasRequiredNames$1 = 1;
	Object.defineProperty(names$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const names = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names$1.default = names;
	
	return names$1;
}

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen$1();
		const util_1 = requireUtil$1();
		const names_1 = requireNames$1();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors$1));
	return errors$1;
}

var hasRequiredBoolSchema$1;

function requireBoolSchema$1 () {
	if (hasRequiredBoolSchema$1) return boolSchema$1;
	hasRequiredBoolSchema$1 = 1;
	Object.defineProperty(boolSchema$1, "__esModule", { value: true });
	boolSchema$1.boolOrEmptySchema = boolSchema$1.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors$1();
	const codegen_1 = requireCodegen$1();
	const names_1 = requireNames$1();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema$1.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema$1.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema$1;
}

var dataType$1 = {};

var rules$1 = {};

var hasRequiredRules$1;

function requireRules$1 () {
	if (hasRequiredRules$1) return rules$1;
	hasRequiredRules$1 = 1;
	Object.defineProperty(rules$1, "__esModule", { value: true });
	rules$1.getRules = rules$1.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules$1.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules$1.getRules = getRules;
	
	return rules$1;
}

var applicability$1 = {};

var hasRequiredApplicability$1;

function requireApplicability$1 () {
	if (hasRequiredApplicability$1) return applicability$1;
	hasRequiredApplicability$1 = 1;
	Object.defineProperty(applicability$1, "__esModule", { value: true });
	applicability$1.shouldUseRule = applicability$1.shouldUseGroup = applicability$1.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability$1.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability$1.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability$1.shouldUseRule = shouldUseRule;
	
	return applicability$1;
}

var hasRequiredDataType$1;

function requireDataType$1 () {
	if (hasRequiredDataType$1) return dataType$1;
	hasRequiredDataType$1 = 1;
	Object.defineProperty(dataType$1, "__esModule", { value: true });
	dataType$1.reportTypeError = dataType$1.checkDataTypes = dataType$1.checkDataType = dataType$1.coerceAndCheckDataType = dataType$1.getJSONTypes = dataType$1.getSchemaTypes = dataType$1.DataType = void 0;
	const rules_1 = requireRules$1();
	const applicability_1 = requireApplicability$1();
	const errors_1 = requireErrors$1();
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType$1.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType$1.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType$1.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType$1.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType$1.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType$1.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType$1.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType$1;
}

var defaults$1 = {};

var hasRequiredDefaults$1;

function requireDefaults$1 () {
	if (hasRequiredDefaults$1) return defaults$1;
	hasRequiredDefaults$1 = 1;
	Object.defineProperty(defaults$1, "__esModule", { value: true });
	defaults$1.assignDefaults = void 0;
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults$1.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults$1;
}

var keyword$1 = {};

var code$2 = {};

var hasRequiredCode$2;

function requireCode$2 () {
	if (hasRequiredCode$2) return code$2;
	hasRequiredCode$2 = 1;
	Object.defineProperty(code$2, "__esModule", { value: true });
	code$2.validateUnion = code$2.validateArray = code$2.usePattern = code$2.callValidateCode = code$2.schemaProperties = code$2.allSchemaProperties = code$2.noPropertyInData = code$2.propertyInData = code$2.isOwnProperty = code$2.hasPropFunc = code$2.reportMissingProp = code$2.checkMissingProp = code$2.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const names_1 = requireNames$1();
	const util_2 = requireUtil$1();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code$2.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code$2.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code$2.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code$2.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code$2.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code$2.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code$2.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code$2.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code$2.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code$2.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code$2.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code$2.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code$2.validateUnion = validateUnion;
	
	return code$2;
}

var hasRequiredKeyword$1;

function requireKeyword$1 () {
	if (hasRequiredKeyword$1) return keyword$1;
	hasRequiredKeyword$1 = 1;
	Object.defineProperty(keyword$1, "__esModule", { value: true });
	keyword$1.validateKeywordUsage = keyword$1.validSchemaType = keyword$1.funcKeywordCode = keyword$1.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen$1();
	const names_1 = requireNames$1();
	const code_1 = requireCode$2();
	const errors_1 = requireErrors$1();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword$1.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword$1.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword$1.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword$1.validateKeywordUsage = validateKeywordUsage;
	
	return keyword$1;
}

var subschema$1 = {};

var hasRequiredSubschema$1;

function requireSubschema$1 () {
	if (hasRequiredSubschema$1) return subschema$1;
	hasRequiredSubschema$1 = 1;
	Object.defineProperty(subschema$1, "__esModule", { value: true });
	subschema$1.extendSubschemaMode = subschema$1.extendSubschemaData = subschema$1.getSubschema = void 0;
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema$1.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema$1.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema$1.extendSubschemaMode = extendSubschemaMode;
	
	return subschema$1;
}

var resolve$1 = {};

var fastDeepEqual;
var hasRequiredFastDeepEqual;

function requireFastDeepEqual () {
	if (hasRequiredFastDeepEqual) return fastDeepEqual;
	hasRequiredFastDeepEqual = 1;

	// do not edit .js files directly - edit src/index.jst



	fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    if (a.constructor !== b.constructor) return false;

	    var length, i, keys;
	    if (Array.isArray(a)) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }



	    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
	    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
	    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

	    keys = Object.keys(a);
	    length = keys.length;
	    if (length !== Object.keys(b).length) return false;

	    for (i = length; i-- !== 0;)
	      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      var key = keys[i];

	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  // true if both NaN, false otherwise
	  return a!==a && b!==b;
	};
	return fastDeepEqual;
}

var jsonSchemaTraverse$1 = {exports: {}};

var hasRequiredJsonSchemaTraverse$1;

function requireJsonSchemaTraverse$1 () {
	if (hasRequiredJsonSchemaTraverse$1) return jsonSchemaTraverse$1.exports;
	hasRequiredJsonSchemaTraverse$1 = 1;

	var traverse = jsonSchemaTraverse$1.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse$1.exports;
}

var hasRequiredResolve$1;

function requireResolve$1 () {
	if (hasRequiredResolve$1) return resolve$1;
	hasRequiredResolve$1 = 1;
	Object.defineProperty(resolve$1, "__esModule", { value: true });
	resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
	const util_1 = requireUtil$1();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse$1();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve$1.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve$1.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve$1._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve$1.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve$1.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve$1.getSchemaRefs = getSchemaRefs;
	
	return resolve$1;
}

var hasRequiredValidate$1;

function requireValidate$1 () {
	if (hasRequiredValidate$1) return validate$1;
	hasRequiredValidate$1 = 1;
	Object.defineProperty(validate$1, "__esModule", { value: true });
	validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema$1();
	const dataType_1 = requireDataType$1();
	const applicability_1 = requireApplicability$1();
	const dataType_2 = requireDataType$1();
	const defaults_1 = requireDefaults$1();
	const keyword_1 = requireKeyword$1();
	const subschema_1 = requireSubschema$1();
	const codegen_1 = requireCodegen$1();
	const names_1 = requireNames$1();
	const resolve_1 = requireResolve$1();
	const util_1 = requireUtil$1();
	const errors_1 = requireErrors$1();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate$1.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate$1.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate$1.getData = getData;
	
	return validate$1;
}

var validation_error$1 = {};

var hasRequiredValidation_error$1;

function requireValidation_error$1 () {
	if (hasRequiredValidation_error$1) return validation_error$1;
	hasRequiredValidation_error$1 = 1;
	Object.defineProperty(validation_error$1, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error$1.default = ValidationError;
	
	return validation_error$1;
}

var ref_error$1 = {};

var hasRequiredRef_error$1;

function requireRef_error$1 () {
	if (hasRequiredRef_error$1) return ref_error$1;
	hasRequiredRef_error$1 = 1;
	Object.defineProperty(ref_error$1, "__esModule", { value: true });
	const resolve_1 = requireResolve$1();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error$1.default = MissingRefError;
	
	return ref_error$1;
}

var compile$1 = {};

var hasRequiredCompile$1;

function requireCompile$1 () {
	if (hasRequiredCompile$1) return compile$1;
	hasRequiredCompile$1 = 1;
	Object.defineProperty(compile$1, "__esModule", { value: true });
	compile$1.resolveSchema = compile$1.getCompilingSchema = compile$1.resolveRef = compile$1.compileSchema = compile$1.SchemaEnv = void 0;
	const codegen_1 = requireCodegen$1();
	const validation_error_1 = requireValidation_error$1();
	const names_1 = requireNames$1();
	const resolve_1 = requireResolve$1();
	const util_1 = requireUtil$1();
	const validate_1 = requireValidate$1();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile$1.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile$1.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile$1.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile$1.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile$1.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile$1;
}

var $id$3 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description$1 = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$3 = "object";
var required$3 = [
	"$data"
];
var properties$5 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$3 = false;
var require$$9$1 = {
	$id: $id$3,
	description: description$1,
	type: type$3,
	required: required$3,
	properties: properties$5,
	additionalProperties: additionalProperties$3
};

var uri$1 = {};

var fastUri = {exports: {}};

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	/** @type {(value: string) => boolean} */
	const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);

	/** @type {(value: string) => boolean} */
	const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);

	/**
	 * @param {Array<string>} input
	 * @returns {string}
	 */
	function stringArrayToHexStripped (input) {
	  let acc = '';
	  let code = 0;
	  let i = 0;

	  for (i = 0; i < input.length; i++) {
	    code = input[i].charCodeAt(0);
	    if (code === 48) {
	      continue
	    }
	    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {
	      return ''
	    }
	    acc += input[i];
	    break
	  }

	  for (i += 1; i < input.length; i++) {
	    code = input[i].charCodeAt(0);
	    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {
	      return ''
	    }
	    acc += input[i];
	  }
	  return acc
	}

	/**
	 * @typedef {Object} GetIPV6Result
	 * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
	 * @property {string} address - The parsed IPv6 address.
	 * @property {string} [zone] - The zone identifier, if present.
	 */

	/**
	 * @param {string} value
	 * @returns {boolean}
	 */
	const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);

	/**
	 * @param {Array<string>} buffer
	 * @returns {boolean}
	 */
	function consumeIsZone (buffer) {
	  buffer.length = 0;
	  return true
	}

	/**
	 * @param {Array<string>} buffer
	 * @param {Array<string>} address
	 * @param {GetIPV6Result} output
	 * @returns {boolean}
	 */
	function consumeHextets (buffer, address, output) {
	  if (buffer.length) {
	    const hex = stringArrayToHexStripped(buffer);
	    if (hex !== '') {
	      address.push(hex);
	    } else {
	      output.error = true;
	      return false
	    }
	    buffer.length = 0;
	  }
	  return true
	}

	/**
	 * @param {string} input
	 * @returns {GetIPV6Result}
	 */
	function getIPV6 (input) {
	  let tokenCount = 0;
	  const output = { error: false, address: '', zone: '' };
	  /** @type {Array<string>} */
	  const address = [];
	  /** @type {Array<string>} */
	  const buffer = [];
	  let endipv6Encountered = false;
	  let endIpv6 = false;

	  let consume = consumeHextets;

	  for (let i = 0; i < input.length; i++) {
	    const cursor = input[i];
	    if (cursor === '[' || cursor === ']') { continue }
	    if (cursor === ':') {
	      if (endipv6Encountered === true) {
	        endIpv6 = true;
	      }
	      if (!consume(buffer, address, output)) { break }
	      if (++tokenCount > 7) {
	        // not valid
	        output.error = true;
	        break
	      }
	      if (i > 0 && input[i - 1] === ':') {
	        endipv6Encountered = true;
	      }
	      address.push(':');
	      continue
	    } else if (cursor === '%') {
	      if (!consume(buffer, address, output)) { break }
	      // switch to zone detection
	      consume = consumeIsZone;
	    } else {
	      buffer.push(cursor);
	      continue
	    }
	  }
	  if (buffer.length) {
	    if (consume === consumeIsZone) {
	      output.zone = buffer.join('');
	    } else if (endIpv6) {
	      address.push(buffer.join(''));
	    } else {
	      address.push(stringArrayToHexStripped(buffer));
	    }
	  }
	  output.address = address.join('');
	  return output
	}

	/**
	 * @typedef {Object} NormalizeIPv6Result
	 * @property {string} host - The normalized host.
	 * @property {string} [escapedHost] - The escaped host.
	 * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
	 */

	/**
	 * @param {string} host
	 * @returns {NormalizeIPv6Result}
	 */
	function normalizeIPv6 (host) {
	  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }
	  const ipv6 = getIPV6(host);

	  if (!ipv6.error) {
	    let newHost = ipv6.address;
	    let escapedHost = ipv6.address;
	    if (ipv6.zone) {
	      newHost += '%' + ipv6.zone;
	      escapedHost += '%25' + ipv6.zone;
	    }
	    return { host: newHost, isIPV6: true, escapedHost }
	  } else {
	    return { host, isIPV6: false }
	  }
	}

	/**
	 * @param {string} str
	 * @param {string} token
	 * @returns {number}
	 */
	function findToken (str, token) {
	  let ind = 0;
	  for (let i = 0; i < str.length; i++) {
	    if (str[i] === token) ind++;
	  }
	  return ind
	}

	/**
	 * @param {string} path
	 * @returns {string}
	 *
	 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
	 */
	function removeDotSegments (path) {
	  let input = path;
	  const output = [];
	  let nextSlash = -1;
	  let len = 0;

	  // eslint-disable-next-line no-cond-assign
	  while (len = input.length) {
	    if (len === 1) {
	      if (input === '.') {
	        break
	      } else if (input === '/') {
	        output.push('/');
	        break
	      } else {
	        output.push(input);
	        break
	      }
	    } else if (len === 2) {
	      if (input[0] === '.') {
	        if (input[1] === '.') {
	          break
	        } else if (input[1] === '/') {
	          input = input.slice(2);
	          continue
	        }
	      } else if (input[0] === '/') {
	        if (input[1] === '.' || input[1] === '/') {
	          output.push('/');
	          break
	        }
	      }
	    } else if (len === 3) {
	      if (input === '/..') {
	        if (output.length !== 0) {
	          output.pop();
	        }
	        output.push('/');
	        break
	      }
	    }
	    if (input[0] === '.') {
	      if (input[1] === '.') {
	        if (input[2] === '/') {
	          input = input.slice(3);
	          continue
	        }
	      } else if (input[1] === '/') {
	        input = input.slice(2);
	        continue
	      }
	    } else if (input[0] === '/') {
	      if (input[1] === '.') {
	        if (input[2] === '/') {
	          input = input.slice(2);
	          continue
	        } else if (input[2] === '.') {
	          if (input[3] === '/') {
	            input = input.slice(3);
	            if (output.length !== 0) {
	              output.pop();
	            }
	            continue
	          }
	        }
	      }
	    }

	    // Rule 2E: Move normal path segment to output
	    if ((nextSlash = input.indexOf('/', 1)) === -1) {
	      output.push(input);
	      break
	    } else {
	      output.push(input.slice(0, nextSlash));
	      input = input.slice(nextSlash);
	    }
	  }

	  return output.join('')
	}

	/**
	 * @param {import('../types/index').URIComponent} component
	 * @param {boolean} esc
	 * @returns {import('../types/index').URIComponent}
	 */
	function normalizeComponentEncoding (component, esc) {
	  const func = esc !== true ? escape : unescape;
	  if (component.scheme !== undefined) {
	    component.scheme = func(component.scheme);
	  }
	  if (component.userinfo !== undefined) {
	    component.userinfo = func(component.userinfo);
	  }
	  if (component.host !== undefined) {
	    component.host = func(component.host);
	  }
	  if (component.path !== undefined) {
	    component.path = func(component.path);
	  }
	  if (component.query !== undefined) {
	    component.query = func(component.query);
	  }
	  if (component.fragment !== undefined) {
	    component.fragment = func(component.fragment);
	  }
	  return component
	}

	/**
	 * @param {import('../types/index').URIComponent} component
	 * @returns {string|undefined}
	 */
	function recomposeAuthority (component) {
	  const uriTokens = [];

	  if (component.userinfo !== undefined) {
	    uriTokens.push(component.userinfo);
	    uriTokens.push('@');
	  }

	  if (component.host !== undefined) {
	    let host = unescape(component.host);
	    if (!isIPv4(host)) {
	      const ipV6res = normalizeIPv6(host);
	      if (ipV6res.isIPV6 === true) {
	        host = `[${ipV6res.escapedHost}]`;
	      } else {
	        host = component.host;
	      }
	    }
	    uriTokens.push(host);
	  }

	  if (typeof component.port === 'number' || typeof component.port === 'string') {
	    uriTokens.push(':');
	    uriTokens.push(String(component.port));
	  }

	  return uriTokens.length ? uriTokens.join('') : undefined
	}
	utils = {
	  nonSimpleDomain,
	  recomposeAuthority,
	  normalizeComponentEncoding,
	  removeDotSegments,
	  isIPv4,
	  isUUID,
	  normalizeIPv6,
	  stringArrayToHexStripped
	};
	return utils;
}

var schemes;
var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;

	const { isUUID } = requireUtils();
	const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;

	const supportedSchemeNames = /** @type {const} */ (['http', 'https', 'ws',
	  'wss', 'urn', 'urn:uuid']);

	/** @typedef {supportedSchemeNames[number]} SchemeName */

	/**
	 * @param {string} name
	 * @returns {name is SchemeName}
	 */
	function isValidSchemeName (name) {
	  return supportedSchemeNames.indexOf(/** @type {*} */ (name)) !== -1
	}

	/**
	 * @callback SchemeFn
	 * @param {import('../types/index').URIComponent} component
	 * @param {import('../types/index').Options} options
	 * @returns {import('../types/index').URIComponent}
	 */

	/**
	 * @typedef {Object} SchemeHandler
	 * @property {SchemeName} scheme - The scheme name.
	 * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
	 * @property {SchemeFn} parse - Function to parse the URI component for this scheme.
	 * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
	 * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
	 * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
	 * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
	 */

	/**
	 * @param {import('../types/index').URIComponent} wsComponent
	 * @returns {boolean}
	 */
	function wsIsSecure (wsComponent) {
	  if (wsComponent.secure === true) {
	    return true
	  } else if (wsComponent.secure === false) {
	    return false
	  } else if (wsComponent.scheme) {
	    return (
	      wsComponent.scheme.length === 3 &&
	      (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') &&
	      (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') &&
	      (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S')
	    )
	  } else {
	    return false
	  }
	}

	/** @type {SchemeFn} */
	function httpParse (component) {
	  if (!component.host) {
	    component.error = component.error || 'HTTP URIs must have a host.';
	  }

	  return component
	}

	/** @type {SchemeFn} */
	function httpSerialize (component) {
	  const secure = String(component.scheme).toLowerCase() === 'https';

	  // normalize the default port
	  if (component.port === (secure ? 443 : 80) || component.port === '') {
	    component.port = undefined;
	  }

	  // normalize the empty path
	  if (!component.path) {
	    component.path = '/';
	  }

	  // NOTE: We do not parse query strings for HTTP URIs
	  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
	  // and not the HTTP spec.

	  return component
	}

	/** @type {SchemeFn} */
	function wsParse (wsComponent) {
	// indicate if the secure flag is set
	  wsComponent.secure = wsIsSecure(wsComponent);

	  // construct resouce name
	  wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '');
	  wsComponent.path = undefined;
	  wsComponent.query = undefined;

	  return wsComponent
	}

	/** @type {SchemeFn} */
	function wsSerialize (wsComponent) {
	// normalize the default port
	  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {
	    wsComponent.port = undefined;
	  }

	  // ensure scheme matches secure flag
	  if (typeof wsComponent.secure === 'boolean') {
	    wsComponent.scheme = (wsComponent.secure ? 'wss' : 'ws');
	    wsComponent.secure = undefined;
	  }

	  // reconstruct path from resource name
	  if (wsComponent.resourceName) {
	    const [path, query] = wsComponent.resourceName.split('?');
	    wsComponent.path = (path && path !== '/' ? path : undefined);
	    wsComponent.query = query;
	    wsComponent.resourceName = undefined;
	  }

	  // forbid fragment component
	  wsComponent.fragment = undefined;

	  return wsComponent
	}

	/** @type {SchemeFn} */
	function urnParse (urnComponent, options) {
	  if (!urnComponent.path) {
	    urnComponent.error = 'URN can not be parsed';
	    return urnComponent
	  }
	  const matches = urnComponent.path.match(URN_REG);
	  if (matches) {
	    const scheme = options.scheme || urnComponent.scheme || 'urn';
	    urnComponent.nid = matches[1].toLowerCase();
	    urnComponent.nss = matches[2];
	    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
	    const schemeHandler = getSchemeHandler(urnScheme);
	    urnComponent.path = undefined;

	    if (schemeHandler) {
	      urnComponent = schemeHandler.parse(urnComponent, options);
	    }
	  } else {
	    urnComponent.error = urnComponent.error || 'URN can not be parsed.';
	  }

	  return urnComponent
	}

	/** @type {SchemeFn} */
	function urnSerialize (urnComponent, options) {
	  if (urnComponent.nid === undefined) {
	    throw new Error('URN without nid cannot be serialized')
	  }
	  const scheme = options.scheme || urnComponent.scheme || 'urn';
	  const nid = urnComponent.nid.toLowerCase();
	  const urnScheme = `${scheme}:${options.nid || nid}`;
	  const schemeHandler = getSchemeHandler(urnScheme);

	  if (schemeHandler) {
	    urnComponent = schemeHandler.serialize(urnComponent, options);
	  }

	  const uriComponent = urnComponent;
	  const nss = urnComponent.nss;
	  uriComponent.path = `${nid || options.nid}:${nss}`;

	  options.skipEscape = true;
	  return uriComponent
	}

	/** @type {SchemeFn} */
	function urnuuidParse (urnComponent, options) {
	  const uuidComponent = urnComponent;
	  uuidComponent.uuid = uuidComponent.nss;
	  uuidComponent.nss = undefined;

	  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
	    uuidComponent.error = uuidComponent.error || 'UUID is not valid.';
	  }

	  return uuidComponent
	}

	/** @type {SchemeFn} */
	function urnuuidSerialize (uuidComponent) {
	  const urnComponent = uuidComponent;
	  // normalize UUID
	  urnComponent.nss = (uuidComponent.uuid || '').toLowerCase();
	  return urnComponent
	}

	const http = /** @type {SchemeHandler} */ ({
	  scheme: 'http',
	  domainHost: true,
	  parse: httpParse,
	  serialize: httpSerialize
	});

	const https = /** @type {SchemeHandler} */ ({
	  scheme: 'https',
	  domainHost: http.domainHost,
	  parse: httpParse,
	  serialize: httpSerialize
	});

	const ws = /** @type {SchemeHandler} */ ({
	  scheme: 'ws',
	  domainHost: true,
	  parse: wsParse,
	  serialize: wsSerialize
	});

	const wss = /** @type {SchemeHandler} */ ({
	  scheme: 'wss',
	  domainHost: ws.domainHost,
	  parse: ws.parse,
	  serialize: ws.serialize
	});

	const urn = /** @type {SchemeHandler} */ ({
	  scheme: 'urn',
	  parse: urnParse,
	  serialize: urnSerialize,
	  skipNormalize: true
	});

	const urnuuid = /** @type {SchemeHandler} */ ({
	  scheme: 'urn:uuid',
	  parse: urnuuidParse,
	  serialize: urnuuidSerialize,
	  skipNormalize: true
	});

	const SCHEMES = /** @type {Record<SchemeName, SchemeHandler>} */ ({
	  http,
	  https,
	  ws,
	  wss,
	  urn,
	  'urn:uuid': urnuuid
	});

	Object.setPrototypeOf(SCHEMES, null);

	/**
	 * @param {string|undefined} scheme
	 * @returns {SchemeHandler|undefined}
	 */
	function getSchemeHandler (scheme) {
	  return (
	    scheme && (
	      SCHEMES[/** @type {SchemeName} */ (scheme)] ||
	      SCHEMES[/** @type {SchemeName} */(scheme.toLowerCase())])
	  ) ||
	    undefined
	}

	schemes = {
	  wsIsSecure,
	  SCHEMES,
	  isValidSchemeName,
	  getSchemeHandler,
	};
	return schemes;
}

var hasRequiredFastUri;

function requireFastUri () {
	if (hasRequiredFastUri) return fastUri.exports;
	hasRequiredFastUri = 1;

	const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = requireUtils();
	const { SCHEMES, getSchemeHandler } = requireSchemes();

	/**
	 * @template {import('./types/index').URIComponent|string} T
	 * @param {T} uri
	 * @param {import('./types/index').Options} [options]
	 * @returns {T}
	 */
	function normalize (uri, options) {
	  if (typeof uri === 'string') {
	    uri = /** @type {T} */ (serialize(parse(uri, options), options));
	  } else if (typeof uri === 'object') {
	    uri = /** @type {T} */ (parse(serialize(uri, options), options));
	  }
	  return uri
	}

	/**
	 * @param {string} baseURI
	 * @param {string} relativeURI
	 * @param {import('./types/index').Options} [options]
	 * @returns {string}
	 */
	function resolve (baseURI, relativeURI, options) {
	  const schemelessOptions = options ? Object.assign({ scheme: 'null' }, options) : { scheme: 'null' };
	  const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
	  schemelessOptions.skipEscape = true;
	  return serialize(resolved, schemelessOptions)
	}

	/**
	 * @param {import ('./types/index').URIComponent} base
	 * @param {import ('./types/index').URIComponent} relative
	 * @param {import('./types/index').Options} [options]
	 * @param {boolean} [skipNormalization=false]
	 * @returns {import ('./types/index').URIComponent}
	 */
	function resolveComponent (base, relative, options, skipNormalization) {
	  /** @type {import('./types/index').URIComponent} */
	  const target = {};
	  if (!skipNormalization) {
	    base = parse(serialize(base, options), options); // normalize base component
	    relative = parse(serialize(relative, options), options); // normalize relative component
	  }
	  options = options || {};

	  if (!options.tolerant && relative.scheme) {
	    target.scheme = relative.scheme;
	    // target.authority = relative.authority;
	    target.userinfo = relative.userinfo;
	    target.host = relative.host;
	    target.port = relative.port;
	    target.path = removeDotSegments(relative.path || '');
	    target.query = relative.query;
	  } else {
	    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
	      // target.authority = relative.authority;
	      target.userinfo = relative.userinfo;
	      target.host = relative.host;
	      target.port = relative.port;
	      target.path = removeDotSegments(relative.path || '');
	      target.query = relative.query;
	    } else {
	      if (!relative.path) {
	        target.path = base.path;
	        if (relative.query !== undefined) {
	          target.query = relative.query;
	        } else {
	          target.query = base.query;
	        }
	      } else {
	        if (relative.path[0] === '/') {
	          target.path = removeDotSegments(relative.path);
	        } else {
	          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
	            target.path = '/' + relative.path;
	          } else if (!base.path) {
	            target.path = relative.path;
	          } else {
	            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
	          }
	          target.path = removeDotSegments(target.path);
	        }
	        target.query = relative.query;
	      }
	      // target.authority = base.authority;
	      target.userinfo = base.userinfo;
	      target.host = base.host;
	      target.port = base.port;
	    }
	    target.scheme = base.scheme;
	  }

	  target.fragment = relative.fragment;

	  return target
	}

	/**
	 * @param {import ('./types/index').URIComponent|string} uriA
	 * @param {import ('./types/index').URIComponent|string} uriB
	 * @param {import ('./types/index').Options} options
	 * @returns {boolean}
	 */
	function equal (uriA, uriB, options) {
	  if (typeof uriA === 'string') {
	    uriA = unescape(uriA);
	    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriA === 'object') {
	    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
	  }

	  if (typeof uriB === 'string') {
	    uriB = unescape(uriB);
	    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
	  } else if (typeof uriB === 'object') {
	    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
	  }

	  return uriA.toLowerCase() === uriB.toLowerCase()
	}

	/**
	 * @param {Readonly<import('./types/index').URIComponent>} cmpts
	 * @param {import('./types/index').Options} [opts]
	 * @returns {string}
	 */
	function serialize (cmpts, opts) {
	  const component = {
	    host: cmpts.host,
	    scheme: cmpts.scheme,
	    userinfo: cmpts.userinfo,
	    port: cmpts.port,
	    path: cmpts.path,
	    query: cmpts.query,
	    nid: cmpts.nid,
	    nss: cmpts.nss,
	    uuid: cmpts.uuid,
	    fragment: cmpts.fragment,
	    reference: cmpts.reference,
	    resourceName: cmpts.resourceName,
	    secure: cmpts.secure,
	    error: ''
	  };
	  const options = Object.assign({}, opts);
	  const uriTokens = [];

	  // find scheme handler
	  const schemeHandler = getSchemeHandler(options.scheme || component.scheme);

	  // perform scheme specific serialization
	  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);

	  if (component.path !== undefined) {
	    if (!options.skipEscape) {
	      component.path = escape(component.path);

	      if (component.scheme !== undefined) {
	        component.path = component.path.split('%3A').join(':');
	      }
	    } else {
	      component.path = unescape(component.path);
	    }
	  }

	  if (options.reference !== 'suffix' && component.scheme) {
	    uriTokens.push(component.scheme, ':');
	  }

	  const authority = recomposeAuthority(component);
	  if (authority !== undefined) {
	    if (options.reference !== 'suffix') {
	      uriTokens.push('//');
	    }

	    uriTokens.push(authority);

	    if (component.path && component.path[0] !== '/') {
	      uriTokens.push('/');
	    }
	  }
	  if (component.path !== undefined) {
	    let s = component.path;

	    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
	      s = removeDotSegments(s);
	    }

	    if (
	      authority === undefined &&
	      s[0] === '/' &&
	      s[1] === '/'
	    ) {
	      // don't allow the path to start with "//"
	      s = '/%2F' + s.slice(2);
	    }

	    uriTokens.push(s);
	  }

	  if (component.query !== undefined) {
	    uriTokens.push('?', component.query);
	  }

	  if (component.fragment !== undefined) {
	    uriTokens.push('#', component.fragment);
	  }
	  return uriTokens.join('')
	}

	const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;

	/**
	 * @param {string} uri
	 * @param {import('./types/index').Options} [opts]
	 * @returns
	 */
	function parse (uri, opts) {
	  const options = Object.assign({}, opts);
	  /** @type {import('./types/index').URIComponent} */
	  const parsed = {
	    scheme: undefined,
	    userinfo: undefined,
	    host: '',
	    port: undefined,
	    path: '',
	    query: undefined,
	    fragment: undefined
	  };

	  let isIP = false;
	  if (options.reference === 'suffix') {
	    if (options.scheme) {
	      uri = options.scheme + ':' + uri;
	    } else {
	      uri = '//' + uri;
	    }
	  }

	  const matches = uri.match(URI_PARSE);

	  if (matches) {
	    // store each component
	    parsed.scheme = matches[1];
	    parsed.userinfo = matches[3];
	    parsed.host = matches[4];
	    parsed.port = parseInt(matches[5], 10);
	    parsed.path = matches[6] || '';
	    parsed.query = matches[7];
	    parsed.fragment = matches[8];

	    // fix port number
	    if (isNaN(parsed.port)) {
	      parsed.port = matches[5];
	    }
	    if (parsed.host) {
	      const ipv4result = isIPv4(parsed.host);
	      if (ipv4result === false) {
	        const ipv6result = normalizeIPv6(parsed.host);
	        parsed.host = ipv6result.host.toLowerCase();
	        isIP = ipv6result.isIPV6;
	      } else {
	        isIP = true;
	      }
	    }
	    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
	      parsed.reference = 'same-document';
	    } else if (parsed.scheme === undefined) {
	      parsed.reference = 'relative';
	    } else if (parsed.fragment === undefined) {
	      parsed.reference = 'absolute';
	    } else {
	      parsed.reference = 'uri';
	    }

	    // check for reference errors
	    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
	      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
	    }

	    // find scheme handler
	    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);

	    // check if scheme can't handle IRIs
	    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
	      // if host component is a domain name
	      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {
	        // convert Unicode IDN -> ASCII IDN
	        try {
	          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
	        } catch (e) {
	          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
	        }
	      }
	      // convert IRI -> URI
	    }

	    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {
	      if (uri.indexOf('%') !== -1) {
	        if (parsed.scheme !== undefined) {
	          parsed.scheme = unescape(parsed.scheme);
	        }
	        if (parsed.host !== undefined) {
	          parsed.host = unescape(parsed.host);
	        }
	      }
	      if (parsed.path) {
	        parsed.path = escape(unescape(parsed.path));
	      }
	      if (parsed.fragment) {
	        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
	      }
	    }

	    // perform scheme specific parsing
	    if (schemeHandler && schemeHandler.parse) {
	      schemeHandler.parse(parsed, options);
	    }
	  } else {
	    parsed.error = parsed.error || 'URI can not be parsed.';
	  }
	  return parsed
	}

	const fastUri$1 = {
	  SCHEMES,
	  normalize,
	  resolve,
	  resolveComponent,
	  equal,
	  serialize,
	  parse
	};

	fastUri.exports = fastUri$1;
	fastUri.exports.default = fastUri$1;
	fastUri.exports.fastUri = fastUri$1;
	return fastUri.exports;
}

var hasRequiredUri$1;

function requireUri$1 () {
	if (hasRequiredUri$1) return uri$1;
	hasRequiredUri$1 = 1;
	Object.defineProperty(uri$1, "__esModule", { value: true });
	const uri = requireFastUri();
	uri.code = 'require("ajv/dist/runtime/uri").default';
	uri$1.default = uri;
	
	return uri$1;
}

var hasRequiredCore$3;

function requireCore$3 () {
	if (hasRequiredCore$3) return core$3;
	hasRequiredCore$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate$1();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error$1();
		const ref_error_1 = requireRef_error$1();
		const rules_1 = requireRules$1();
		const compile_1 = requireCompile$1();
		const codegen_2 = requireCodegen$1();
		const resolve_1 = requireResolve$1();
		const dataType_1 = requireDataType$1();
		const util_1 = requireUtil$1();
		const $dataRefSchema = require$$9$1;
		const uri_1 = requireUri$1();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$3));
	return core$3;
}

var draft7$1 = {};

var core$2 = {};

var id$1 = {};

var hasRequiredId$1;

function requireId$1 () {
	if (hasRequiredId$1) return id$1;
	hasRequiredId$1 = 1;
	Object.defineProperty(id$1, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id$1.default = def;
	
	return id$1;
}

var ref$1 = {};

var hasRequiredRef$1;

function requireRef$1 () {
	if (hasRequiredRef$1) return ref$1;
	hasRequiredRef$1 = 1;
	Object.defineProperty(ref$1, "__esModule", { value: true });
	ref$1.callRef = ref$1.getValidate = void 0;
	const ref_error_1 = requireRef_error$1();
	const code_1 = requireCode$2();
	const codegen_1 = requireCodegen$1();
	const names_1 = requireNames$1();
	const compile_1 = requireCompile$1();
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref$1.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref$1.callRef = callRef;
	ref$1.default = def;
	
	return ref$1;
}

var hasRequiredCore$2;

function requireCore$2 () {
	if (hasRequiredCore$2) return core$2;
	hasRequiredCore$2 = 1;
	Object.defineProperty(core$2, "__esModule", { value: true });
	const id_1 = requireId$1();
	const ref_1 = requireRef$1();
	const core = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core$2.default = core;
	
	return core$2;
}

var validation$1 = {};

var limitNumber$1 = {};

var hasRequiredLimitNumber$1;

function requireLimitNumber$1 () {
	if (hasRequiredLimitNumber$1) return limitNumber$1;
	hasRequiredLimitNumber$1 = 1;
	Object.defineProperty(limitNumber$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber$1.default = def;
	
	return limitNumber$1;
}

var multipleOf$1 = {};

var hasRequiredMultipleOf$1;

function requireMultipleOf$1 () {
	if (hasRequiredMultipleOf$1) return multipleOf$1;
	hasRequiredMultipleOf$1 = 1;
	Object.defineProperty(multipleOf$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf$1.default = def;
	
	return multipleOf$1;
}

var limitLength$1 = {};

var ucs2length$1 = {};

var hasRequiredUcs2length$1;

function requireUcs2length$1 () {
	if (hasRequiredUcs2length$1) return ucs2length$1;
	hasRequiredUcs2length$1 = 1;
	Object.defineProperty(ucs2length$1, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length$1.default = ucs2length;
	ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length$1;
}

var hasRequiredLimitLength$1;

function requireLimitLength$1 () {
	if (hasRequiredLimitLength$1) return limitLength$1;
	hasRequiredLimitLength$1 = 1;
	Object.defineProperty(limitLength$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const ucs2length_1 = requireUcs2length$1();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength$1.default = def;
	
	return limitLength$1;
}

var pattern$1 = {};

var hasRequiredPattern$1;

function requirePattern$1 () {
	if (hasRequiredPattern$1) return pattern$1;
	hasRequiredPattern$1 = 1;
	Object.defineProperty(pattern$1, "__esModule", { value: true });
	const code_1 = requireCode$2();
	const codegen_1 = requireCodegen$1();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern$1.default = def;
	
	return pattern$1;
}

var limitProperties$1 = {};

var hasRequiredLimitProperties$1;

function requireLimitProperties$1 () {
	if (hasRequiredLimitProperties$1) return limitProperties$1;
	hasRequiredLimitProperties$1 = 1;
	Object.defineProperty(limitProperties$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties$1.default = def;
	
	return limitProperties$1;
}

var required$2 = {};

var hasRequiredRequired$1;

function requireRequired$1 () {
	if (hasRequiredRequired$1) return required$2;
	hasRequiredRequired$1 = 1;
	Object.defineProperty(required$2, "__esModule", { value: true });
	const code_1 = requireCode$2();
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required$2.default = def;
	
	return required$2;
}

var limitItems$1 = {};

var hasRequiredLimitItems$1;

function requireLimitItems$1 () {
	if (hasRequiredLimitItems$1) return limitItems$1;
	hasRequiredLimitItems$1 = 1;
	Object.defineProperty(limitItems$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems$1.default = def;
	
	return limitItems$1;
}

var uniqueItems$1 = {};

var equal$1 = {};

var hasRequiredEqual$1;

function requireEqual$1 () {
	if (hasRequiredEqual$1) return equal$1;
	hasRequiredEqual$1 = 1;
	Object.defineProperty(equal$1, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal = requireFastDeepEqual();
	equal.code = 'require("ajv/dist/runtime/equal").default';
	equal$1.default = equal;
	
	return equal$1;
}

var hasRequiredUniqueItems$1;

function requireUniqueItems$1 () {
	if (hasRequiredUniqueItems$1) return uniqueItems$1;
	hasRequiredUniqueItems$1 = 1;
	Object.defineProperty(uniqueItems$1, "__esModule", { value: true });
	const dataType_1 = requireDataType$1();
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual$1();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems$1.default = def;
	
	return uniqueItems$1;
}

var _const$1 = {};

var hasRequired_const$1;

function require_const$1 () {
	if (hasRequired_const$1) return _const$1;
	hasRequired_const$1 = 1;
	Object.defineProperty(_const$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual$1();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const$1.default = def;
	
	return _const$1;
}

var _enum$1 = {};

var hasRequired_enum$1;

function require_enum$1 () {
	if (hasRequired_enum$1) return _enum$1;
	hasRequired_enum$1 = 1;
	Object.defineProperty(_enum$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const equal_1 = requireEqual$1();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum$1.default = def;
	
	return _enum$1;
}

var hasRequiredValidation$1;

function requireValidation$1 () {
	if (hasRequiredValidation$1) return validation$1;
	hasRequiredValidation$1 = 1;
	Object.defineProperty(validation$1, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber$1();
	const multipleOf_1 = requireMultipleOf$1();
	const limitLength_1 = requireLimitLength$1();
	const pattern_1 = requirePattern$1();
	const limitProperties_1 = requireLimitProperties$1();
	const required_1 = requireRequired$1();
	const limitItems_1 = requireLimitItems$1();
	const uniqueItems_1 = requireUniqueItems$1();
	const const_1 = require_const$1();
	const enum_1 = require_enum$1();
	const validation = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation$1.default = validation;
	
	return validation$1;
}

var applicator$1 = {};

var additionalItems$1 = {};

var hasRequiredAdditionalItems$1;

function requireAdditionalItems$1 () {
	if (hasRequiredAdditionalItems$1) return additionalItems$1;
	hasRequiredAdditionalItems$1 = 1;
	Object.defineProperty(additionalItems$1, "__esModule", { value: true });
	additionalItems$1.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems$1.validateAdditionalItems = validateAdditionalItems;
	additionalItems$1.default = def;
	
	return additionalItems$1;
}

var prefixItems$1 = {};

var items$1 = {};

var hasRequiredItems$1;

function requireItems$1 () {
	if (hasRequiredItems$1) return items$1;
	hasRequiredItems$1 = 1;
	Object.defineProperty(items$1, "__esModule", { value: true });
	items$1.validateTuple = void 0;
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const code_1 = requireCode$2();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items$1.validateTuple = validateTuple;
	items$1.default = def;
	
	return items$1;
}

var hasRequiredPrefixItems$1;

function requirePrefixItems$1 () {
	if (hasRequiredPrefixItems$1) return prefixItems$1;
	hasRequiredPrefixItems$1 = 1;
	Object.defineProperty(prefixItems$1, "__esModule", { value: true });
	const items_1 = requireItems$1();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems$1.default = def;
	
	return prefixItems$1;
}

var items2020$1 = {};

var hasRequiredItems2020$1;

function requireItems2020$1 () {
	if (hasRequiredItems2020$1) return items2020$1;
	hasRequiredItems2020$1 = 1;
	Object.defineProperty(items2020$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const code_1 = requireCode$2();
	const additionalItems_1 = requireAdditionalItems$1();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020$1.default = def;
	
	return items2020$1;
}

var contains$1 = {};

var hasRequiredContains$1;

function requireContains$1 () {
	if (hasRequiredContains$1) return contains$1;
	hasRequiredContains$1 = 1;
	Object.defineProperty(contains$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains$1.default = def;
	
	return contains$1;
}

var dependencies$1 = {};

var hasRequiredDependencies$1;

function requireDependencies$1 () {
	if (hasRequiredDependencies$1) return dependencies$1;
	hasRequiredDependencies$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen$1();
		const util_1 = requireUtil$1();
		const code_1 = requireCode$2();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies$1));
	return dependencies$1;
}

var propertyNames$1 = {};

var hasRequiredPropertyNames$1;

function requirePropertyNames$1 () {
	if (hasRequiredPropertyNames$1) return propertyNames$1;
	hasRequiredPropertyNames$1 = 1;
	Object.defineProperty(propertyNames$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames$1.default = def;
	
	return propertyNames$1;
}

var additionalProperties$2 = {};

var hasRequiredAdditionalProperties$1;

function requireAdditionalProperties$1 () {
	if (hasRequiredAdditionalProperties$1) return additionalProperties$2;
	hasRequiredAdditionalProperties$1 = 1;
	Object.defineProperty(additionalProperties$2, "__esModule", { value: true });
	const code_1 = requireCode$2();
	const codegen_1 = requireCodegen$1();
	const names_1 = requireNames$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties$2.default = def;
	
	return additionalProperties$2;
}

var properties$4 = {};

var hasRequiredProperties$1;

function requireProperties$1 () {
	if (hasRequiredProperties$1) return properties$4;
	hasRequiredProperties$1 = 1;
	Object.defineProperty(properties$4, "__esModule", { value: true });
	const validate_1 = requireValidate$1();
	const code_1 = requireCode$2();
	const util_1 = requireUtil$1();
	const additionalProperties_1 = requireAdditionalProperties$1();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$4.default = def;
	
	return properties$4;
}

var patternProperties$1 = {};

var hasRequiredPatternProperties$1;

function requirePatternProperties$1 () {
	if (hasRequiredPatternProperties$1) return patternProperties$1;
	hasRequiredPatternProperties$1 = 1;
	Object.defineProperty(patternProperties$1, "__esModule", { value: true });
	const code_1 = requireCode$2();
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const util_2 = requireUtil$1();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties$1.default = def;
	
	return patternProperties$1;
}

var not$1 = {};

var hasRequiredNot$1;

function requireNot$1 () {
	if (hasRequiredNot$1) return not$1;
	hasRequiredNot$1 = 1;
	Object.defineProperty(not$1, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not$1.default = def;
	
	return not$1;
}

var anyOf$1 = {};

var hasRequiredAnyOf$1;

function requireAnyOf$1 () {
	if (hasRequiredAnyOf$1) return anyOf$1;
	hasRequiredAnyOf$1 = 1;
	Object.defineProperty(anyOf$1, "__esModule", { value: true });
	const code_1 = requireCode$2();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf$1.default = def;
	
	return anyOf$1;
}

var oneOf$1 = {};

var hasRequiredOneOf$1;

function requireOneOf$1 () {
	if (hasRequiredOneOf$1) return oneOf$1;
	hasRequiredOneOf$1 = 1;
	Object.defineProperty(oneOf$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf$1.default = def;
	
	return oneOf$1;
}

var allOf$1 = {};

var hasRequiredAllOf$1;

function requireAllOf$1 () {
	if (hasRequiredAllOf$1) return allOf$1;
	hasRequiredAllOf$1 = 1;
	Object.defineProperty(allOf$1, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf$1.default = def;
	
	return allOf$1;
}

var _if$1 = {};

var hasRequired_if$1;

function require_if$1 () {
	if (hasRequired_if$1) return _if$1;
	hasRequired_if$1 = 1;
	Object.defineProperty(_if$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if$1.default = def;
	
	return _if$1;
}

var thenElse$1 = {};

var hasRequiredThenElse$1;

function requireThenElse$1 () {
	if (hasRequiredThenElse$1) return thenElse$1;
	hasRequiredThenElse$1 = 1;
	Object.defineProperty(thenElse$1, "__esModule", { value: true });
	const util_1 = requireUtil$1();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse$1.default = def;
	
	return thenElse$1;
}

var hasRequiredApplicator$1;

function requireApplicator$1 () {
	if (hasRequiredApplicator$1) return applicator$1;
	hasRequiredApplicator$1 = 1;
	Object.defineProperty(applicator$1, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems$1();
	const prefixItems_1 = requirePrefixItems$1();
	const items_1 = requireItems$1();
	const items2020_1 = requireItems2020$1();
	const contains_1 = requireContains$1();
	const dependencies_1 = requireDependencies$1();
	const propertyNames_1 = requirePropertyNames$1();
	const additionalProperties_1 = requireAdditionalProperties$1();
	const properties_1 = requireProperties$1();
	const patternProperties_1 = requirePatternProperties$1();
	const not_1 = requireNot$1();
	const anyOf_1 = requireAnyOf$1();
	const oneOf_1 = requireOneOf$1();
	const allOf_1 = requireAllOf$1();
	const if_1 = require_if$1();
	const thenElse_1 = requireThenElse$1();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator$1.default = getApplicator;
	
	return applicator$1;
}

var format$3 = {};

var format$2 = {};

var hasRequiredFormat$3;

function requireFormat$3 () {
	if (hasRequiredFormat$3) return format$2;
	hasRequiredFormat$3 = 1;
	Object.defineProperty(format$2, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format$2.default = def;
	
	return format$2;
}

var hasRequiredFormat$2;

function requireFormat$2 () {
	if (hasRequiredFormat$2) return format$3;
	hasRequiredFormat$2 = 1;
	Object.defineProperty(format$3, "__esModule", { value: true });
	const format_1 = requireFormat$3();
	const format = [format_1.default];
	format$3.default = format;
	
	return format$3;
}

var metadata$1 = {};

var hasRequiredMetadata$1;

function requireMetadata$1 () {
	if (hasRequiredMetadata$1) return metadata$1;
	hasRequiredMetadata$1 = 1;
	Object.defineProperty(metadata$1, "__esModule", { value: true });
	metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
	metadata$1.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata$1.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata$1;
}

var hasRequiredDraft7$1;

function requireDraft7$1 () {
	if (hasRequiredDraft7$1) return draft7$1;
	hasRequiredDraft7$1 = 1;
	Object.defineProperty(draft7$1, "__esModule", { value: true });
	const core_1 = requireCore$2();
	const validation_1 = requireValidation$1();
	const applicator_1 = requireApplicator$1();
	const format_1 = requireFormat$2();
	const metadata_1 = requireMetadata$1();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7$1.default = draft7Vocabularies;
	
	return draft7$1;
}

var discriminator$1 = {};

var types$1 = {};

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types$1.DiscrError = DiscrError = {}));
	
	return types$1;
}

var hasRequiredDiscriminator$1;

function requireDiscriminator$1 () {
	if (hasRequiredDiscriminator$1) return discriminator$1;
	hasRequiredDiscriminator$1 = 1;
	Object.defineProperty(discriminator$1, "__esModule", { value: true });
	const codegen_1 = requireCodegen$1();
	const types_1 = requireTypes$1();
	const compile_1 = requireCompile$1();
	const ref_error_1 = requireRef_error$1();
	const util_1 = requireUtil$1();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator$1.default = def;
	
	return discriminator$1;
}

var $schema$1 = "http://json-schema.org/draft-07/schema#";
var $id$2 = "http://json-schema.org/draft-07/schema#";
var title$1 = "Core schema meta-schema";
var definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$2 = [
	"object",
	"boolean"
];
var properties$3 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3$1 = {
	$schema: $schema$1,
	$id: $id$2,
	title: title$1,
	definitions: definitions$1,
	type: type$2,
	properties: properties$3,
	"default": true
};

var hasRequiredAjv$1;

function requireAjv$1 () {
	if (hasRequiredAjv$1) return ajv$3.exports;
	hasRequiredAjv$1 = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$3();
		const draft7_1 = requireDraft7$1();
		const discriminator_1 = requireDiscriminator$1();
		const draft7MetaSchema = require$$3$1;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate$1();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error$1();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error$1();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv$3, ajv$3.exports));
	return ajv$3.exports;
}

var ajvExports = requireAjv$1();
var ajv$1 = /*@__PURE__*/getDefaultExportFromCjs(ajvExports);

var ajv$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: ajv$1
});

var dist = {exports: {}};

var formats = {};

var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
		function fmtDef(validate, compare) {
		    return { validate, compare };
		}
		exports.fullFormats = {
		    // date: http://tools.ietf.org/html/rfc3339#section-5.6
		    date: fmtDef(date, compareDate),
		    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
		    time: fmtDef(getTime(true), compareTime),
		    "date-time": fmtDef(getDateTime(true), compareDateTime),
		    "iso-time": fmtDef(getTime(), compareIsoTime),
		    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
		    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
		    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
		    uri,
		    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
		    // uri-template: https://tools.ietf.org/html/rfc6570
		    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
		    // For the source: https://gist.github.com/dperini/729294
		    // For test cases: https://mathiasbynens.be/demo/url-regex
		    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
		    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
		    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
		    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
		    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
		    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
		    regex,
		    // uuid: http://tools.ietf.org/html/rfc4122
		    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
		    // JSON-pointer: https://tools.ietf.org/html/rfc6901
		    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
		    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
		    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
		    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
		    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
		    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
		    // byte: https://github.com/miguelmota/is-base64
		    byte,
		    // signed 32 bit integer
		    int32: { type: "number", validate: validateInt32 },
		    // signed 64 bit integer
		    int64: { type: "number", validate: validateInt64 },
		    // C-type float
		    float: { type: "number", validate: validateNumber },
		    // C-type double
		    double: { type: "number", validate: validateNumber },
		    // hint to the UI to hide input strings
		    password: true,
		    // unchecked string payload
		    binary: true,
		};
		exports.fastFormats = {
		    ...exports.fullFormats,
		    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
		    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
		    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
		    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
		    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
		    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
		    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
		    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
		    // email (sources from jsen validator):
		    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
		    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
		    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		};
		exports.formatNames = Object.keys(exports.fullFormats);
		function isLeapYear(year) {
		    // https://tools.ietf.org/html/rfc3339#appendix-C
		    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
		}
		const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
		const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		function date(str) {
		    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
		    const matches = DATE.exec(str);
		    if (!matches)
		        return false;
		    const year = +matches[1];
		    const month = +matches[2];
		    const day = +matches[3];
		    return (month >= 1 &&
		        month <= 12 &&
		        day >= 1 &&
		        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
		}
		function compareDate(d1, d2) {
		    if (!(d1 && d2))
		        return undefined;
		    if (d1 > d2)
		        return 1;
		    if (d1 < d2)
		        return -1;
		    return 0;
		}
		const TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
		function getTime(strictTimeZone) {
		    return function time(str) {
		        const matches = TIME.exec(str);
		        if (!matches)
		            return false;
		        const hr = +matches[1];
		        const min = +matches[2];
		        const sec = +matches[3];
		        const tz = matches[4];
		        const tzSign = matches[5] === "-" ? -1 : 1;
		        const tzH = +(matches[6] || 0);
		        const tzM = +(matches[7] || 0);
		        if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz))
		            return false;
		        if (hr <= 23 && min <= 59 && sec < 60)
		            return true;
		        // leap second
		        const utcMin = min - tzM * tzSign;
		        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
		        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
		    };
		}
		function compareTime(s1, s2) {
		    if (!(s1 && s2))
		        return undefined;
		    const t1 = new Date("2020-01-01T" + s1).valueOf();
		    const t2 = new Date("2020-01-01T" + s2).valueOf();
		    if (!(t1 && t2))
		        return undefined;
		    return t1 - t2;
		}
		function compareIsoTime(t1, t2) {
		    if (!(t1 && t2))
		        return undefined;
		    const a1 = TIME.exec(t1);
		    const a2 = TIME.exec(t2);
		    if (!(a1 && a2))
		        return undefined;
		    t1 = a1[1] + a1[2] + a1[3];
		    t2 = a2[1] + a2[2] + a2[3];
		    if (t1 > t2)
		        return 1;
		    if (t1 < t2)
		        return -1;
		    return 0;
		}
		const DATE_TIME_SEPARATOR = /t|\s/i;
		function getDateTime(strictTimeZone) {
		    const time = getTime(strictTimeZone);
		    return function date_time(str) {
		        // http://tools.ietf.org/html/rfc3339#section-5.6
		        const dateTime = str.split(DATE_TIME_SEPARATOR);
		        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
		    };
		}
		function compareDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const d1 = new Date(dt1).valueOf();
		    const d2 = new Date(dt2).valueOf();
		    if (!(d1 && d2))
		        return undefined;
		    return d1 - d2;
		}
		function compareIsoDateTime(dt1, dt2) {
		    if (!(dt1 && dt2))
		        return undefined;
		    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
		    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
		    const res = compareDate(d1, d2);
		    if (res === undefined)
		        return undefined;
		    return res || compareTime(t1, t2);
		}
		const NOT_URI_FRAGMENT = /\/|:/;
		const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
		function uri(str) {
		    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
		    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
		}
		const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
		function byte(str) {
		    BYTE.lastIndex = 0;
		    return BYTE.test(str);
		}
		const MIN_INT32 = -2147483648;
		const MAX_INT32 = 2 ** 31 - 1;
		function validateInt32(value) {
		    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
		}
		function validateInt64(value) {
		    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
		    return Number.isInteger(value);
		}
		function validateNumber() {
		    return true;
		}
		const Z_ANCHOR = /[^\\]\\Z/;
		function regex(str) {
		    if (Z_ANCHOR.test(str))
		        return false;
		    try {
		        new RegExp(str);
		        return true;
		    }
		    catch (e) {
		        return false;
		    }
		}
		
	} (formats));
	return formats;
}

var limit = {};

var ajv = {exports: {}};

var core$1 = {};

var validate = {};

var boolSchema = {};

var errors = {};

var codegen = {};

var code$1 = {};

var hasRequiredCode$1;

function requireCode$1 () {
	if (hasRequiredCode$1) return code$1;
	hasRequiredCode$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
		// eslint-disable-next-line @typescript-eslint/no-extraneous-class
		class _CodeOrName {
		}
		exports._CodeOrName = _CodeOrName;
		exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
		class Name extends _CodeOrName {
		    constructor(s) {
		        super();
		        if (!exports.IDENTIFIER.test(s))
		            throw new Error("CodeGen: name must be a valid identifier");
		        this.str = s;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        return false;
		    }
		    get names() {
		        return { [this.str]: 1 };
		    }
		}
		exports.Name = Name;
		class _Code extends _CodeOrName {
		    constructor(code) {
		        super();
		        this._items = typeof code === "string" ? [code] : code;
		    }
		    toString() {
		        return this.str;
		    }
		    emptyStr() {
		        if (this._items.length > 1)
		            return false;
		        const item = this._items[0];
		        return item === "" || item === '""';
		    }
		    get str() {
		        var _a;
		        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));
		    }
		    get names() {
		        var _a;
		        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {
		            if (c instanceof Name)
		                names[c.str] = (names[c.str] || 0) + 1;
		            return names;
		        }, {})));
		    }
		}
		exports._Code = _Code;
		exports.nil = new _Code("");
		function _(strs, ...args) {
		    const code = [strs[0]];
		    let i = 0;
		    while (i < args.length) {
		        addCodeArg(code, args[i]);
		        code.push(strs[++i]);
		    }
		    return new _Code(code);
		}
		exports._ = _;
		const plus = new _Code("+");
		function str(strs, ...args) {
		    const expr = [safeStringify(strs[0])];
		    let i = 0;
		    while (i < args.length) {
		        expr.push(plus);
		        addCodeArg(expr, args[i]);
		        expr.push(plus, safeStringify(strs[++i]));
		    }
		    optimize(expr);
		    return new _Code(expr);
		}
		exports.str = str;
		function addCodeArg(code, arg) {
		    if (arg instanceof _Code)
		        code.push(...arg._items);
		    else if (arg instanceof Name)
		        code.push(arg);
		    else
		        code.push(interpolate(arg));
		}
		exports.addCodeArg = addCodeArg;
		function optimize(expr) {
		    let i = 1;
		    while (i < expr.length - 1) {
		        if (expr[i] === plus) {
		            const res = mergeExprItems(expr[i - 1], expr[i + 1]);
		            if (res !== undefined) {
		                expr.splice(i - 1, 3, res);
		                continue;
		            }
		            expr[i++] = "+";
		        }
		        i++;
		    }
		}
		function mergeExprItems(a, b) {
		    if (b === '""')
		        return a;
		    if (a === '""')
		        return b;
		    if (typeof a == "string") {
		        if (b instanceof Name || a[a.length - 1] !== '"')
		            return;
		        if (typeof b != "string")
		            return `${a.slice(0, -1)}${b}"`;
		        if (b[0] === '"')
		            return a.slice(0, -1) + b.slice(1);
		        return;
		    }
		    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
		        return `"${a}${b.slice(1)}`;
		    return;
		}
		function strConcat(c1, c2) {
		    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;
		}
		exports.strConcat = strConcat;
		// TODO do not allow arrays here
		function interpolate(x) {
		    return typeof x == "number" || typeof x == "boolean" || x === null
		        ? x
		        : safeStringify(Array.isArray(x) ? x.join(",") : x);
		}
		function stringify(x) {
		    return new _Code(safeStringify(x));
		}
		exports.stringify = stringify;
		function safeStringify(x) {
		    return JSON.stringify(x)
		        .replace(/\u2028/g, "\\u2028")
		        .replace(/\u2029/g, "\\u2029");
		}
		exports.safeStringify = safeStringify;
		function getProperty(key) {
		    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;
		}
		exports.getProperty = getProperty;
		//Does best effort to format the name properly
		function getEsmExportName(key) {
		    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
		        return new _Code(`${key}`);
		    }
		    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
		}
		exports.getEsmExportName = getEsmExportName;
		function regexpCode(rx) {
		    return new _Code(rx.toString());
		}
		exports.regexpCode = regexpCode;
		
	} (code$1));
	return code$1;
}

var scope = {};

var hasRequiredScope;

function requireScope () {
	if (hasRequiredScope) return scope;
	hasRequiredScope = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
		const code_1 = requireCode$1();
		class ValueError extends Error {
		    constructor(name) {
		        super(`CodeGen: "code" for ${name} not defined`);
		        this.value = name.value;
		    }
		}
		var UsedValueState;
		(function (UsedValueState) {
		    UsedValueState[UsedValueState["Started"] = 0] = "Started";
		    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
		})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
		exports.varKinds = {
		    const: new code_1.Name("const"),
		    let: new code_1.Name("let"),
		    var: new code_1.Name("var"),
		};
		class Scope {
		    constructor({ prefixes, parent } = {}) {
		        this._names = {};
		        this._prefixes = prefixes;
		        this._parent = parent;
		    }
		    toName(nameOrPrefix) {
		        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
		    }
		    name(prefix) {
		        return new code_1.Name(this._newName(prefix));
		    }
		    _newName(prefix) {
		        const ng = this._names[prefix] || this._nameGroup(prefix);
		        return `${prefix}${ng.index++}`;
		    }
		    _nameGroup(prefix) {
		        var _a, _b;
		        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
		            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
		        }
		        return (this._names[prefix] = { prefix, index: 0 });
		    }
		}
		exports.Scope = Scope;
		class ValueScopeName extends code_1.Name {
		    constructor(prefix, nameStr) {
		        super(nameStr);
		        this.prefix = prefix;
		    }
		    setValue(value, { property, itemIndex }) {
		        this.value = value;
		        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;
		    }
		}
		exports.ValueScopeName = ValueScopeName;
		const line = (0, code_1._) `\n`;
		class ValueScope extends Scope {
		    constructor(opts) {
		        super(opts);
		        this._values = {};
		        this._scope = opts.scope;
		        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
		    }
		    get() {
		        return this._scope;
		    }
		    name(prefix) {
		        return new ValueScopeName(prefix, this._newName(prefix));
		    }
		    value(nameOrPrefix, value) {
		        var _a;
		        if (value.ref === undefined)
		            throw new Error("CodeGen: ref must be passed in value");
		        const name = this.toName(nameOrPrefix);
		        const { prefix } = name;
		        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
		        let vs = this._values[prefix];
		        if (vs) {
		            const _name = vs.get(valueKey);
		            if (_name)
		                return _name;
		        }
		        else {
		            vs = this._values[prefix] = new Map();
		        }
		        vs.set(valueKey, name);
		        const s = this._scope[prefix] || (this._scope[prefix] = []);
		        const itemIndex = s.length;
		        s[itemIndex] = value.ref;
		        name.setValue(value, { property: prefix, itemIndex });
		        return name;
		    }
		    getValue(prefix, keyOrRef) {
		        const vs = this._values[prefix];
		        if (!vs)
		            return;
		        return vs.get(keyOrRef);
		    }
		    scopeRefs(scopeName, values = this._values) {
		        return this._reduceValues(values, (name) => {
		            if (name.scopePath === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return (0, code_1._) `${scopeName}${name.scopePath}`;
		        });
		    }
		    scopeCode(values = this._values, usedValues, getCode) {
		        return this._reduceValues(values, (name) => {
		            if (name.value === undefined)
		                throw new Error(`CodeGen: name "${name}" has no value`);
		            return name.value.code;
		        }, usedValues, getCode);
		    }
		    _reduceValues(values, valueCode, usedValues = {}, getCode) {
		        let code = code_1.nil;
		        for (const prefix in values) {
		            const vs = values[prefix];
		            if (!vs)
		                continue;
		            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
		            vs.forEach((name) => {
		                if (nameSet.has(name))
		                    return;
		                nameSet.set(name, UsedValueState.Started);
		                let c = valueCode(name);
		                if (c) {
		                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
		                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;
		                }
		                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
		                    code = (0, code_1._) `${code}${c}${this.opts._n}`;
		                }
		                else {
		                    throw new ValueError(name);
		                }
		                nameSet.set(name, UsedValueState.Completed);
		            });
		        }
		        return code;
		    }
		}
		exports.ValueScope = ValueScope;
		
	} (scope));
	return scope;
}

var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen;
	hasRequiredCodegen = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
		const code_1 = requireCode$1();
		const scope_1 = requireScope();
		var code_2 = requireCode$1();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; } });
		Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; } });
		Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; } });
		Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; } });
		var scope_2 = requireScope();
		Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; } });
		Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; } });
		Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });
		Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; } });
		exports.operators = {
		    GT: new code_1._Code(">"),
		    GTE: new code_1._Code(">="),
		    LT: new code_1._Code("<"),
		    LTE: new code_1._Code("<="),
		    EQ: new code_1._Code("==="),
		    NEQ: new code_1._Code("!=="),
		    NOT: new code_1._Code("!"),
		    OR: new code_1._Code("||"),
		    AND: new code_1._Code("&&"),
		    ADD: new code_1._Code("+"),
		};
		class Node {
		    optimizeNodes() {
		        return this;
		    }
		    optimizeNames(_names, _constants) {
		        return this;
		    }
		}
		class Def extends Node {
		    constructor(varKind, name, rhs) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.rhs = rhs;
		    }
		    render({ es5, _n }) {
		        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
		        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
		        return `${varKind} ${this.name}${rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (!names[this.name.str])
		            return;
		        if (this.rhs)
		            this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
		    }
		}
		class Assign extends Node {
		    constructor(lhs, rhs, sideEffects) {
		        super();
		        this.lhs = lhs;
		        this.rhs = rhs;
		        this.sideEffects = sideEffects;
		    }
		    render({ _n }) {
		        return `${this.lhs} = ${this.rhs};` + _n;
		    }
		    optimizeNames(names, constants) {
		        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
		            return;
		        this.rhs = optimizeExpr(this.rhs, names, constants);
		        return this;
		    }
		    get names() {
		        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
		        return addExprNames(names, this.rhs);
		    }
		}
		class AssignOp extends Assign {
		    constructor(lhs, op, rhs, sideEffects) {
		        super(lhs, rhs, sideEffects);
		        this.op = op;
		    }
		    render({ _n }) {
		        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
		    }
		}
		class Label extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        return `${this.label}:` + _n;
		    }
		}
		class Break extends Node {
		    constructor(label) {
		        super();
		        this.label = label;
		        this.names = {};
		    }
		    render({ _n }) {
		        const label = this.label ? ` ${this.label}` : "";
		        return `break${label};` + _n;
		    }
		}
		class Throw extends Node {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render({ _n }) {
		        return `throw ${this.error};` + _n;
		    }
		    get names() {
		        return this.error.names;
		    }
		}
		class AnyCode extends Node {
		    constructor(code) {
		        super();
		        this.code = code;
		    }
		    render({ _n }) {
		        return `${this.code};` + _n;
		    }
		    optimizeNodes() {
		        return `${this.code}` ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        this.code = optimizeExpr(this.code, names, constants);
		        return this;
		    }
		    get names() {
		        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
		    }
		}
		class ParentNode extends Node {
		    constructor(nodes = []) {
		        super();
		        this.nodes = nodes;
		    }
		    render(opts) {
		        return this.nodes.reduce((code, n) => code + n.render(opts), "");
		    }
		    optimizeNodes() {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            const n = nodes[i].optimizeNodes();
		            if (Array.isArray(n))
		                nodes.splice(i, 1, ...n);
		            else if (n)
		                nodes[i] = n;
		            else
		                nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    optimizeNames(names, constants) {
		        const { nodes } = this;
		        let i = nodes.length;
		        while (i--) {
		            // iterating backwards improves 1-pass optimization
		            const n = nodes[i];
		            if (n.optimizeNames(names, constants))
		                continue;
		            subtractNames(names, n.names);
		            nodes.splice(i, 1);
		        }
		        return nodes.length > 0 ? this : undefined;
		    }
		    get names() {
		        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
		    }
		}
		class BlockNode extends ParentNode {
		    render(opts) {
		        return "{" + opts._n + super.render(opts) + "}" + opts._n;
		    }
		}
		class Root extends ParentNode {
		}
		class Else extends BlockNode {
		}
		Else.kind = "else";
		class If extends BlockNode {
		    constructor(condition, nodes) {
		        super(nodes);
		        this.condition = condition;
		    }
		    render(opts) {
		        let code = `if(${this.condition})` + super.render(opts);
		        if (this.else)
		            code += "else " + this.else.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        super.optimizeNodes();
		        const cond = this.condition;
		        if (cond === true)
		            return this.nodes; // else is ignored here
		        let e = this.else;
		        if (e) {
		            const ns = e.optimizeNodes();
		            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
		        }
		        if (e) {
		            if (cond === false)
		                return e instanceof If ? e : e.nodes;
		            if (this.nodes.length)
		                return this;
		            return new If(not(cond), e instanceof If ? [e] : e.nodes);
		        }
		        if (cond === false || !this.nodes.length)
		            return undefined;
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a;
		        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        if (!(super.optimizeNames(names, constants) || this.else))
		            return;
		        this.condition = optimizeExpr(this.condition, names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        addExprNames(names, this.condition);
		        if (this.else)
		            addNames(names, this.else.names);
		        return names;
		    }
		}
		If.kind = "if";
		class For extends BlockNode {
		}
		For.kind = "for";
		class ForLoop extends For {
		    constructor(iteration) {
		        super();
		        this.iteration = iteration;
		    }
		    render(opts) {
		        return `for(${this.iteration})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iteration = optimizeExpr(this.iteration, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iteration.names);
		    }
		}
		class ForRange extends For {
		    constructor(varKind, name, from, to) {
		        super();
		        this.varKind = varKind;
		        this.name = name;
		        this.from = from;
		        this.to = to;
		    }
		    render(opts) {
		        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
		        const { name, from, to } = this;
		        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
		    }
		    get names() {
		        const names = addExprNames(super.names, this.from);
		        return addExprNames(names, this.to);
		    }
		}
		class ForIter extends For {
		    constructor(loop, varKind, name, iterable) {
		        super();
		        this.loop = loop;
		        this.varKind = varKind;
		        this.name = name;
		        this.iterable = iterable;
		    }
		    render(opts) {
		        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
		    }
		    optimizeNames(names, constants) {
		        if (!super.optimizeNames(names, constants))
		            return;
		        this.iterable = optimizeExpr(this.iterable, names, constants);
		        return this;
		    }
		    get names() {
		        return addNames(super.names, this.iterable.names);
		    }
		}
		class Func extends BlockNode {
		    constructor(name, args, async) {
		        super();
		        this.name = name;
		        this.args = args;
		        this.async = async;
		    }
		    render(opts) {
		        const _async = this.async ? "async " : "";
		        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
		    }
		}
		Func.kind = "func";
		class Return extends ParentNode {
		    render(opts) {
		        return "return " + super.render(opts);
		    }
		}
		Return.kind = "return";
		class Try extends BlockNode {
		    render(opts) {
		        let code = "try" + super.render(opts);
		        if (this.catch)
		            code += this.catch.render(opts);
		        if (this.finally)
		            code += this.finally.render(opts);
		        return code;
		    }
		    optimizeNodes() {
		        var _a, _b;
		        super.optimizeNodes();
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
		        return this;
		    }
		    optimizeNames(names, constants) {
		        var _a, _b;
		        super.optimizeNames(names, constants);
		        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
		        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
		        return this;
		    }
		    get names() {
		        const names = super.names;
		        if (this.catch)
		            addNames(names, this.catch.names);
		        if (this.finally)
		            addNames(names, this.finally.names);
		        return names;
		    }
		}
		class Catch extends BlockNode {
		    constructor(error) {
		        super();
		        this.error = error;
		    }
		    render(opts) {
		        return `catch(${this.error})` + super.render(opts);
		    }
		}
		Catch.kind = "catch";
		class Finally extends BlockNode {
		    render(opts) {
		        return "finally" + super.render(opts);
		    }
		}
		Finally.kind = "finally";
		class CodeGen {
		    constructor(extScope, opts = {}) {
		        this._values = {};
		        this._blockStarts = [];
		        this._constants = {};
		        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
		        this._extScope = extScope;
		        this._scope = new scope_1.Scope({ parent: extScope });
		        this._nodes = [new Root()];
		    }
		    toString() {
		        return this._root.render(this.opts);
		    }
		    // returns unique name in the internal scope
		    name(prefix) {
		        return this._scope.name(prefix);
		    }
		    // reserves unique name in the external scope
		    scopeName(prefix) {
		        return this._extScope.name(prefix);
		    }
		    // reserves unique name in the external scope and assigns value to it
		    scopeValue(prefixOrName, value) {
		        const name = this._extScope.value(prefixOrName, value);
		        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
		        vs.add(name);
		        return name;
		    }
		    getScopeValue(prefix, keyOrRef) {
		        return this._extScope.getValue(prefix, keyOrRef);
		    }
		    // return code that assigns values in the external scope to the names that are used internally
		    // (same names that were returned by gen.scopeName or gen.scopeValue)
		    scopeRefs(scopeName) {
		        return this._extScope.scopeRefs(scopeName, this._values);
		    }
		    scopeCode() {
		        return this._extScope.scopeCode(this._values);
		    }
		    _def(varKind, nameOrPrefix, rhs, constant) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (rhs !== undefined && constant)
		            this._constants[name.str] = rhs;
		        this._leafNode(new Def(varKind, name, rhs));
		        return name;
		    }
		    // `const` declaration (`var` in es5 mode)
		    const(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
		    }
		    // `let` declaration with optional assignment (`var` in es5 mode)
		    let(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
		    }
		    // `var` declaration with optional assignment
		    var(nameOrPrefix, rhs, _constant) {
		        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
		    }
		    // assignment code
		    assign(lhs, rhs, sideEffects) {
		        return this._leafNode(new Assign(lhs, rhs, sideEffects));
		    }
		    // `+=` code
		    add(lhs, rhs) {
		        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
		    }
		    // appends passed SafeExpr to code or executes Block
		    code(c) {
		        if (typeof c == "function")
		            c();
		        else if (c !== code_1.nil)
		            this._leafNode(new AnyCode(c));
		        return this;
		    }
		    // returns code for object literal for the passed argument list of key-value pairs
		    object(...keyValues) {
		        const code = ["{"];
		        for (const [key, value] of keyValues) {
		            if (code.length > 1)
		                code.push(",");
		            code.push(key);
		            if (key !== value || this.opts.es5) {
		                code.push(":");
		                (0, code_1.addCodeArg)(code, value);
		            }
		        }
		        code.push("}");
		        return new code_1._Code(code);
		    }
		    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
		    if(condition, thenBody, elseBody) {
		        this._blockNode(new If(condition));
		        if (thenBody && elseBody) {
		            this.code(thenBody).else().code(elseBody).endIf();
		        }
		        else if (thenBody) {
		            this.code(thenBody).endIf();
		        }
		        else if (elseBody) {
		            throw new Error('CodeGen: "else" body without "then" body');
		        }
		        return this;
		    }
		    // `else if` clause - invalid without `if` or after `else` clauses
		    elseIf(condition) {
		        return this._elseNode(new If(condition));
		    }
		    // `else` clause - only valid after `if` or `else if` clauses
		    else() {
		        return this._elseNode(new Else());
		    }
		    // end `if` statement (needed if gen.if was used only with condition)
		    endIf() {
		        return this._endBlockNode(If, Else);
		    }
		    _for(node, forBody) {
		        this._blockNode(node);
		        if (forBody)
		            this.code(forBody).endFor();
		        return this;
		    }
		    // a generic `for` clause (or statement if `forBody` is passed)
		    for(iteration, forBody) {
		        return this._for(new ForLoop(iteration), forBody);
		    }
		    // `for` statement for a range of values
		    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
		    }
		    // `for-of` statement (in es5 mode replace with a normal for loop)
		    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
		        const name = this._scope.toName(nameOrPrefix);
		        if (this.opts.es5) {
		            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
		            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {
		                this.var(name, (0, code_1._) `${arr}[${i}]`);
		                forBody(name);
		            });
		        }
		        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
		    }
		    // `for-in` statement.
		    // With option `ownProperties` replaced with a `for-of` loop for object keys
		    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
		        if (this.opts.ownProperties) {
		            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);
		        }
		        const name = this._scope.toName(nameOrPrefix);
		        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
		    }
		    // end `for` loop
		    endFor() {
		        return this._endBlockNode(For);
		    }
		    // `label` statement
		    label(label) {
		        return this._leafNode(new Label(label));
		    }
		    // `break` statement
		    break(label) {
		        return this._leafNode(new Break(label));
		    }
		    // `return` statement
		    return(value) {
		        const node = new Return();
		        this._blockNode(node);
		        this.code(value);
		        if (node.nodes.length !== 1)
		            throw new Error('CodeGen: "return" should have one node');
		        return this._endBlockNode(Return);
		    }
		    // `try` statement
		    try(tryBody, catchCode, finallyCode) {
		        if (!catchCode && !finallyCode)
		            throw new Error('CodeGen: "try" without "catch" and "finally"');
		        const node = new Try();
		        this._blockNode(node);
		        this.code(tryBody);
		        if (catchCode) {
		            const error = this.name("e");
		            this._currNode = node.catch = new Catch(error);
		            catchCode(error);
		        }
		        if (finallyCode) {
		            this._currNode = node.finally = new Finally();
		            this.code(finallyCode);
		        }
		        return this._endBlockNode(Catch, Finally);
		    }
		    // `throw` statement
		    throw(error) {
		        return this._leafNode(new Throw(error));
		    }
		    // start self-balancing block
		    block(body, nodeCount) {
		        this._blockStarts.push(this._nodes.length);
		        if (body)
		            this.code(body).endBlock(nodeCount);
		        return this;
		    }
		    // end the current self-balancing block
		    endBlock(nodeCount) {
		        const len = this._blockStarts.pop();
		        if (len === undefined)
		            throw new Error("CodeGen: not in self-balancing block");
		        const toClose = this._nodes.length - len;
		        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
		            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
		        }
		        this._nodes.length = len;
		        return this;
		    }
		    // `function` heading (or definition if funcBody is passed)
		    func(name, args = code_1.nil, async, funcBody) {
		        this._blockNode(new Func(name, args, async));
		        if (funcBody)
		            this.code(funcBody).endFunc();
		        return this;
		    }
		    // end function definition
		    endFunc() {
		        return this._endBlockNode(Func);
		    }
		    optimize(n = 1) {
		        while (n-- > 0) {
		            this._root.optimizeNodes();
		            this._root.optimizeNames(this._root.names, this._constants);
		        }
		    }
		    _leafNode(node) {
		        this._currNode.nodes.push(node);
		        return this;
		    }
		    _blockNode(node) {
		        this._currNode.nodes.push(node);
		        this._nodes.push(node);
		    }
		    _endBlockNode(N1, N2) {
		        const n = this._currNode;
		        if (n instanceof N1 || (N2 && n instanceof N2)) {
		            this._nodes.pop();
		            return this;
		        }
		        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
		    }
		    _elseNode(node) {
		        const n = this._currNode;
		        if (!(n instanceof If)) {
		            throw new Error('CodeGen: "else" without "if"');
		        }
		        this._currNode = n.else = node;
		        return this;
		    }
		    get _root() {
		        return this._nodes[0];
		    }
		    get _currNode() {
		        const ns = this._nodes;
		        return ns[ns.length - 1];
		    }
		    set _currNode(node) {
		        const ns = this._nodes;
		        ns[ns.length - 1] = node;
		    }
		}
		exports.CodeGen = CodeGen;
		function addNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) + (from[n] || 0);
		    return names;
		}
		function addExprNames(names, from) {
		    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
		}
		function optimizeExpr(expr, names, constants) {
		    if (expr instanceof code_1.Name)
		        return replaceName(expr);
		    if (!canOptimize(expr))
		        return expr;
		    return new code_1._Code(expr._items.reduce((items, c) => {
		        if (c instanceof code_1.Name)
		            c = replaceName(c);
		        if (c instanceof code_1._Code)
		            items.push(...c._items);
		        else
		            items.push(c);
		        return items;
		    }, []));
		    function replaceName(n) {
		        const c = constants[n.str];
		        if (c === undefined || names[n.str] !== 1)
		            return n;
		        delete names[n.str];
		        return c;
		    }
		    function canOptimize(e) {
		        return (e instanceof code_1._Code &&
		            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
		    }
		}
		function subtractNames(names, from) {
		    for (const n in from)
		        names[n] = (names[n] || 0) - (from[n] || 0);
		}
		function not(x) {
		    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;
		}
		exports.not = not;
		const andCode = mappend(exports.operators.AND);
		// boolean AND (&&) expression with the passed arguments
		function and(...args) {
		    return args.reduce(andCode);
		}
		exports.and = and;
		const orCode = mappend(exports.operators.OR);
		// boolean OR (||) expression with the passed arguments
		function or(...args) {
		    return args.reduce(orCode);
		}
		exports.or = or;
		function mappend(op) {
		    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);
		}
		function par(x) {
		    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;
		}
		
	} (codegen));
	return codegen;
}

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	Object.defineProperty(util, "__esModule", { value: true });
	util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
	const codegen_1 = requireCodegen();
	const code_1 = requireCode$1();
	// TODO refactor to use Set
	function toHash(arr) {
	    const hash = {};
	    for (const item of arr)
	        hash[item] = true;
	    return hash;
	}
	util.toHash = toHash;
	function alwaysValidSchema(it, schema) {
	    if (typeof schema == "boolean")
	        return schema;
	    if (Object.keys(schema).length === 0)
	        return true;
	    checkUnknownRules(it, schema);
	    return !schemaHasRules(schema, it.self.RULES.all);
	}
	util.alwaysValidSchema = alwaysValidSchema;
	function checkUnknownRules(it, schema = it.schema) {
	    const { opts, self } = it;
	    if (!opts.strictSchema)
	        return;
	    if (typeof schema === "boolean")
	        return;
	    const rules = self.RULES.keywords;
	    for (const key in schema) {
	        if (!rules[key])
	            checkStrictMode(it, `unknown keyword: "${key}"`);
	    }
	}
	util.checkUnknownRules = checkUnknownRules;
	function schemaHasRules(schema, rules) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (rules[key])
	            return true;
	    return false;
	}
	util.schemaHasRules = schemaHasRules;
	function schemaHasRulesButRef(schema, RULES) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (key !== "$ref" && RULES.all[key])
	            return true;
	    return false;
	}
	util.schemaHasRulesButRef = schemaHasRulesButRef;
	function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
	    if (!$data) {
	        if (typeof schema == "number" || typeof schema == "boolean")
	            return schema;
	        if (typeof schema == "string")
	            return (0, codegen_1._) `${schema}`;
	    }
	    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
	}
	util.schemaRefOrVal = schemaRefOrVal;
	function unescapeFragment(str) {
	    return unescapeJsonPointer(decodeURIComponent(str));
	}
	util.unescapeFragment = unescapeFragment;
	function escapeFragment(str) {
	    return encodeURIComponent(escapeJsonPointer(str));
	}
	util.escapeFragment = escapeFragment;
	function escapeJsonPointer(str) {
	    if (typeof str == "number")
	        return `${str}`;
	    return str.replace(/~/g, "~0").replace(/\//g, "~1");
	}
	util.escapeJsonPointer = escapeJsonPointer;
	function unescapeJsonPointer(str) {
	    return str.replace(/~1/g, "/").replace(/~0/g, "~");
	}
	util.unescapeJsonPointer = unescapeJsonPointer;
	function eachItem(xs, f) {
	    if (Array.isArray(xs)) {
	        for (const x of xs)
	            f(x);
	    }
	    else {
	        f(xs);
	    }
	}
	util.eachItem = eachItem;
	function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {
	    return (gen, from, to, toName) => {
	        const res = to === undefined
	            ? from
	            : to instanceof codegen_1.Name
	                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
	                : from instanceof codegen_1.Name
	                    ? (mergeToName(gen, to, from), from)
	                    : mergeValues(from, to);
	        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
	    };
	}
	util.mergeEvaluated = {
	    props: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {
	            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));
	        }),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {
	            if (from === true) {
	                gen.assign(to, true);
	            }
	            else {
	                gen.assign(to, (0, codegen_1._) `${to} || {}`);
	                setEvaluated(gen, to, from);
	            }
	        }),
	        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),
	        resultToName: evaluatedPropsToName,
	    }),
	    items: makeMergeEvaluated({
	        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
	        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),
	        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
	        resultToName: (gen, items) => gen.var("items", items),
	    }),
	};
	function evaluatedPropsToName(gen, ps) {
	    if (ps === true)
	        return gen.var("props", true);
	    const props = gen.var("props", (0, codegen_1._) `{}`);
	    if (ps !== undefined)
	        setEvaluated(gen, props, ps);
	    return props;
	}
	util.evaluatedPropsToName = evaluatedPropsToName;
	function setEvaluated(gen, props, ps) {
	    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));
	}
	util.setEvaluated = setEvaluated;
	const snippets = {};
	function useFunc(gen, f) {
	    return gen.scopeValue("func", {
	        ref: f,
	        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
	    });
	}
	util.useFunc = useFunc;
	var Type;
	(function (Type) {
	    Type[Type["Num"] = 0] = "Num";
	    Type[Type["Str"] = 1] = "Str";
	})(Type || (util.Type = Type = {}));
	function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
	    // let path
	    if (dataProp instanceof codegen_1.Name) {
	        const isNumber = dataPropType === Type.Num;
	        return jsPropertySyntax
	            ? isNumber
	                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`
	                : (0, codegen_1._) `"['" + ${dataProp} + "']"`
	            : isNumber
	                ? (0, codegen_1._) `"/" + ${dataProp}`
	                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
	    }
	    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
	}
	util.getErrorPath = getErrorPath;
	function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
	    if (!mode)
	        return;
	    msg = `strict mode: ${msg}`;
	    if (mode === true)
	        throw new Error(msg);
	    it.self.logger.warn(msg);
	}
	util.checkStrictMode = checkStrictMode;
	
	return util;
}

var names = {};

var hasRequiredNames;

function requireNames () {
	if (hasRequiredNames) return names;
	hasRequiredNames = 1;
	Object.defineProperty(names, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const names$1 = {
	    // validation function arguments
	    data: new codegen_1.Name("data"), // data passed to validation function
	    // args passed from referencing schema
	    valCxt: new codegen_1.Name("valCxt"), // validation/data context - should not be used directly, it is destructured to the names below
	    instancePath: new codegen_1.Name("instancePath"),
	    parentData: new codegen_1.Name("parentData"),
	    parentDataProperty: new codegen_1.Name("parentDataProperty"),
	    rootData: new codegen_1.Name("rootData"), // root data - same as the data passed to the first/top validation function
	    dynamicAnchors: new codegen_1.Name("dynamicAnchors"), // used to support recursiveRef and dynamicRef
	    // function scoped variables
	    vErrors: new codegen_1.Name("vErrors"), // null or array of validation errors
	    errors: new codegen_1.Name("errors"), // counter of validation errors
	    this: new codegen_1.Name("this"),
	    // "globals"
	    self: new codegen_1.Name("self"),
	    scope: new codegen_1.Name("scope"),
	    // JTD serialize/parse name for JSON string and position
	    json: new codegen_1.Name("json"),
	    jsonPos: new codegen_1.Name("jsonPos"),
	    jsonLen: new codegen_1.Name("jsonLen"),
	    jsonPart: new codegen_1.Name("jsonPart"),
	};
	names.default = names$1;
	
	return names;
}

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil();
		const names_1 = requireNames();
		exports.keywordError = {
		    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,
		};
		exports.keyword$DataError = {
		    message: ({ keyword, schemaType }) => schemaType
		        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`
		        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,
		};
		function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
		        addError(gen, errObj);
		    }
		    else {
		        returnErrors(it, (0, codegen_1._) `[${errObj}]`);
		    }
		}
		exports.reportError = reportError;
		function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
		    const { it } = cxt;
		    const { gen, compositeRule, allErrors } = it;
		    const errObj = errorObjectCode(cxt, error, errorPaths);
		    addError(gen, errObj);
		    if (!(compositeRule || allErrors)) {
		        returnErrors(it, names_1.default.vErrors);
		    }
		}
		exports.reportExtraError = reportExtraError;
		function resetErrorsCount(gen, errsCount) {
		    gen.assign(names_1.default.errors, errsCount);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
		}
		exports.resetErrorsCount = resetErrorsCount;
		function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {
		    /* istanbul ignore if */
		    if (errsCount === undefined)
		        throw new Error("ajv implementation error");
		    const err = gen.name("err");
		    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
		        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);
		        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
		        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);
		        if (it.opts.verbose) {
		            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);
		            gen.assign((0, codegen_1._) `${err}.data`, data);
		        }
		    });
		}
		exports.extendErrors = extendErrors;
		function addError(gen, errObj) {
		    const err = gen.const("err", errObj);
		    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);
		    gen.code((0, codegen_1._) `${names_1.default.errors}++`);
		}
		function returnErrors(it, errs) {
		    const { gen, validateName, schemaEnv } = it;
		    if (schemaEnv.$async) {
		        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);
		    }
		    else {
		        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);
		        gen.return(false);
		    }
		}
		const E = {
		    keyword: new codegen_1.Name("keyword"),
		    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
		    params: new codegen_1.Name("params"),
		    propertyName: new codegen_1.Name("propertyName"),
		    message: new codegen_1.Name("message"),
		    schema: new codegen_1.Name("schema"),
		    parentSchema: new codegen_1.Name("parentSchema"),
		};
		function errorObjectCode(cxt, error, errorPaths) {
		    const { createErrors } = cxt.it;
		    if (createErrors === false)
		        return (0, codegen_1._) `{}`;
		    return errorObject(cxt, error, errorPaths);
		}
		function errorObject(cxt, error, errorPaths = {}) {
		    const { gen, it } = cxt;
		    const keyValues = [
		        errorInstancePath(it, errorPaths),
		        errorSchemaPath(cxt, errorPaths),
		    ];
		    extraErrorProps(cxt, error, keyValues);
		    return gen.object(...keyValues);
		}
		function errorInstancePath({ errorPath }, { instancePath }) {
		    const instPath = instancePath
		        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`
		        : errorPath;
		    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
		}
		function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
		    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;
		    if (schemaPath) {
		        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
		    }
		    return [E.schemaPath, schPath];
		}
		function extraErrorProps(cxt, { params, message }, keyValues) {
		    const { keyword, data, schemaValue, it } = cxt;
		    const { opts, propertyName, topSchemaRef, schemaPath } = it;
		    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);
		    if (opts.messages) {
		        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
		    }
		    if (opts.verbose) {
		        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
		    }
		    if (propertyName)
		        keyValues.push([E.propertyName, propertyName]);
		}
		
	} (errors));
	return errors;
}

var hasRequiredBoolSchema;

function requireBoolSchema () {
	if (hasRequiredBoolSchema) return boolSchema;
	hasRequiredBoolSchema = 1;
	Object.defineProperty(boolSchema, "__esModule", { value: true });
	boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const boolError = {
	    message: "boolean schema is false",
	};
	function topBoolOrEmptySchema(it) {
	    const { gen, schema, validateName } = it;
	    if (schema === false) {
	        falseSchemaError(it, false);
	    }
	    else if (typeof schema == "object" && schema.$async === true) {
	        gen.return(names_1.default.data);
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, null);
	        gen.return(true);
	    }
	}
	boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
	function boolOrEmptySchema(it, valid) {
	    const { gen, schema } = it;
	    if (schema === false) {
	        gen.var(valid, false); // TODO var
	        falseSchemaError(it);
	    }
	    else {
	        gen.var(valid, true); // TODO var
	    }
	}
	boolSchema.boolOrEmptySchema = boolOrEmptySchema;
	function falseSchemaError(it, overrideAllErrors) {
	    const { gen, data } = it;
	    // TODO maybe some other interface should be used for non-keyword validation errors...
	    const cxt = {
	        gen,
	        keyword: "false schema",
	        data,
	        schema: false,
	        schemaCode: false,
	        schemaValue: false,
	        params: {},
	        it,
	    };
	    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
	}
	
	return boolSchema;
}

var dataType = {};

var rules = {};

var hasRequiredRules;

function requireRules () {
	if (hasRequiredRules) return rules;
	hasRequiredRules = 1;
	Object.defineProperty(rules, "__esModule", { value: true });
	rules.getRules = rules.isJSONType = void 0;
	const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
	const jsonTypes = new Set(_jsonTypes);
	function isJSONType(x) {
	    return typeof x == "string" && jsonTypes.has(x);
	}
	rules.isJSONType = isJSONType;
	function getRules() {
	    const groups = {
	        number: { type: "number", rules: [] },
	        string: { type: "string", rules: [] },
	        array: { type: "array", rules: [] },
	        object: { type: "object", rules: [] },
	    };
	    return {
	        types: { ...groups, integer: true, boolean: true, null: true },
	        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
	        post: { rules: [] },
	        all: {},
	        keywords: {},
	    };
	}
	rules.getRules = getRules;
	
	return rules;
}

var applicability = {};

var hasRequiredApplicability;

function requireApplicability () {
	if (hasRequiredApplicability) return applicability;
	hasRequiredApplicability = 1;
	Object.defineProperty(applicability, "__esModule", { value: true });
	applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
	function schemaHasRulesForType({ schema, self }, type) {
	    const group = self.RULES.types[type];
	    return group && group !== true && shouldUseGroup(schema, group);
	}
	applicability.schemaHasRulesForType = schemaHasRulesForType;
	function shouldUseGroup(schema, group) {
	    return group.rules.some((rule) => shouldUseRule(schema, rule));
	}
	applicability.shouldUseGroup = shouldUseGroup;
	function shouldUseRule(schema, rule) {
	    var _a;
	    return (schema[rule.keyword] !== undefined ||
	        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));
	}
	applicability.shouldUseRule = shouldUseRule;
	
	return applicability;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;
	Object.defineProperty(dataType, "__esModule", { value: true });
	dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
	const rules_1 = requireRules();
	const applicability_1 = requireApplicability();
	const errors_1 = requireErrors();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	var DataType;
	(function (DataType) {
	    DataType[DataType["Correct"] = 0] = "Correct";
	    DataType[DataType["Wrong"] = 1] = "Wrong";
	})(DataType || (dataType.DataType = DataType = {}));
	function getSchemaTypes(schema) {
	    const types = getJSONTypes(schema.type);
	    const hasNull = types.includes("null");
	    if (hasNull) {
	        if (schema.nullable === false)
	            throw new Error("type: null contradicts nullable: false");
	    }
	    else {
	        if (!types.length && schema.nullable !== undefined) {
	            throw new Error('"nullable" cannot be used without "type"');
	        }
	        if (schema.nullable === true)
	            types.push("null");
	    }
	    return types;
	}
	dataType.getSchemaTypes = getSchemaTypes;
	// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
	function getJSONTypes(ts) {
	    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
	    if (types.every(rules_1.isJSONType))
	        return types;
	    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
	}
	dataType.getJSONTypes = getJSONTypes;
	function coerceAndCheckDataType(it, types) {
	    const { gen, data, opts } = it;
	    const coerceTo = coerceToTypes(types, opts.coerceTypes);
	    const checkTypes = types.length > 0 &&
	        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
	    if (checkTypes) {
	        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
	        gen.if(wrongType, () => {
	            if (coerceTo.length)
	                coerceData(it, types, coerceTo);
	            else
	                reportTypeError(it);
	        });
	    }
	    return checkTypes;
	}
	dataType.coerceAndCheckDataType = coerceAndCheckDataType;
	const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
	function coerceToTypes(types, coerceTypes) {
	    return coerceTypes
	        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
	        : [];
	}
	function coerceData(it, types, coerceTo) {
	    const { gen, data, opts } = it;
	    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);
	    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
	    if (opts.coerceTypes === "array") {
	        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen
	            .assign(data, (0, codegen_1._) `${data}[0]`)
	            .assign(dataType, (0, codegen_1._) `typeof ${data}`)
	            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
	    }
	    gen.if((0, codegen_1._) `${coerced} !== undefined`);
	    for (const t of coerceTo) {
	        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
	            coerceSpecificType(t);
	        }
	    }
	    gen.else();
	    reportTypeError(it);
	    gen.endIf();
	    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {
	        gen.assign(data, coerced);
	        assignParentData(it, coerced);
	    });
	    function coerceSpecificType(t) {
	        switch (t) {
	            case "string":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)
	                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)
	                    .elseIf((0, codegen_1._) `${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `""`);
	                return;
	            case "number":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "integer":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)
	                    .assign(coerced, (0, codegen_1._) `+${data}`);
	                return;
	            case "boolean":
	                gen
	                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)
	                    .assign(coerced, false)
	                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)
	                    .assign(coerced, true);
	                return;
	            case "null":
	                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);
	                gen.assign(coerced, null);
	                return;
	            case "array":
	                gen
	                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`)
	                    .assign(coerced, (0, codegen_1._) `[${data}]`);
	        }
	    }
	}
	function assignParentData({ gen, parentData, parentDataProperty }, expr) {
	    // TODO use gen.property
	    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));
	}
	function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
	    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
	    let cond;
	    switch (dataType) {
	        case "null":
	            return (0, codegen_1._) `${data} ${EQ} null`;
	        case "array":
	            cond = (0, codegen_1._) `Array.isArray(${data})`;
	            break;
	        case "object":
	            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
	            break;
	        case "integer":
	            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);
	            break;
	        case "number":
	            cond = numCond();
	            break;
	        default:
	            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;
	    }
	    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
	    function numCond(_cond = codegen_1.nil) {
	        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);
	    }
	}
	dataType.checkDataType = checkDataType;
	function checkDataTypes(dataTypes, data, strictNums, correct) {
	    if (dataTypes.length === 1) {
	        return checkDataType(dataTypes[0], data, strictNums, correct);
	    }
	    let cond;
	    const types = (0, util_1.toHash)(dataTypes);
	    if (types.array && types.object) {
	        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;
	        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;
	        delete types.null;
	        delete types.array;
	        delete types.object;
	    }
	    else {
	        cond = codegen_1.nil;
	    }
	    if (types.number)
	        delete types.integer;
	    for (const t in types)
	        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
	    return cond;
	}
	dataType.checkDataTypes = checkDataTypes;
	const typeError = {
	    message: ({ schema }) => `must be ${schema}`,
	    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,
	};
	function reportTypeError(it) {
	    const cxt = getTypeErrorContext(it);
	    (0, errors_1.reportError)(cxt, typeError);
	}
	dataType.reportTypeError = reportTypeError;
	function getTypeErrorContext(it) {
	    const { gen, data, schema } = it;
	    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
	    return {
	        gen,
	        keyword: "type",
	        data,
	        schema: schema.type,
	        schemaCode,
	        schemaValue: schemaCode,
	        parentSchema: schema,
	        params: {},
	        it,
	    };
	}
	
	return dataType;
}

var defaults = {};

var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	Object.defineProperty(defaults, "__esModule", { value: true });
	defaults.assignDefaults = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	function assignDefaults(it, ty) {
	    const { properties, items } = it.schema;
	    if (ty === "object" && properties) {
	        for (const key in properties) {
	            assignDefault(it, key, properties[key].default);
	        }
	    }
	    else if (ty === "array" && Array.isArray(items)) {
	        items.forEach((sch, i) => assignDefault(it, i, sch.default));
	    }
	}
	defaults.assignDefaults = assignDefaults;
	function assignDefault(it, prop, defaultValue) {
	    const { gen, compositeRule, data, opts } = it;
	    if (defaultValue === undefined)
	        return;
	    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;
	    if (compositeRule) {
	        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
	        return;
	    }
	    let condition = (0, codegen_1._) `${childData} === undefined`;
	    if (opts.useDefaults === "empty") {
	        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;
	    }
	    // `${childData} === undefined` +
	    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")
	    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
	}
	
	return defaults;
}

var keyword = {};

var code = {};

var hasRequiredCode;

function requireCode () {
	if (hasRequiredCode) return code;
	hasRequiredCode = 1;
	Object.defineProperty(code, "__esModule", { value: true });
	code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const names_1 = requireNames();
	const util_2 = requireUtil();
	function checkReportMissingProp(cxt, prop) {
	    const { gen, data, it } = cxt;
	    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
	        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);
	        cxt.error();
	    });
	}
	code.checkReportMissingProp = checkReportMissingProp;
	function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
	    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));
	}
	code.checkMissingProp = checkMissingProp;
	function reportMissingProp(cxt, missing) {
	    cxt.setParams({ missingProperty: missing }, true);
	    cxt.error();
	}
	code.reportMissingProp = reportMissingProp;
	function hasPropFunc(gen) {
	    return gen.scopeValue("func", {
	        // eslint-disable-next-line @typescript-eslint/unbound-method
	        ref: Object.prototype.hasOwnProperty,
	        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
	    });
	}
	code.hasPropFunc = hasPropFunc;
	function isOwnProperty(gen, data, property) {
	    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;
	}
	code.isOwnProperty = isOwnProperty;
	function propertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
	    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;
	}
	code.propertyInData = propertyInData;
	function noPropertyInData(gen, data, property, ownProperties) {
	    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;
	    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
	}
	code.noPropertyInData = noPropertyInData;
	function allSchemaProperties(schemaMap) {
	    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
	}
	code.allSchemaProperties = allSchemaProperties;
	function schemaProperties(it, schemaMap) {
	    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
	}
	code.schemaProperties = schemaProperties;
	function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
	    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
	    const valCxt = [
	        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
	        [names_1.default.parentData, it.parentData],
	        [names_1.default.parentDataProperty, it.parentDataProperty],
	        [names_1.default.rootData, names_1.default.rootData],
	    ];
	    if (it.opts.dynamicRef)
	        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
	    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;
	    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;
	}
	code.callValidateCode = callValidateCode;
	const newRegExp = (0, codegen_1._) `new RegExp`;
	function usePattern({ gen, it: { opts } }, pattern) {
	    const u = opts.unicodeRegExp ? "u" : "";
	    const { regExp } = opts.code;
	    const rx = regExp(pattern, u);
	    return gen.scopeValue("pattern", {
	        key: rx.toString(),
	        ref: rx,
	        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,
	    });
	}
	code.usePattern = usePattern;
	function validateArray(cxt) {
	    const { gen, data, keyword, it } = cxt;
	    const valid = gen.name("valid");
	    if (it.allErrors) {
	        const validArr = gen.let("valid", true);
	        validateItems(() => gen.assign(validArr, false));
	        return validArr;
	    }
	    gen.var(valid, true);
	    validateItems(() => gen.break());
	    return valid;
	    function validateItems(notValid) {
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        gen.forRange("i", 0, len, (i) => {
	            cxt.subschema({
	                keyword,
	                dataProp: i,
	                dataPropType: util_1.Type.Num,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), notValid);
	        });
	    }
	}
	code.validateArray = validateArray;
	function validateUnion(cxt) {
	    const { gen, schema, keyword, it } = cxt;
	    /* istanbul ignore if */
	    if (!Array.isArray(schema))
	        throw new Error("ajv implementation error");
	    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
	    if (alwaysValid && !it.opts.unevaluated)
	        return;
	    const valid = gen.let("valid", false);
	    const schValid = gen.name("_valid");
	    gen.block(() => schema.forEach((_sch, i) => {
	        const schCxt = cxt.subschema({
	            keyword,
	            schemaProp: i,
	            compositeRule: true,
	        }, schValid);
	        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);
	        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
	        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
	        // or if all properties and items were evaluated (it.props === true && it.items === true)
	        if (!merged)
	            gen.if((0, codegen_1.not)(valid));
	    }));
	    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	}
	code.validateUnion = validateUnion;
	
	return code;
}

var hasRequiredKeyword;

function requireKeyword () {
	if (hasRequiredKeyword) return keyword;
	hasRequiredKeyword = 1;
	Object.defineProperty(keyword, "__esModule", { value: true });
	keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const code_1 = requireCode();
	const errors_1 = requireErrors();
	function macroKeywordCode(cxt, def) {
	    const { gen, keyword, schema, parentSchema, it } = cxt;
	    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
	    const schemaRef = useKeyword(gen, keyword, macroSchema);
	    if (it.opts.validateSchema !== false)
	        it.self.validateSchema(macroSchema, true);
	    const valid = gen.name("valid");
	    cxt.subschema({
	        schema: macroSchema,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	        topSchemaRef: schemaRef,
	        compositeRule: true,
	    }, valid);
	    cxt.pass(valid, () => cxt.error(true));
	}
	keyword.macroKeywordCode = macroKeywordCode;
	function funcKeywordCode(cxt, def) {
	    var _a;
	    const { gen, keyword, schema, parentSchema, $data, it } = cxt;
	    checkAsyncKeyword(it, def);
	    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
	    const validateRef = useKeyword(gen, keyword, validate);
	    const valid = gen.let("valid");
	    cxt.block$data(valid, validateKeyword);
	    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
	    function validateKeyword() {
	        if (def.errors === false) {
	            assignValid();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => cxt.error());
	        }
	        else {
	            const ruleErrs = def.async ? validateAsync() : validateSync();
	            if (def.modifying)
	                modifyData(cxt);
	            reportErrs(() => addErrs(cxt, ruleErrs));
	        }
	    }
	    function validateAsync() {
	        const ruleErrs = gen.let("ruleErrs", null);
	        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));
	        return ruleErrs;
	    }
	    function validateSync() {
	        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;
	        gen.assign(validateErrs, null);
	        assignValid(codegen_1.nil);
	        return validateErrs;
	    }
	    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
	        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
	        const passSchema = !(("compile" in def && !$data) || def.schema === false);
	        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
	    }
	    function reportErrs(errors) {
	        var _a;
	        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
	    }
	}
	keyword.funcKeywordCode = funcKeywordCode;
	function modifyData(cxt) {
	    const { gen, data, it } = cxt;
	    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));
	}
	function addErrs(cxt, errs) {
	    const { gen } = cxt;
	    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {
	        gen
	            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)
	            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	        (0, errors_1.extendErrors)(cxt);
	    }, () => cxt.error());
	}
	function checkAsyncKeyword({ schemaEnv }, def) {
	    if (def.async && !schemaEnv.$async)
	        throw new Error("async keyword in sync schema");
	}
	function useKeyword(gen, keyword, result) {
	    if (result === undefined)
	        throw new Error(`keyword "${keyword}" failed to compile`);
	    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
	}
	function validSchemaType(schema, schemaType, allowUndefined = false) {
	    // TODO add tests
	    return (!schemaType.length ||
	        schemaType.some((st) => st === "array"
	            ? Array.isArray(schema)
	            : st === "object"
	                ? schema && typeof schema == "object" && !Array.isArray(schema)
	                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
	}
	keyword.validSchemaType = validSchemaType;
	function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
	    /* istanbul ignore if */
	    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
	        throw new Error("ajv implementation error");
	    }
	    const deps = def.dependencies;
	    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
	        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
	    }
	    if (def.validateSchema) {
	        const valid = def.validateSchema(schema[keyword]);
	        if (!valid) {
	            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +
	                self.errorsText(def.validateSchema.errors);
	            if (opts.validateSchema === "log")
	                self.logger.error(msg);
	            else
	                throw new Error(msg);
	        }
	    }
	}
	keyword.validateKeywordUsage = validateKeywordUsage;
	
	return keyword;
}

var subschema = {};

var hasRequiredSubschema;

function requireSubschema () {
	if (hasRequiredSubschema) return subschema;
	hasRequiredSubschema = 1;
	Object.defineProperty(subschema, "__esModule", { value: true });
	subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
	    if (keyword !== undefined && schema !== undefined) {
	        throw new Error('both "keyword" and "schema" passed, only one allowed');
	    }
	    if (keyword !== undefined) {
	        const sch = it.schema[keyword];
	        return schemaProp === undefined
	            ? {
	                schema: sch,
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}`,
	            }
	            : {
	                schema: sch[schemaProp],
	                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
	                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,
	            };
	    }
	    if (schema !== undefined) {
	        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
	            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
	        }
	        return {
	            schema,
	            schemaPath,
	            topSchemaRef,
	            errSchemaPath,
	        };
	    }
	    throw new Error('either "keyword" or "schema" must be passed');
	}
	subschema.getSubschema = getSubschema;
	function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
	    if (data !== undefined && dataProp !== undefined) {
	        throw new Error('both "data" and "dataProp" passed, only one allowed');
	    }
	    const { gen } = it;
	    if (dataProp !== undefined) {
	        const { errorPath, dataPathArr, opts } = it;
	        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
	        dataContextProps(nextData);
	        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
	        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;
	        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
	    }
	    if (data !== undefined) {
	        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
	        dataContextProps(nextData);
	        if (propertyName !== undefined)
	            subschema.propertyName = propertyName;
	        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
	    }
	    if (dataTypes)
	        subschema.dataTypes = dataTypes;
	    function dataContextProps(_nextData) {
	        subschema.data = _nextData;
	        subschema.dataLevel = it.dataLevel + 1;
	        subschema.dataTypes = [];
	        it.definedProperties = new Set();
	        subschema.parentData = it.data;
	        subschema.dataNames = [...it.dataNames, _nextData];
	    }
	}
	subschema.extendSubschemaData = extendSubschemaData;
	function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
	    if (compositeRule !== undefined)
	        subschema.compositeRule = compositeRule;
	    if (createErrors !== undefined)
	        subschema.createErrors = createErrors;
	    if (allErrors !== undefined)
	        subschema.allErrors = allErrors;
	    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
	    subschema.jtdMetadata = jtdMetadata; // not inherited
	}
	subschema.extendSubschemaMode = extendSubschemaMode;
	
	return subschema;
}

var resolve = {};

var jsonSchemaTraverse = {exports: {}};

var hasRequiredJsonSchemaTraverse;

function requireJsonSchemaTraverse () {
	if (hasRequiredJsonSchemaTraverse) return jsonSchemaTraverse.exports;
	hasRequiredJsonSchemaTraverse = 1;

	var traverse = jsonSchemaTraverse.exports = function (schema, opts, cb) {
	  // Legacy support for v0.3.1 and earlier.
	  if (typeof opts == 'function') {
	    cb = opts;
	    opts = {};
	  }

	  cb = opts.cb || cb;
	  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
	  var post = cb.post || function() {};

	  _traverse(opts, pre, post, schema, '', schema);
	};


	traverse.keywords = {
	  additionalItems: true,
	  items: true,
	  contains: true,
	  additionalProperties: true,
	  propertyNames: true,
	  not: true,
	  if: true,
	  then: true,
	  else: true
	};

	traverse.arrayKeywords = {
	  items: true,
	  allOf: true,
	  anyOf: true,
	  oneOf: true
	};

	traverse.propsKeywords = {
	  $defs: true,
	  definitions: true,
	  properties: true,
	  patternProperties: true,
	  dependencies: true
	};

	traverse.skipKeywords = {
	  default: true,
	  enum: true,
	  const: true,
	  required: true,
	  maximum: true,
	  minimum: true,
	  exclusiveMaximum: true,
	  exclusiveMinimum: true,
	  multipleOf: true,
	  maxLength: true,
	  minLength: true,
	  pattern: true,
	  format: true,
	  maxItems: true,
	  minItems: true,
	  uniqueItems: true,
	  maxProperties: true,
	  minProperties: true
	};


	function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
	  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
	    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	    for (var key in schema) {
	      var sch = schema[key];
	      if (Array.isArray(sch)) {
	        if (key in traverse.arrayKeywords) {
	          for (var i=0; i<sch.length; i++)
	            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
	        }
	      } else if (key in traverse.propsKeywords) {
	        if (sch && typeof sch == 'object') {
	          for (var prop in sch)
	            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
	        }
	      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
	        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
	      }
	    }
	    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
	  }
	}


	function escapeJsonPtr(str) {
	  return str.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	return jsonSchemaTraverse.exports;
}

var hasRequiredResolve;

function requireResolve () {
	if (hasRequiredResolve) return resolve;
	hasRequiredResolve = 1;
	Object.defineProperty(resolve, "__esModule", { value: true });
	resolve.getSchemaRefs = resolve.resolveUrl = resolve.normalizeId = resolve._getFullPath = resolve.getFullPath = resolve.inlineRef = void 0;
	const util_1 = requireUtil();
	const equal = requireFastDeepEqual();
	const traverse = requireJsonSchemaTraverse();
	// TODO refactor to use keyword definitions
	const SIMPLE_INLINED = new Set([
	    "type",
	    "format",
	    "pattern",
	    "maxLength",
	    "minLength",
	    "maxProperties",
	    "minProperties",
	    "maxItems",
	    "minItems",
	    "maximum",
	    "minimum",
	    "uniqueItems",
	    "multipleOf",
	    "required",
	    "enum",
	    "const",
	]);
	function inlineRef(schema, limit = true) {
	    if (typeof schema == "boolean")
	        return true;
	    if (limit === true)
	        return !hasRef(schema);
	    if (!limit)
	        return false;
	    return countKeys(schema) <= limit;
	}
	resolve.inlineRef = inlineRef;
	const REF_KEYWORDS = new Set([
	    "$ref",
	    "$recursiveRef",
	    "$recursiveAnchor",
	    "$dynamicRef",
	    "$dynamicAnchor",
	]);
	function hasRef(schema) {
	    for (const key in schema) {
	        if (REF_KEYWORDS.has(key))
	            return true;
	        const sch = schema[key];
	        if (Array.isArray(sch) && sch.some(hasRef))
	            return true;
	        if (typeof sch == "object" && hasRef(sch))
	            return true;
	    }
	    return false;
	}
	function countKeys(schema) {
	    let count = 0;
	    for (const key in schema) {
	        if (key === "$ref")
	            return Infinity;
	        count++;
	        if (SIMPLE_INLINED.has(key))
	            continue;
	        if (typeof schema[key] == "object") {
	            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));
	        }
	        if (count === Infinity)
	            return Infinity;
	    }
	    return count;
	}
	function getFullPath(resolver, id = "", normalize) {
	    if (normalize !== false)
	        id = normalizeId(id);
	    const p = resolver.parse(id);
	    return _getFullPath(resolver, p);
	}
	resolve.getFullPath = getFullPath;
	function _getFullPath(resolver, p) {
	    const serialized = resolver.serialize(p);
	    return serialized.split("#")[0] + "#";
	}
	resolve._getFullPath = _getFullPath;
	const TRAILING_SLASH_HASH = /#\/?$/;
	function normalizeId(id) {
	    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
	}
	resolve.normalizeId = normalizeId;
	function resolveUrl(resolver, baseId, id) {
	    id = normalizeId(id);
	    return resolver.resolve(baseId, id);
	}
	resolve.resolveUrl = resolveUrl;
	const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
	function getSchemaRefs(schema, baseId) {
	    if (typeof schema == "boolean")
	        return {};
	    const { schemaId, uriResolver } = this.opts;
	    const schId = normalizeId(schema[schemaId] || baseId);
	    const baseIds = { "": schId };
	    const pathPrefix = getFullPath(uriResolver, schId, false);
	    const localRefs = {};
	    const schemaRefs = new Set();
	    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
	        if (parentJsonPtr === undefined)
	            return;
	        const fullPath = pathPrefix + jsonPtr;
	        let innerBaseId = baseIds[parentJsonPtr];
	        if (typeof sch[schemaId] == "string")
	            innerBaseId = addRef.call(this, sch[schemaId]);
	        addAnchor.call(this, sch.$anchor);
	        addAnchor.call(this, sch.$dynamicAnchor);
	        baseIds[jsonPtr] = innerBaseId;
	        function addRef(ref) {
	            // eslint-disable-next-line @typescript-eslint/unbound-method
	            const _resolve = this.opts.uriResolver.resolve;
	            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
	            if (schemaRefs.has(ref))
	                throw ambiguos(ref);
	            schemaRefs.add(ref);
	            let schOrRef = this.refs[ref];
	            if (typeof schOrRef == "string")
	                schOrRef = this.refs[schOrRef];
	            if (typeof schOrRef == "object") {
	                checkAmbiguosRef(sch, schOrRef.schema, ref);
	            }
	            else if (ref !== normalizeId(fullPath)) {
	                if (ref[0] === "#") {
	                    checkAmbiguosRef(sch, localRefs[ref], ref);
	                    localRefs[ref] = sch;
	                }
	                else {
	                    this.refs[ref] = fullPath;
	                }
	            }
	            return ref;
	        }
	        function addAnchor(anchor) {
	            if (typeof anchor == "string") {
	                if (!ANCHOR.test(anchor))
	                    throw new Error(`invalid anchor "${anchor}"`);
	                addRef.call(this, `#${anchor}`);
	            }
	        }
	    });
	    return localRefs;
	    function checkAmbiguosRef(sch1, sch2, ref) {
	        if (sch2 !== undefined && !equal(sch1, sch2))
	            throw ambiguos(ref);
	    }
	    function ambiguos(ref) {
	        return new Error(`reference "${ref}" resolves to more than one schema`);
	    }
	}
	resolve.getSchemaRefs = getSchemaRefs;
	
	return resolve;
}

var hasRequiredValidate;

function requireValidate () {
	if (hasRequiredValidate) return validate;
	hasRequiredValidate = 1;
	Object.defineProperty(validate, "__esModule", { value: true });
	validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
	const boolSchema_1 = requireBoolSchema();
	const dataType_1 = requireDataType();
	const applicability_1 = requireApplicability();
	const dataType_2 = requireDataType();
	const defaults_1 = requireDefaults();
	const keyword_1 = requireKeyword();
	const subschema_1 = requireSubschema();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil();
	const errors_1 = requireErrors();
	// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
	function validateFunctionCode(it) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            topSchemaObjCode(it);
	            return;
	        }
	    }
	    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
	}
	validate.validateFunctionCode = validateFunctionCode;
	function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
	    if (opts.code.es5) {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
	            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);
	            destructureValCxtES5(gen, opts);
	            gen.code(body);
	        });
	    }
	    else {
	        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
	    }
	}
	function destructureValCxt(opts) {
	    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
	}
	function destructureValCxtES5(gen, opts) {
	    gen.if(names_1.default.valCxt, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
	        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
	    }, () => {
	        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
	        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
	        gen.var(names_1.default.rootData, names_1.default.data);
	        if (opts.dynamicRef)
	            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);
	    });
	}
	function topSchemaObjCode(it) {
	    const { schema, opts, gen } = it;
	    validateFunction(it, () => {
	        if (opts.$comment && schema.$comment)
	            commentKeyword(it);
	        checkNoDefault(it);
	        gen.let(names_1.default.vErrors, null);
	        gen.let(names_1.default.errors, 0);
	        if (opts.unevaluated)
	            resetEvaluated(it);
	        typeAndKeywords(it);
	        returnResults(it);
	    });
	    return;
	}
	function resetEvaluated(it) {
	    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
	    const { gen, validateName } = it;
	    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));
	    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));
	}
	function funcSourceUrl(schema, opts) {
	    const schId = typeof schema == "object" && schema[opts.schemaId];
	    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;
	}
	// schema compilation - this function is used recursively to generate code for sub-schemas
	function subschemaCode(it, valid) {
	    if (isSchemaObj(it)) {
	        checkKeywords(it);
	        if (schemaCxtHasRules(it)) {
	            subSchemaObjCode(it, valid);
	            return;
	        }
	    }
	    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
	}
	function schemaCxtHasRules({ schema, self }) {
	    if (typeof schema == "boolean")
	        return !schema;
	    for (const key in schema)
	        if (self.RULES.all[key])
	            return true;
	    return false;
	}
	function isSchemaObj(it) {
	    return typeof it.schema != "boolean";
	}
	function subSchemaObjCode(it, valid) {
	    const { schema, gen, opts } = it;
	    if (opts.$comment && schema.$comment)
	        commentKeyword(it);
	    updateContext(it);
	    checkAsyncSchema(it);
	    const errsCount = gen.const("_errs", names_1.default.errors);
	    typeAndKeywords(it, errsCount);
	    // TODO var
	    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	}
	function checkKeywords(it) {
	    (0, util_1.checkUnknownRules)(it);
	    checkRefsAndKeywords(it);
	}
	function typeAndKeywords(it, errsCount) {
	    if (it.opts.jtd)
	        return schemaKeywords(it, [], false, errsCount);
	    const types = (0, dataType_1.getSchemaTypes)(it.schema);
	    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
	    schemaKeywords(it, types, !checkedTypes, errsCount);
	}
	function checkRefsAndKeywords(it) {
	    const { schema, errSchemaPath, opts, self } = it;
	    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
	        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
	    }
	}
	function checkNoDefault(it) {
	    const { schema, opts } = it;
	    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
	        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
	    }
	}
	function updateContext(it) {
	    const schId = it.schema[it.opts.schemaId];
	    if (schId)
	        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
	}
	function checkAsyncSchema(it) {
	    if (it.schema.$async && !it.schemaEnv.$async)
	        throw new Error("async schema in sync schema");
	}
	function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
	    const msg = schema.$comment;
	    if (opts.$comment === true) {
	        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);
	    }
	    else if (typeof opts.$comment == "function") {
	        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;
	        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
	        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
	    }
	}
	function returnResults(it) {
	    const { gen, schemaEnv, validateName, ValidationError, opts } = it;
	    if (schemaEnv.$async) {
	        // TODO assign unevaluated
	        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));
	    }
	    else {
	        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);
	        if (opts.unevaluated)
	            assignEvaluated(it);
	        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);
	    }
	}
	function assignEvaluated({ gen, evaluated, props, items }) {
	    if (props instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.props`, props);
	    if (items instanceof codegen_1.Name)
	        gen.assign((0, codegen_1._) `${evaluated}.items`, items);
	}
	function schemaKeywords(it, types, typeErrors, errsCount) {
	    const { gen, schema, data, allErrors, opts, self } = it;
	    const { RULES } = self;
	    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
	        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
	        return;
	    }
	    if (!opts.jtd)
	        checkStrictTypes(it, types);
	    gen.block(() => {
	        for (const group of RULES.rules)
	            groupKeywords(group);
	        groupKeywords(RULES.post);
	    });
	    function groupKeywords(group) {
	        if (!(0, applicability_1.shouldUseGroup)(schema, group))
	            return;
	        if (group.type) {
	            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
	            iterateKeywords(it, group);
	            if (types.length === 1 && types[0] === group.type && typeErrors) {
	                gen.else();
	                (0, dataType_2.reportTypeError)(it);
	            }
	            gen.endIf();
	        }
	        else {
	            iterateKeywords(it, group);
	        }
	        // TODO make it "ok" call?
	        if (!allErrors)
	            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);
	    }
	}
	function iterateKeywords(it, group) {
	    const { gen, schema, opts: { useDefaults }, } = it;
	    if (useDefaults)
	        (0, defaults_1.assignDefaults)(it, group.type);
	    gen.block(() => {
	        for (const rule of group.rules) {
	            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
	                keywordCode(it, rule.keyword, rule.definition, group.type);
	            }
	        }
	    });
	}
	function checkStrictTypes(it, types) {
	    if (it.schemaEnv.meta || !it.opts.strictTypes)
	        return;
	    checkContextTypes(it, types);
	    if (!it.opts.allowUnionTypes)
	        checkMultipleTypes(it, types);
	    checkKeywordTypes(it, it.dataTypes);
	}
	function checkContextTypes(it, types) {
	    if (!types.length)
	        return;
	    if (!it.dataTypes.length) {
	        it.dataTypes = types;
	        return;
	    }
	    types.forEach((t) => {
	        if (!includesType(it.dataTypes, t)) {
	            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
	        }
	    });
	    narrowSchemaTypes(it, types);
	}
	function checkMultipleTypes(it, ts) {
	    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
	        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
	    }
	}
	function checkKeywordTypes(it, ts) {
	    const rules = it.self.RULES.all;
	    for (const keyword in rules) {
	        const rule = rules[keyword];
	        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
	            const { type } = rule.definition;
	            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
	                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
	            }
	        }
	    }
	}
	function hasApplicableType(schTs, kwdT) {
	    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
	}
	function includesType(ts, t) {
	    return ts.includes(t) || (t === "integer" && ts.includes("number"));
	}
	function narrowSchemaTypes(it, withTypes) {
	    const ts = [];
	    for (const t of it.dataTypes) {
	        if (includesType(withTypes, t))
	            ts.push(t);
	        else if (withTypes.includes("integer") && t === "number")
	            ts.push("integer");
	    }
	    it.dataTypes = ts;
	}
	function strictTypesError(it, msg) {
	    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	    msg += ` at "${schemaPath}" (strictTypes)`;
	    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
	}
	class KeywordCxt {
	    constructor(it, def, keyword) {
	        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
	        this.gen = it.gen;
	        this.allErrors = it.allErrors;
	        this.keyword = keyword;
	        this.data = it.data;
	        this.schema = it.schema[keyword];
	        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
	        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
	        this.schemaType = def.schemaType;
	        this.parentSchema = it.schema;
	        this.params = {};
	        this.it = it;
	        this.def = def;
	        if (this.$data) {
	            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
	        }
	        else {
	            this.schemaCode = this.schemaValue;
	            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
	                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
	            }
	        }
	        if ("code" in def ? def.trackErrors : def.errors !== false) {
	            this.errsCount = it.gen.const("_errs", names_1.default.errors);
	        }
	    }
	    result(condition, successAction, failAction) {
	        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
	    }
	    failResult(condition, successAction, failAction) {
	        this.gen.if(condition);
	        if (failAction)
	            failAction();
	        else
	            this.error();
	        if (successAction) {
	            this.gen.else();
	            successAction();
	            if (this.allErrors)
	                this.gen.endIf();
	        }
	        else {
	            if (this.allErrors)
	                this.gen.endIf();
	            else
	                this.gen.else();
	        }
	    }
	    pass(condition, failAction) {
	        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
	    }
	    fail(condition) {
	        if (condition === undefined) {
	            this.error();
	            if (!this.allErrors)
	                this.gen.if(false); // this branch will be removed by gen.optimize
	            return;
	        }
	        this.gen.if(condition);
	        this.error();
	        if (this.allErrors)
	            this.gen.endIf();
	        else
	            this.gen.else();
	    }
	    fail$data(condition) {
	        if (!this.$data)
	            return this.fail(condition);
	        const { schemaCode } = this;
	        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
	    }
	    error(append, errorParams, errorPaths) {
	        if (errorParams) {
	            this.setParams(errorParams);
	            this._error(append, errorPaths);
	            this.setParams({});
	            return;
	        }
	        this._error(append, errorPaths);
	    }
	    _error(append, errorPaths) {
	        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
	    }
	    $dataError() {
	        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
	    }
	    reset() {
	        if (this.errsCount === undefined)
	            throw new Error('add "trackErrors" to keyword definition');
	        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
	    }
	    ok(cond) {
	        if (!this.allErrors)
	            this.gen.if(cond);
	    }
	    setParams(obj, assign) {
	        if (assign)
	            Object.assign(this.params, obj);
	        else
	            this.params = obj;
	    }
	    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
	        this.gen.block(() => {
	            this.check$data(valid, $dataValid);
	            codeBlock();
	        });
	    }
	    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
	        if (!this.$data)
	            return;
	        const { gen, schemaCode, schemaType, def } = this;
	        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));
	        if (valid !== codegen_1.nil)
	            gen.assign(valid, true);
	        if (schemaType.length || def.validateSchema) {
	            gen.elseIf(this.invalid$data());
	            this.$dataError();
	            if (valid !== codegen_1.nil)
	                gen.assign(valid, false);
	        }
	        gen.else();
	    }
	    invalid$data() {
	        const { gen, schemaCode, schemaType, def, it } = this;
	        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
	        function wrong$DataType() {
	            if (schemaType.length) {
	                /* istanbul ignore if */
	                if (!(schemaCode instanceof codegen_1.Name))
	                    throw new Error("ajv implementation error");
	                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
	                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
	            }
	            return codegen_1.nil;
	        }
	        function invalid$DataSchema() {
	            if (def.validateSchema) {
	                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone
	                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;
	            }
	            return codegen_1.nil;
	        }
	    }
	    subschema(appl, valid) {
	        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
	        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
	        (0, subschema_1.extendSubschemaMode)(subschema, appl);
	        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
	        subschemaCode(nextContext, valid);
	        return nextContext;
	    }
	    mergeEvaluated(schemaCxt, toName) {
	        const { it, gen } = this;
	        if (!it.opts.unevaluated)
	            return;
	        if (it.props !== true && schemaCxt.props !== undefined) {
	            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
	        }
	        if (it.items !== true && schemaCxt.items !== undefined) {
	            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
	        }
	    }
	    mergeValidEvaluated(schemaCxt, valid) {
	        const { it, gen } = this;
	        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
	            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
	            return true;
	        }
	    }
	}
	validate.KeywordCxt = KeywordCxt;
	function keywordCode(it, keyword, def, ruleType) {
	    const cxt = new KeywordCxt(it, def, keyword);
	    if ("code" in def) {
	        def.code(cxt, ruleType);
	    }
	    else if (cxt.$data && def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	    else if ("macro" in def) {
	        (0, keyword_1.macroKeywordCode)(cxt, def);
	    }
	    else if (def.compile || def.validate) {
	        (0, keyword_1.funcKeywordCode)(cxt, def);
	    }
	}
	const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
	const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
	function getData($data, { dataLevel, dataNames, dataPathArr }) {
	    let jsonPointer;
	    let data;
	    if ($data === "")
	        return names_1.default.rootData;
	    if ($data[0] === "/") {
	        if (!JSON_POINTER.test($data))
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        jsonPointer = $data;
	        data = names_1.default.rootData;
	    }
	    else {
	        const matches = RELATIVE_JSON_POINTER.exec($data);
	        if (!matches)
	            throw new Error(`Invalid JSON-pointer: ${$data}`);
	        const up = +matches[1];
	        jsonPointer = matches[2];
	        if (jsonPointer === "#") {
	            if (up >= dataLevel)
	                throw new Error(errorMsg("property/index", up));
	            return dataPathArr[dataLevel - up];
	        }
	        if (up > dataLevel)
	            throw new Error(errorMsg("data", up));
	        data = dataNames[dataLevel - up];
	        if (!jsonPointer)
	            return data;
	    }
	    let expr = data;
	    const segments = jsonPointer.split("/");
	    for (const segment of segments) {
	        if (segment) {
	            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
	            expr = (0, codegen_1._) `${expr} && ${data}`;
	        }
	    }
	    return expr;
	    function errorMsg(pointerType, up) {
	        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
	    }
	}
	validate.getData = getData;
	
	return validate;
}

var validation_error = {};

var hasRequiredValidation_error;

function requireValidation_error () {
	if (hasRequiredValidation_error) return validation_error;
	hasRequiredValidation_error = 1;
	Object.defineProperty(validation_error, "__esModule", { value: true });
	class ValidationError extends Error {
	    constructor(errors) {
	        super("validation failed");
	        this.errors = errors;
	        this.ajv = this.validation = true;
	    }
	}
	validation_error.default = ValidationError;
	
	return validation_error;
}

var ref_error = {};

var hasRequiredRef_error;

function requireRef_error () {
	if (hasRequiredRef_error) return ref_error;
	hasRequiredRef_error = 1;
	Object.defineProperty(ref_error, "__esModule", { value: true });
	const resolve_1 = requireResolve();
	class MissingRefError extends Error {
	    constructor(resolver, baseId, ref, msg) {
	        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
	        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
	        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
	    }
	}
	ref_error.default = MissingRefError;
	
	return ref_error;
}

var compile = {};

var hasRequiredCompile;

function requireCompile () {
	if (hasRequiredCompile) return compile;
	hasRequiredCompile = 1;
	Object.defineProperty(compile, "__esModule", { value: true });
	compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
	const codegen_1 = requireCodegen();
	const validation_error_1 = requireValidation_error();
	const names_1 = requireNames();
	const resolve_1 = requireResolve();
	const util_1 = requireUtil();
	const validate_1 = requireValidate();
	class SchemaEnv {
	    constructor(env) {
	        var _a;
	        this.refs = {};
	        this.dynamicAnchors = {};
	        let schema;
	        if (typeof env.schema == "object")
	            schema = env.schema;
	        this.schema = env.schema;
	        this.schemaId = env.schemaId;
	        this.root = env.root || this;
	        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
	        this.schemaPath = env.schemaPath;
	        this.localRefs = env.localRefs;
	        this.meta = env.meta;
	        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
	        this.refs = {};
	    }
	}
	compile.SchemaEnv = SchemaEnv;
	// let codeSize = 0
	// let nodeCount = 0
	// Compiles schema in SchemaEnv
	function compileSchema(sch) {
	    // TODO refactor - remove compilations
	    const _sch = getCompilingSchema.call(this, sch);
	    if (_sch)
	        return _sch;
	    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails
	    const { es5, lines } = this.opts.code;
	    const { ownProperties } = this.opts;
	    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
	    let _ValidationError;
	    if (sch.$async) {
	        _ValidationError = gen.scopeValue("Error", {
	            ref: validation_error_1.default,
	            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,
	        });
	    }
	    const validateName = gen.scopeName("validate");
	    sch.validateName = validateName;
	    const schemaCxt = {
	        gen,
	        allErrors: this.opts.allErrors,
	        data: names_1.default.data,
	        parentData: names_1.default.parentData,
	        parentDataProperty: names_1.default.parentDataProperty,
	        dataNames: [names_1.default.data],
	        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?
	        dataLevel: 0,
	        dataTypes: [],
	        definedProperties: new Set(),
	        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true
	            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }
	            : { ref: sch.schema }),
	        validateName,
	        ValidationError: _ValidationError,
	        schema: sch.schema,
	        schemaEnv: sch,
	        rootId,
	        baseId: sch.baseId || rootId,
	        schemaPath: codegen_1.nil,
	        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
	        errorPath: (0, codegen_1._) `""`,
	        opts: this.opts,
	        self: this,
	    };
	    let sourceCode;
	    try {
	        this._compilations.add(sch);
	        (0, validate_1.validateFunctionCode)(schemaCxt);
	        gen.optimize(this.opts.code.optimize);
	        // gen.optimize(1)
	        const validateCode = gen.toString();
	        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
	        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))
	        if (this.opts.code.process)
	            sourceCode = this.opts.code.process(sourceCode, sch);
	        // console.log("\n\n\n *** \n", sourceCode)
	        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
	        const validate = makeValidate(this, this.scope.get());
	        this.scope.value(validateName, { ref: validate });
	        validate.errors = null;
	        validate.schema = sch.schema;
	        validate.schemaEnv = sch;
	        if (sch.$async)
	            validate.$async = true;
	        if (this.opts.code.source === true) {
	            validate.source = { validateName, validateCode, scopeValues: gen._values };
	        }
	        if (this.opts.unevaluated) {
	            const { props, items } = schemaCxt;
	            validate.evaluated = {
	                props: props instanceof codegen_1.Name ? undefined : props,
	                items: items instanceof codegen_1.Name ? undefined : items,
	                dynamicProps: props instanceof codegen_1.Name,
	                dynamicItems: items instanceof codegen_1.Name,
	            };
	            if (validate.source)
	                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
	        }
	        sch.validate = validate;
	        return sch;
	    }
	    catch (e) {
	        delete sch.validate;
	        delete sch.validateName;
	        if (sourceCode)
	            this.logger.error("Error compiling schema, function code:", sourceCode);
	        // console.log("\n\n\n *** \n", sourceCode, this.opts)
	        throw e;
	    }
	    finally {
	        this._compilations.delete(sch);
	    }
	}
	compile.compileSchema = compileSchema;
	function resolveRef(root, baseId, ref) {
	    var _a;
	    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
	    const schOrFunc = root.refs[ref];
	    if (schOrFunc)
	        return schOrFunc;
	    let _sch = resolve.call(this, root, ref);
	    if (_sch === undefined) {
	        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv
	        const { schemaId } = this.opts;
	        if (schema)
	            _sch = new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    if (_sch === undefined)
	        return;
	    return (root.refs[ref] = inlineOrCompile.call(this, _sch));
	}
	compile.resolveRef = resolveRef;
	function inlineOrCompile(sch) {
	    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
	        return sch.schema;
	    return sch.validate ? sch : compileSchema.call(this, sch);
	}
	// Index of schema compilation in the currently compiled list
	function getCompilingSchema(schEnv) {
	    for (const sch of this._compilations) {
	        if (sameSchemaEnv(sch, schEnv))
	            return sch;
	    }
	}
	compile.getCompilingSchema = getCompilingSchema;
	function sameSchemaEnv(s1, s2) {
	    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
	}
	// resolve and compile the references ($ref)
	// TODO returns AnySchemaObject (if the schema can be inlined) or validation function
	function resolve(root, // information about the root schema for the current schema
	ref // reference to resolve
	) {
	    let sch;
	    while (typeof (sch = this.refs[ref]) == "string")
	        ref = sch;
	    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
	}
	// Resolve schema, its root and baseId
	function resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it
	ref // reference to resolve
	) {
	    const p = this.opts.uriResolver.parse(ref);
	    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
	    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
	    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests
	    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
	        return getJsonPointer.call(this, p, root);
	    }
	    const id = (0, resolve_1.normalizeId)(refPath);
	    const schOrRef = this.refs[id] || this.schemas[id];
	    if (typeof schOrRef == "string") {
	        const sch = resolveSchema.call(this, root, schOrRef);
	        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
	            return;
	        return getJsonPointer.call(this, p, sch);
	    }
	    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
	        return;
	    if (!schOrRef.validate)
	        compileSchema.call(this, schOrRef);
	    if (id === (0, resolve_1.normalizeId)(ref)) {
	        const { schema } = schOrRef;
	        const { schemaId } = this.opts;
	        const schId = schema[schemaId];
	        if (schId)
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        return new SchemaEnv({ schema, schemaId, root, baseId });
	    }
	    return getJsonPointer.call(this, p, schOrRef);
	}
	compile.resolveSchema = resolveSchema;
	const PREVENT_SCOPE_CHANGE = new Set([
	    "properties",
	    "patternProperties",
	    "enum",
	    "dependencies",
	    "definitions",
	]);
	function getJsonPointer(parsedRef, { baseId, schema, root }) {
	    var _a;
	    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
	        return;
	    for (const part of parsedRef.fragment.slice(1).split("/")) {
	        if (typeof schema === "boolean")
	            return;
	        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
	        if (partSchema === undefined)
	            return;
	        schema = partSchema;
	        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?
	        const schId = typeof schema === "object" && schema[this.opts.schemaId];
	        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
	            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
	        }
	    }
	    let env;
	    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
	        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
	        env = resolveSchema.call(this, root, $ref);
	    }
	    // even though resolution failed we need to return SchemaEnv to throw exception
	    // so that compileAsync loads missing schema.
	    const { schemaId } = this.opts;
	    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
	    if (env.schema !== env.root.schema)
	        return env;
	    return undefined;
	}
	
	return compile;
}

var $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var type$1 = "object";
var required$1 = [
	"$data"
];
var properties$2 = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties$1 = false;
var require$$9 = {
	$id: $id$1,
	description: description,
	type: type$1,
	required: required$1,
	properties: properties$2,
	additionalProperties: additionalProperties$1
};

var uri = {};

var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;
	Object.defineProperty(uri, "__esModule", { value: true });
	const uri$1 = requireFastUri();
	uri$1.code = 'require("ajv/dist/runtime/uri").default';
	uri.default = uri$1;
	
	return uri;
}

var hasRequiredCore$1;

function requireCore$1 () {
	if (hasRequiredCore$1) return core$1;
	hasRequiredCore$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		const validation_error_1 = requireValidation_error();
		const ref_error_1 = requireRef_error();
		const rules_1 = requireRules();
		const compile_1 = requireCompile();
		const codegen_2 = requireCodegen();
		const resolve_1 = requireResolve();
		const dataType_1 = requireDataType();
		const util_1 = requireUtil();
		const $dataRefSchema = require$$9;
		const uri_1 = requireUri();
		const defaultRegExp = (str, flags) => new RegExp(str, flags);
		defaultRegExp.code = "new RegExp";
		const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
		const EXT_SCOPE_NAMES = new Set([
		    "validate",
		    "serialize",
		    "parse",
		    "wrapper",
		    "root",
		    "schema",
		    "keyword",
		    "pattern",
		    "formats",
		    "validate$data",
		    "func",
		    "obj",
		    "Error",
		]);
		const removedOptions = {
		    errorDataPath: "",
		    format: "`validateFormats: false` can be used instead.",
		    nullable: '"nullable" keyword is supported by default.',
		    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
		    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
		    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
		    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
		    sourceCode: "Use option `code: {source: true}`",
		    strictDefaults: "It is default now, see option `strict`.",
		    strictKeywords: "It is default now, see option `strict`.",
		    uniqueItems: '"uniqueItems" keyword is always validated.',
		    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
		    cache: "Map is used as cache, schema object as key.",
		    serialize: "Map is used as cache, schema object as key.",
		    ajvErrors: "It is default now.",
		};
		const deprecatedOptions = {
		    ignoreKeywordsWithRef: "",
		    jsPropertySyntax: "",
		    unicode: '"minLength"/"maxLength" account for unicode characters by default.',
		};
		const MAX_EXPRESSION = 200;
		// eslint-disable-next-line complexity
		function requiredOptions(o) {
		    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
		    const s = o.strict;
		    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
		    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
		    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
		    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
		    return {
		        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
		        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
		        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
		        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
		        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
		        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
		        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
		        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
		        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
		        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
		        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
		        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
		        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
		        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
		        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
		        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
		        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
		        uriResolver: uriResolver,
		    };
		}
		class Ajv {
		    constructor(opts = {}) {
		        this.schemas = {};
		        this.refs = {};
		        this.formats = {};
		        this._compilations = new Set();
		        this._loading = {};
		        this._cache = new Map();
		        opts = this.opts = { ...opts, ...requiredOptions(opts) };
		        const { es5, lines } = this.opts.code;
		        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
		        this.logger = getLogger(opts.logger);
		        const formatOpt = opts.validateFormats;
		        opts.validateFormats = false;
		        this.RULES = (0, rules_1.getRules)();
		        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
		        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
		        this._metaOpts = getMetaSchemaOptions.call(this);
		        if (opts.formats)
		            addInitialFormats.call(this);
		        this._addVocabularies();
		        this._addDefaultMetaSchema();
		        if (opts.keywords)
		            addInitialKeywords.call(this, opts.keywords);
		        if (typeof opts.meta == "object")
		            this.addMetaSchema(opts.meta);
		        addInitialSchemas.call(this);
		        opts.validateFormats = formatOpt;
		    }
		    _addVocabularies() {
		        this.addKeyword("$async");
		    }
		    _addDefaultMetaSchema() {
		        const { $data, meta, schemaId } = this.opts;
		        let _dataRefSchema = $dataRefSchema;
		        if (schemaId === "id") {
		            _dataRefSchema = { ...$dataRefSchema };
		            _dataRefSchema.id = _dataRefSchema.$id;
		            delete _dataRefSchema.$id;
		        }
		        if (meta && $data)
		            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
		    }
		    defaultMeta() {
		        const { meta, schemaId } = this.opts;
		        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);
		    }
		    validate(schemaKeyRef, // key, ref or schema object
		    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
		    data // to be validated
		    ) {
		        let v;
		        if (typeof schemaKeyRef == "string") {
		            v = this.getSchema(schemaKeyRef);
		            if (!v)
		                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
		        }
		        else {
		            v = this.compile(schemaKeyRef);
		        }
		        const valid = v(data);
		        if (!("$async" in v))
		            this.errors = v.errors;
		        return valid;
		    }
		    compile(schema, _meta) {
		        const sch = this._addSchema(schema, _meta);
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    compileAsync(schema, meta) {
		        if (typeof this.opts.loadSchema != "function") {
		            throw new Error("options.loadSchema should be a function");
		        }
		        const { loadSchema } = this.opts;
		        return runCompileAsync.call(this, schema, meta);
		        async function runCompileAsync(_schema, _meta) {
		            await loadMetaSchema.call(this, _schema.$schema);
		            const sch = this._addSchema(_schema, _meta);
		            return sch.validate || _compileAsync.call(this, sch);
		        }
		        async function loadMetaSchema($ref) {
		            if ($ref && !this.getSchema($ref)) {
		                await runCompileAsync.call(this, { $ref }, true);
		            }
		        }
		        async function _compileAsync(sch) {
		            try {
		                return this._compileSchemaEnv(sch);
		            }
		            catch (e) {
		                if (!(e instanceof ref_error_1.default))
		                    throw e;
		                checkLoaded.call(this, e);
		                await loadMissingSchema.call(this, e.missingSchema);
		                return _compileAsync.call(this, sch);
		            }
		        }
		        function checkLoaded({ missingSchema: ref, missingRef }) {
		            if (this.refs[ref]) {
		                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
		            }
		        }
		        async function loadMissingSchema(ref) {
		            const _schema = await _loadSchema.call(this, ref);
		            if (!this.refs[ref])
		                await loadMetaSchema.call(this, _schema.$schema);
		            if (!this.refs[ref])
		                this.addSchema(_schema, ref, meta);
		        }
		        async function _loadSchema(ref) {
		            const p = this._loading[ref];
		            if (p)
		                return p;
		            try {
		                return await (this._loading[ref] = loadSchema(ref));
		            }
		            finally {
		                delete this._loading[ref];
		            }
		        }
		    }
		    // Adds schema to the instance
		    addSchema(schema, // If array is passed, `key` will be ignored
		    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
		    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
		    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.
		    ) {
		        if (Array.isArray(schema)) {
		            for (const sch of schema)
		                this.addSchema(sch, undefined, _meta, _validateSchema);
		            return this;
		        }
		        let id;
		        if (typeof schema === "object") {
		            const { schemaId } = this.opts;
		            id = schema[schemaId];
		            if (id !== undefined && typeof id != "string") {
		                throw new Error(`schema ${schemaId} must be string`);
		            }
		        }
		        key = (0, resolve_1.normalizeId)(key || id);
		        this._checkUnique(key);
		        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
		        return this;
		    }
		    // Add schema that will be used to validate other schemas
		    // options in META_IGNORE_OPTIONS are alway set to false
		    addMetaSchema(schema, key, // schema key
		    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema
		    ) {
		        this.addSchema(schema, key, true, _validateSchema);
		        return this;
		    }
		    //  Validate schema against its meta-schema
		    validateSchema(schema, throwOrLogError) {
		        if (typeof schema == "boolean")
		            return true;
		        let $schema;
		        $schema = schema.$schema;
		        if ($schema !== undefined && typeof $schema != "string") {
		            throw new Error("$schema must be a string");
		        }
		        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
		        if (!$schema) {
		            this.logger.warn("meta-schema not available");
		            this.errors = null;
		            return true;
		        }
		        const valid = this.validate($schema, schema);
		        if (!valid && throwOrLogError) {
		            const message = "schema is invalid: " + this.errorsText();
		            if (this.opts.validateSchema === "log")
		                this.logger.error(message);
		            else
		                throw new Error(message);
		        }
		        return valid;
		    }
		    // Get compiled schema by `key` or `ref`.
		    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
		    getSchema(keyRef) {
		        let sch;
		        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
		            keyRef = sch;
		        if (sch === undefined) {
		            const { schemaId } = this.opts;
		            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
		            sch = compile_1.resolveSchema.call(this, root, keyRef);
		            if (!sch)
		                return;
		            this.refs[keyRef] = sch;
		        }
		        return (sch.validate || this._compileSchemaEnv(sch));
		    }
		    // Remove cached schema(s).
		    // If no parameter is passed all schemas but meta-schemas are removed.
		    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
		    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
		    removeSchema(schemaKeyRef) {
		        if (schemaKeyRef instanceof RegExp) {
		            this._removeAllSchemas(this.schemas, schemaKeyRef);
		            this._removeAllSchemas(this.refs, schemaKeyRef);
		            return this;
		        }
		        switch (typeof schemaKeyRef) {
		            case "undefined":
		                this._removeAllSchemas(this.schemas);
		                this._removeAllSchemas(this.refs);
		                this._cache.clear();
		                return this;
		            case "string": {
		                const sch = getSchEnv.call(this, schemaKeyRef);
		                if (typeof sch == "object")
		                    this._cache.delete(sch.schema);
		                delete this.schemas[schemaKeyRef];
		                delete this.refs[schemaKeyRef];
		                return this;
		            }
		            case "object": {
		                const cacheKey = schemaKeyRef;
		                this._cache.delete(cacheKey);
		                let id = schemaKeyRef[this.opts.schemaId];
		                if (id) {
		                    id = (0, resolve_1.normalizeId)(id);
		                    delete this.schemas[id];
		                    delete this.refs[id];
		                }
		                return this;
		            }
		            default:
		                throw new Error("ajv.removeSchema: invalid parameter");
		        }
		    }
		    // add "vocabulary" - a collection of keywords
		    addVocabulary(definitions) {
		        for (const def of definitions)
		            this.addKeyword(def);
		        return this;
		    }
		    addKeyword(kwdOrDef, def // deprecated
		    ) {
		        let keyword;
		        if (typeof kwdOrDef == "string") {
		            keyword = kwdOrDef;
		            if (typeof def == "object") {
		                this.logger.warn("these parameters are deprecated, see docs for addKeyword");
		                def.keyword = keyword;
		            }
		        }
		        else if (typeof kwdOrDef == "object" && def === undefined) {
		            def = kwdOrDef;
		            keyword = def.keyword;
		            if (Array.isArray(keyword) && !keyword.length) {
		                throw new Error("addKeywords: keyword must be string or non-empty array");
		            }
		        }
		        else {
		            throw new Error("invalid addKeywords parameters");
		        }
		        checkKeyword.call(this, keyword, def);
		        if (!def) {
		            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
		            return this;
		        }
		        keywordMetaschema.call(this, def);
		        const definition = {
		            ...def,
		            type: (0, dataType_1.getJSONTypes)(def.type),
		            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),
		        };
		        (0, util_1.eachItem)(keyword, definition.type.length === 0
		            ? (k) => addRule.call(this, k, definition)
		            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
		        return this;
		    }
		    getKeyword(keyword) {
		        const rule = this.RULES.all[keyword];
		        return typeof rule == "object" ? rule.definition : !!rule;
		    }
		    // Remove keyword
		    removeKeyword(keyword) {
		        // TODO return type should be Ajv
		        const { RULES } = this;
		        delete RULES.keywords[keyword];
		        delete RULES.all[keyword];
		        for (const group of RULES.rules) {
		            const i = group.rules.findIndex((rule) => rule.keyword === keyword);
		            if (i >= 0)
		                group.rules.splice(i, 1);
		        }
		        return this;
		    }
		    // Add format
		    addFormat(name, format) {
		        if (typeof format == "string")
		            format = new RegExp(format);
		        this.formats[name] = format;
		        return this;
		    }
		    errorsText(errors = this.errors, // optional array of validation errors
		    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`
		    ) {
		        if (!errors || errors.length === 0)
		            return "No errors";
		        return errors
		            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)
		            .reduce((text, msg) => text + separator + msg);
		    }
		    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
		        const rules = this.RULES.all;
		        metaSchema = JSON.parse(JSON.stringify(metaSchema));
		        for (const jsonPointer of keywordsJsonPointers) {
		            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string
		            let keywords = metaSchema;
		            for (const seg of segments)
		                keywords = keywords[seg];
		            for (const key in rules) {
		                const rule = rules[key];
		                if (typeof rule != "object")
		                    continue;
		                const { $data } = rule.definition;
		                const schema = keywords[key];
		                if ($data && schema)
		                    keywords[key] = schemaOrData(schema);
		            }
		        }
		        return metaSchema;
		    }
		    _removeAllSchemas(schemas, regex) {
		        for (const keyRef in schemas) {
		            const sch = schemas[keyRef];
		            if (!regex || regex.test(keyRef)) {
		                if (typeof sch == "string") {
		                    delete schemas[keyRef];
		                }
		                else if (sch && !sch.meta) {
		                    this._cache.delete(sch.schema);
		                    delete schemas[keyRef];
		                }
		            }
		        }
		    }
		    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
		        let id;
		        const { schemaId } = this.opts;
		        if (typeof schema == "object") {
		            id = schema[schemaId];
		        }
		        else {
		            if (this.opts.jtd)
		                throw new Error("schema must be object");
		            else if (typeof schema != "boolean")
		                throw new Error("schema must be object or boolean");
		        }
		        let sch = this._cache.get(schema);
		        if (sch !== undefined)
		            return sch;
		        baseId = (0, resolve_1.normalizeId)(id || baseId);
		        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
		        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
		        this._cache.set(sch.schema, sch);
		        if (addSchema && !baseId.startsWith("#")) {
		            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)
		            if (baseId)
		                this._checkUnique(baseId);
		            this.refs[baseId] = sch;
		        }
		        if (validateSchema)
		            this.validateSchema(schema, true);
		        return sch;
		    }
		    _checkUnique(id) {
		        if (this.schemas[id] || this.refs[id]) {
		            throw new Error(`schema with key or id "${id}" already exists`);
		        }
		    }
		    _compileSchemaEnv(sch) {
		        if (sch.meta)
		            this._compileMetaSchema(sch);
		        else
		            compile_1.compileSchema.call(this, sch);
		        /* istanbul ignore if */
		        if (!sch.validate)
		            throw new Error("ajv implementation error");
		        return sch.validate;
		    }
		    _compileMetaSchema(sch) {
		        const currentOpts = this.opts;
		        this.opts = this._metaOpts;
		        try {
		            compile_1.compileSchema.call(this, sch);
		        }
		        finally {
		            this.opts = currentOpts;
		        }
		    }
		}
		Ajv.ValidationError = validation_error_1.default;
		Ajv.MissingRefError = ref_error_1.default;
		exports.default = Ajv;
		function checkOptions(checkOpts, options, msg, log = "error") {
		    for (const key in checkOpts) {
		        const opt = key;
		        if (opt in options)
		            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
		    }
		}
		function getSchEnv(keyRef) {
		    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line
		    return this.schemas[keyRef] || this.refs[keyRef];
		}
		function addInitialSchemas() {
		    const optsSchemas = this.opts.schemas;
		    if (!optsSchemas)
		        return;
		    if (Array.isArray(optsSchemas))
		        this.addSchema(optsSchemas);
		    else
		        for (const key in optsSchemas)
		            this.addSchema(optsSchemas[key], key);
		}
		function addInitialFormats() {
		    for (const name in this.opts.formats) {
		        const format = this.opts.formats[name];
		        if (format)
		            this.addFormat(name, format);
		    }
		}
		function addInitialKeywords(defs) {
		    if (Array.isArray(defs)) {
		        this.addVocabulary(defs);
		        return;
		    }
		    this.logger.warn("keywords option as map is deprecated, pass array");
		    for (const keyword in defs) {
		        const def = defs[keyword];
		        if (!def.keyword)
		            def.keyword = keyword;
		        this.addKeyword(def);
		    }
		}
		function getMetaSchemaOptions() {
		    const metaOpts = { ...this.opts };
		    for (const opt of META_IGNORE_OPTIONS)
		        delete metaOpts[opt];
		    return metaOpts;
		}
		const noLogs = { log() { }, warn() { }, error() { } };
		function getLogger(logger) {
		    if (logger === false)
		        return noLogs;
		    if (logger === undefined)
		        return console;
		    if (logger.log && logger.warn && logger.error)
		        return logger;
		    throw new Error("logger must implement log, warn and error methods");
		}
		const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
		function checkKeyword(keyword, def) {
		    const { RULES } = this;
		    (0, util_1.eachItem)(keyword, (kwd) => {
		        if (RULES.keywords[kwd])
		            throw new Error(`Keyword ${kwd} is already defined`);
		        if (!KEYWORD_NAME.test(kwd))
		            throw new Error(`Keyword ${kwd} has invalid name`);
		    });
		    if (!def)
		        return;
		    if (def.$data && !("code" in def || "validate" in def)) {
		        throw new Error('$data keyword must have "code" or "validate" function');
		    }
		}
		function addRule(keyword, definition, dataType) {
		    var _a;
		    const post = definition === null || definition === void 0 ? void 0 : definition.post;
		    if (dataType && post)
		        throw new Error('keyword with "post" flag cannot have "type"');
		    const { RULES } = this;
		    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
		    if (!ruleGroup) {
		        ruleGroup = { type: dataType, rules: [] };
		        RULES.rules.push(ruleGroup);
		    }
		    RULES.keywords[keyword] = true;
		    if (!definition)
		        return;
		    const rule = {
		        keyword,
		        definition: {
		            ...definition,
		            type: (0, dataType_1.getJSONTypes)(definition.type),
		            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),
		        },
		    };
		    if (definition.before)
		        addBeforeRule.call(this, ruleGroup, rule, definition.before);
		    else
		        ruleGroup.rules.push(rule);
		    RULES.all[keyword] = rule;
		    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
		}
		function addBeforeRule(ruleGroup, rule, before) {
		    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
		    if (i >= 0) {
		        ruleGroup.rules.splice(i, 0, rule);
		    }
		    else {
		        ruleGroup.rules.push(rule);
		        this.logger.warn(`rule ${before} is not defined`);
		    }
		}
		function keywordMetaschema(def) {
		    let { metaSchema } = def;
		    if (metaSchema === undefined)
		        return;
		    if (def.$data && this.opts.$data)
		        metaSchema = schemaOrData(metaSchema);
		    def.validateSchema = this.compile(metaSchema, true);
		}
		const $dataRef = {
		    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
		};
		function schemaOrData(schema) {
		    return { anyOf: [schema, $dataRef] };
		}
		
	} (core$1));
	return core$1;
}

var draft7 = {};

var core = {};

var id = {};

var hasRequiredId;

function requireId () {
	if (hasRequiredId) return id;
	hasRequiredId = 1;
	Object.defineProperty(id, "__esModule", { value: true });
	const def = {
	    keyword: "id",
	    code() {
	        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
	    },
	};
	id.default = def;
	
	return id;
}

var ref = {};

var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;
	Object.defineProperty(ref, "__esModule", { value: true });
	ref.callRef = ref.getValidate = void 0;
	const ref_error_1 = requireRef_error();
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const compile_1 = requireCompile();
	const util_1 = requireUtil();
	const def = {
	    keyword: "$ref",
	    schemaType: "string",
	    code(cxt) {
	        const { gen, schema: $ref, it } = cxt;
	        const { baseId, schemaEnv: env, validateName, opts, self } = it;
	        const { root } = env;
	        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
	            return callRootRef();
	        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
	        if (schOrEnv === undefined)
	            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
	        if (schOrEnv instanceof compile_1.SchemaEnv)
	            return callValidate(schOrEnv);
	        return inlineRefSchema(schOrEnv);
	        function callRootRef() {
	            if (env === root)
	                return callRef(cxt, validateName, env, env.$async);
	            const rootName = gen.scopeValue("root", { ref: root });
	            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);
	        }
	        function callValidate(sch) {
	            const v = getValidate(cxt, sch);
	            callRef(cxt, v, sch, sch.$async);
	        }
	        function inlineRefSchema(sch) {
	            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
	            const valid = gen.name("valid");
	            const schCxt = cxt.subschema({
	                schema: sch,
	                dataTypes: [],
	                schemaPath: codegen_1.nil,
	                topSchemaRef: schName,
	                errSchemaPath: $ref,
	            }, valid);
	            cxt.mergeEvaluated(schCxt);
	            cxt.ok(valid);
	        }
	    },
	};
	function getValidate(cxt, sch) {
	    const { gen } = cxt;
	    return sch.validate
	        ? gen.scopeValue("validate", { ref: sch.validate })
	        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;
	}
	ref.getValidate = getValidate;
	function callRef(cxt, v, sch, $async) {
	    const { gen, it } = cxt;
	    const { allErrors, schemaEnv: env, opts } = it;
	    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
	    if ($async)
	        callAsyncRef();
	    else
	        callSyncRef();
	    function callAsyncRef() {
	        if (!env.$async)
	            throw new Error("async schema referenced by sync schema");
	        const valid = gen.let("valid");
	        gen.try(() => {
	            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
	            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result
	            if (!allErrors)
	                gen.assign(valid, true);
	        }, (e) => {
	            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
	            addErrorsFrom(e);
	            if (!allErrors)
	                gen.assign(valid, false);
	        });
	        cxt.ok(valid);
	    }
	    function callSyncRef() {
	        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
	    }
	    function addErrorsFrom(source) {
	        const errs = (0, codegen_1._) `${source}.errors`;
	        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged
	        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);
	    }
	    function addEvaluatedFrom(source) {
	        var _a;
	        if (!it.opts.unevaluated)
	            return;
	        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
	        // TODO refactor
	        if (it.props !== true) {
	            if (schEvaluated && !schEvaluated.dynamicProps) {
	                if (schEvaluated.props !== undefined) {
	                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
	                }
	            }
	            else {
	                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);
	                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
	            }
	        }
	        if (it.items !== true) {
	            if (schEvaluated && !schEvaluated.dynamicItems) {
	                if (schEvaluated.items !== undefined) {
	                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
	                }
	            }
	            else {
	                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);
	                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
	            }
	        }
	    }
	}
	ref.callRef = callRef;
	ref.default = def;
	
	return ref;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	Object.defineProperty(core, "__esModule", { value: true });
	const id_1 = requireId();
	const ref_1 = requireRef();
	const core$1 = [
	    "$schema",
	    "$id",
	    "$defs",
	    "$vocabulary",
	    { keyword: "$comment" },
	    "definitions",
	    id_1.default,
	    ref_1.default,
	];
	core.default = core$1;
	
	return core;
}

var validation = {};

var limitNumber = {};

var hasRequiredLimitNumber;

function requireLimitNumber () {
	if (hasRequiredLimitNumber) return limitNumber;
	hasRequiredLimitNumber = 1;
	Object.defineProperty(limitNumber, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const ops = codegen_1.operators;
	const KWDs = {
	    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
	    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
	    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
	    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
	};
	const error = {
	    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,
	    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: Object.keys(KWDs),
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
	    },
	};
	limitNumber.default = def;
	
	return limitNumber;
}

var multipleOf = {};

var hasRequiredMultipleOf;

function requireMultipleOf () {
	if (hasRequiredMultipleOf) return multipleOf;
	hasRequiredMultipleOf = 1;
	Object.defineProperty(multipleOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,
	};
	const def = {
	    keyword: "multipleOf",
	    type: "number",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, schemaCode, it } = cxt;
	        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)
	        const prec = it.opts.multipleOfPrecision;
	        const res = gen.let("res");
	        const invalid = prec
	            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`
	            : (0, codegen_1._) `${res} !== parseInt(${res})`;
	        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
	    },
	};
	multipleOf.default = def;
	
	return multipleOf;
}

var limitLength = {};

var ucs2length = {};

var hasRequiredUcs2length;

function requireUcs2length () {
	if (hasRequiredUcs2length) return ucs2length;
	hasRequiredUcs2length = 1;
	Object.defineProperty(ucs2length, "__esModule", { value: true });
	// https://mathiasbynens.be/notes/javascript-encoding
	// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
	function ucs2length$1(str) {
	    const len = str.length;
	    let length = 0;
	    let pos = 0;
	    let value;
	    while (pos < len) {
	        length++;
	        value = str.charCodeAt(pos++);
	        if (value >= 0xd800 && value <= 0xdbff && pos < len) {
	            // high surrogate, and there is a next character
	            value = str.charCodeAt(pos);
	            if ((value & 0xfc00) === 0xdc00)
	                pos++; // low surrogate
	        }
	    }
	    return length;
	}
	ucs2length.default = ucs2length$1;
	ucs2length$1.code = 'require("ajv/dist/runtime/ucs2length").default';
	
	return ucs2length;
}

var hasRequiredLimitLength;

function requireLimitLength () {
	if (hasRequiredLimitLength) return limitLength;
	hasRequiredLimitLength = 1;
	Object.defineProperty(limitLength, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const ucs2length_1 = requireUcs2length();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxLength" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxLength", "minLength"],
	    type: "string",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode, it } = cxt;
	        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
	        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);
	    },
	};
	limitLength.default = def;
	
	return limitLength;
}

var pattern = {};

var hasRequiredPattern;

function requirePattern () {
	if (hasRequiredPattern) return pattern;
	hasRequiredPattern = 1;
	Object.defineProperty(pattern, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,
	};
	const def = {
	    keyword: "pattern",
	    type: "string",
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt) {
	        const { data, $data, schema, schemaCode, it } = cxt;
	        // TODO regexp should be wrapped in try/catchs
	        const u = it.opts.unicodeRegExp ? "u" : "";
	        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
	        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);
	    },
	};
	pattern.default = def;
	
	return pattern;
}

var limitProperties = {};

var hasRequiredLimitProperties;

function requireLimitProperties () {
	if (hasRequiredLimitProperties) return limitProperties;
	hasRequiredLimitProperties = 1;
	Object.defineProperty(limitProperties, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxProperties" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxProperties", "minProperties"],
	    type: "object",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);
	    },
	};
	limitProperties.default = def;
	
	return limitProperties;
}

var required = {};

var hasRequiredRequired;

function requireRequired () {
	if (hasRequiredRequired) return required;
	hasRequiredRequired = 1;
	Object.defineProperty(required, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,
	    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,
	};
	const def = {
	    keyword: "required",
	    type: "object",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, schema, schemaCode, data, $data, it } = cxt;
	        const { opts } = it;
	        if (!$data && schema.length === 0)
	            return;
	        const useLoop = schema.length >= opts.loopRequired;
	        if (it.allErrors)
	            allErrorsMode();
	        else
	            exitOnErrorMode();
	        if (opts.strictRequired) {
	            const props = cxt.parentSchema.properties;
	            const { definedProperties } = cxt.it;
	            for (const requiredKey of schema) {
	                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
	                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
	                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
	                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
	                }
	            }
	        }
	        function allErrorsMode() {
	            if (useLoop || $data) {
	                cxt.block$data(codegen_1.nil, loopAllRequired);
	            }
	            else {
	                for (const prop of schema) {
	                    (0, code_1.checkReportMissingProp)(cxt, prop);
	                }
	            }
	        }
	        function exitOnErrorMode() {
	            const missing = gen.let("missing");
	            if (useLoop || $data) {
	                const valid = gen.let("valid", true);
	                cxt.block$data(valid, () => loopUntilMissing(missing, valid));
	                cxt.ok(valid);
	            }
	            else {
	                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
	                (0, code_1.reportMissingProp)(cxt, missing);
	                gen.else();
	            }
	        }
	        function loopAllRequired() {
	            gen.forOf("prop", schemaCode, (prop) => {
	                cxt.setParams({ missingProperty: prop });
	                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
	            });
	        }
	        function loopUntilMissing(missing, valid) {
	            cxt.setParams({ missingProperty: missing });
	            gen.forOf(missing, schemaCode, () => {
	                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
	                gen.if((0, codegen_1.not)(valid), () => {
	                    cxt.error();
	                    gen.break();
	                });
	            }, codegen_1.nil);
	        }
	    },
	};
	required.default = def;
	
	return required;
}

var limitItems = {};

var hasRequiredLimitItems;

function requireLimitItems () {
	if (hasRequiredLimitItems) return limitItems;
	hasRequiredLimitItems = 1;
	Object.defineProperty(limitItems, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message({ keyword, schemaCode }) {
	        const comp = keyword === "maxItems" ? "more" : "fewer";
	        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;
	    },
	    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,
	};
	const def = {
	    keyword: ["maxItems", "minItems"],
	    type: "array",
	    schemaType: "number",
	    $data: true,
	    error,
	    code(cxt) {
	        const { keyword, data, schemaCode } = cxt;
	        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
	        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);
	    },
	};
	limitItems.default = def;
	
	return limitItems;
}

var uniqueItems = {};

var equal = {};

var hasRequiredEqual;

function requireEqual () {
	if (hasRequiredEqual) return equal;
	hasRequiredEqual = 1;
	Object.defineProperty(equal, "__esModule", { value: true });
	// https://github.com/ajv-validator/ajv/issues/889
	const equal$1 = requireFastDeepEqual();
	equal$1.code = 'require("ajv/dist/runtime/equal").default';
	equal.default = equal$1;
	
	return equal;
}

var hasRequiredUniqueItems;

function requireUniqueItems () {
	if (hasRequiredUniqueItems) return uniqueItems;
	hasRequiredUniqueItems = 1;
	Object.defineProperty(uniqueItems, "__esModule", { value: true });
	const dataType_1 = requireDataType();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
	    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,
	};
	const def = {
	    keyword: "uniqueItems",
	    type: "array",
	    schemaType: "boolean",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
	        if (!$data && !schema)
	            return;
	        const valid = gen.let("valid");
	        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
	        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);
	        cxt.ok(valid);
	        function validateUniqueItems() {
	            const i = gen.let("i", (0, codegen_1._) `${data}.length`);
	            const j = gen.let("j");
	            cxt.setParams({ i, j });
	            gen.assign(valid, true);
	            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
	        }
	        function canOptimize() {
	            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
	        }
	        function loopN(i, j) {
	            const item = gen.name("item");
	            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
	            const indices = gen.const("indices", (0, codegen_1._) `{}`);
	            gen.for((0, codegen_1._) `;${i}--;`, () => {
	                gen.let(item, (0, codegen_1._) `${data}[${i}]`);
	                gen.if(wrongType, (0, codegen_1._) `continue`);
	                if (itemTypes.length > 1)
	                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);
	                gen
	                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {
	                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);
	                    cxt.error();
	                    gen.assign(valid, false).break();
	                })
	                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);
	            });
	        }
	        function loopN2(i, j) {
	            const eql = (0, util_1.useFunc)(gen, equal_1.default);
	            const outer = gen.name("outer");
	            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {
	                cxt.error();
	                gen.assign(valid, false).break(outer);
	            })));
	        }
	    },
	};
	uniqueItems.default = def;
	
	return uniqueItems;
}

var _const = {};

var hasRequired_const;

function require_const () {
	if (hasRequired_const) return _const;
	hasRequired_const = 1;
	Object.defineProperty(_const, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to constant",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,
	};
	const def = {
	    keyword: "const",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schemaCode, schema } = cxt;
	        if ($data || (schema && typeof schema == "object")) {
	            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
	        }
	        else {
	            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);
	        }
	    },
	};
	_const.default = def;
	
	return _const;
}

var _enum = {};

var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	Object.defineProperty(_enum, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const equal_1 = requireEqual();
	const error = {
	    message: "must be equal to one of the allowed values",
	    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,
	};
	const def = {
	    keyword: "enum",
	    schemaType: "array",
	    $data: true,
	    error,
	    code(cxt) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        if (!$data && schema.length === 0)
	            throw new Error("enum must have non-empty array");
	        const useLoop = schema.length >= it.opts.loopEnum;
	        let eql;
	        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));
	        let valid;
	        if (useLoop || $data) {
	            valid = gen.let("valid");
	            cxt.block$data(valid, loopEnum);
	        }
	        else {
	            /* istanbul ignore if */
	            if (!Array.isArray(schema))
	                throw new Error("ajv implementation error");
	            const vSchema = gen.const("vSchema", schemaCode);
	            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
	        }
	        cxt.pass(valid);
	        function loopEnum() {
	            gen.assign(valid, false);
	            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
	        }
	        function equalCode(vSchema, i) {
	            const sch = schema[i];
	            return typeof sch === "object" && sch !== null
	                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`
	                : (0, codegen_1._) `${data} === ${sch}`;
	        }
	    },
	};
	_enum.default = def;
	
	return _enum;
}

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation;
	hasRequiredValidation = 1;
	Object.defineProperty(validation, "__esModule", { value: true });
	const limitNumber_1 = requireLimitNumber();
	const multipleOf_1 = requireMultipleOf();
	const limitLength_1 = requireLimitLength();
	const pattern_1 = requirePattern();
	const limitProperties_1 = requireLimitProperties();
	const required_1 = requireRequired();
	const limitItems_1 = requireLimitItems();
	const uniqueItems_1 = requireUniqueItems();
	const const_1 = require_const();
	const enum_1 = require_enum();
	const validation$1 = [
	    // number
	    limitNumber_1.default,
	    multipleOf_1.default,
	    // string
	    limitLength_1.default,
	    pattern_1.default,
	    // object
	    limitProperties_1.default,
	    required_1.default,
	    // array
	    limitItems_1.default,
	    uniqueItems_1.default,
	    // any
	    { keyword: "type", schemaType: ["string", "array"] },
	    { keyword: "nullable", schemaType: "boolean" },
	    const_1.default,
	    enum_1.default,
	];
	validation.default = validation$1;
	
	return validation;
}

var applicator = {};

var additionalItems = {};

var hasRequiredAdditionalItems;

function requireAdditionalItems () {
	if (hasRequiredAdditionalItems) return additionalItems;
	hasRequiredAdditionalItems = 1;
	Object.defineProperty(additionalItems, "__esModule", { value: true });
	additionalItems.validateAdditionalItems = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "additionalItems",
	    type: "array",
	    schemaType: ["boolean", "object"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { parentSchema, it } = cxt;
	        const { items } = parentSchema;
	        if (!Array.isArray(items)) {
	            (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
	            return;
	        }
	        validateAdditionalItems(cxt, items);
	    },
	};
	function validateAdditionalItems(cxt, items) {
	    const { gen, schema, data, keyword, it } = cxt;
	    it.items = true;
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    if (schema === false) {
	        cxt.setParams({ len: items.length });
	        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);
	    }
	    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var
	        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
	        cxt.ok(valid);
	    }
	    function validateItems(valid) {
	        gen.forRange("i", items.length, len, (i) => {
	            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
	            if (!it.allErrors)
	                gen.if((0, codegen_1.not)(valid), () => gen.break());
	        });
	    }
	}
	additionalItems.validateAdditionalItems = validateAdditionalItems;
	additionalItems.default = def;
	
	return additionalItems;
}

var prefixItems = {};

var items = {};

var hasRequiredItems;

function requireItems () {
	if (hasRequiredItems) return items;
	hasRequiredItems = 1;
	Object.defineProperty(items, "__esModule", { value: true });
	items.validateTuple = void 0;
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const code_1 = requireCode();
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "array", "boolean"],
	    before: "uniqueItems",
	    code(cxt) {
	        const { schema, it } = cxt;
	        if (Array.isArray(schema))
	            return validateTuple(cxt, "additionalItems", schema);
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	function validateTuple(cxt, extraItems, schArr = cxt.schema) {
	    const { gen, parentSchema, data, keyword, it } = cxt;
	    checkStrictTuple(parentSchema);
	    if (it.opts.unevaluated && schArr.length && it.items !== true) {
	        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
	    }
	    const valid = gen.name("valid");
	    const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	    schArr.forEach((sch, i) => {
	        if ((0, util_1.alwaysValidSchema)(it, sch))
	            return;
	        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({
	            keyword,
	            schemaProp: i,
	            dataProp: i,
	        }, valid));
	        cxt.ok(valid);
	    });
	    function checkStrictTuple(sch) {
	        const { opts, errSchemaPath } = it;
	        const l = schArr.length;
	        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
	        if (opts.strictTuples && !fullTuple) {
	            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
	            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
	        }
	    }
	}
	items.validateTuple = validateTuple;
	items.default = def;
	
	return items;
}

var hasRequiredPrefixItems;

function requirePrefixItems () {
	if (hasRequiredPrefixItems) return prefixItems;
	hasRequiredPrefixItems = 1;
	Object.defineProperty(prefixItems, "__esModule", { value: true });
	const items_1 = requireItems();
	const def = {
	    keyword: "prefixItems",
	    type: "array",
	    schemaType: ["array"],
	    before: "uniqueItems",
	    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),
	};
	prefixItems.default = def;
	
	return prefixItems;
}

var items2020 = {};

var hasRequiredItems2020;

function requireItems2020 () {
	if (hasRequiredItems2020) return items2020;
	hasRequiredItems2020 = 1;
	Object.defineProperty(items2020, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const code_1 = requireCode();
	const additionalItems_1 = requireAdditionalItems();
	const error = {
	    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,
	    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,
	};
	const def = {
	    keyword: "items",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    error,
	    code(cxt) {
	        const { schema, parentSchema, it } = cxt;
	        const { prefixItems } = parentSchema;
	        it.items = true;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        if (prefixItems)
	            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
	        else
	            cxt.ok((0, code_1.validateArray)(cxt));
	    },
	};
	items2020.default = def;
	
	return items2020;
}

var contains = {};

var hasRequiredContains;

function requireContains () {
	if (hasRequiredContains) return contains;
	hasRequiredContains = 1;
	Object.defineProperty(contains, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { min, max } }) => max === undefined
	        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`
	        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,
	    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,
	};
	const def = {
	    keyword: "contains",
	    type: "array",
	    schemaType: ["object", "boolean"],
	    before: "uniqueItems",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        let min;
	        let max;
	        const { minContains, maxContains } = parentSchema;
	        if (it.opts.next) {
	            min = minContains === undefined ? 1 : minContains;
	            max = maxContains;
	        }
	        else {
	            min = 1;
	        }
	        const len = gen.const("len", (0, codegen_1._) `${data}.length`);
	        cxt.setParams({ min, max });
	        if (max === undefined && min === 0) {
	            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
	            return;
	        }
	        if (max !== undefined && min > max) {
	            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
	            cxt.fail();
	            return;
	        }
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            let cond = (0, codegen_1._) `${len} >= ${min}`;
	            if (max !== undefined)
	                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;
	            cxt.pass(cond);
	            return;
	        }
	        it.items = true;
	        const valid = gen.name("valid");
	        if (max === undefined && min === 1) {
	            validateItems(valid, () => gen.if(valid, () => gen.break()));
	        }
	        else if (min === 0) {
	            gen.let(valid, true);
	            if (max !== undefined)
	                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);
	        }
	        else {
	            gen.let(valid, false);
	            validateItemsWithCount();
	        }
	        cxt.result(valid, () => cxt.reset());
	        function validateItemsWithCount() {
	            const schValid = gen.name("_valid");
	            const count = gen.let("count", 0);
	            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
	        }
	        function validateItems(_valid, block) {
	            gen.forRange("i", 0, len, (i) => {
	                cxt.subschema({
	                    keyword: "contains",
	                    dataProp: i,
	                    dataPropType: util_1.Type.Num,
	                    compositeRule: true,
	                }, _valid);
	                block();
	            });
	        }
	        function checkLimits(count) {
	            gen.code((0, codegen_1._) `${count}++`);
	            if (max === undefined) {
	                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());
	            }
	            else {
	                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());
	                if (min === 1)
	                    gen.assign(valid, true);
	                else
	                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));
	            }
	        }
	    },
	};
	contains.default = def;
	
	return contains;
}

var dependencies = {};

var hasRequiredDependencies;

function requireDependencies () {
	if (hasRequiredDependencies) return dependencies;
	hasRequiredDependencies = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
		const codegen_1 = requireCodegen();
		const util_1 = requireUtil();
		const code_1 = requireCode();
		exports.error = {
		    message: ({ params: { property, depsCount, deps } }) => {
		        const property_ies = depsCount === 1 ? "property" : "properties";
		        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;
		    },
		    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, // TODO change to reference
		};
		const def = {
		    keyword: "dependencies",
		    type: "object",
		    schemaType: "object",
		    error: exports.error,
		    code(cxt) {
		        const [propDeps, schDeps] = splitDependencies(cxt);
		        validatePropertyDeps(cxt, propDeps);
		        validateSchemaDeps(cxt, schDeps);
		    },
		};
		function splitDependencies({ schema }) {
		    const propertyDeps = {};
		    const schemaDeps = {};
		    for (const key in schema) {
		        if (key === "__proto__")
		            continue;
		        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
		        deps[key] = schema[key];
		    }
		    return [propertyDeps, schemaDeps];
		}
		function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
		    const { gen, data, it } = cxt;
		    if (Object.keys(propertyDeps).length === 0)
		        return;
		    const missing = gen.let("missing");
		    for (const prop in propertyDeps) {
		        const deps = propertyDeps[prop];
		        if (deps.length === 0)
		            continue;
		        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
		        cxt.setParams({
		            property: prop,
		            depsCount: deps.length,
		            deps: deps.join(", "),
		        });
		        if (it.allErrors) {
		            gen.if(hasProperty, () => {
		                for (const depProp of deps) {
		                    (0, code_1.checkReportMissingProp)(cxt, depProp);
		                }
		            });
		        }
		        else {
		            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
		            (0, code_1.reportMissingProp)(cxt, missing);
		            gen.else();
		        }
		    }
		}
		exports.validatePropertyDeps = validatePropertyDeps;
		function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
		    const { gen, data, keyword, it } = cxt;
		    const valid = gen.name("valid");
		    for (const prop in schemaDeps) {
		        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
		            continue;
		        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {
		            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
		            cxt.mergeValidEvaluated(schCxt, valid);
		        }, () => gen.var(valid, true) // TODO var
		        );
		        cxt.ok(valid);
		    }
		}
		exports.validateSchemaDeps = validateSchemaDeps;
		exports.default = def;
		
	} (dependencies));
	return dependencies;
}

var propertyNames = {};

var hasRequiredPropertyNames;

function requirePropertyNames () {
	if (hasRequiredPropertyNames) return propertyNames;
	hasRequiredPropertyNames = 1;
	Object.defineProperty(propertyNames, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: "property name must be valid",
	    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,
	};
	const def = {
	    keyword: "propertyNames",
	    type: "object",
	    schemaType: ["object", "boolean"],
	    error,
	    code(cxt) {
	        const { gen, schema, data, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const valid = gen.name("valid");
	        gen.forIn("key", data, (key) => {
	            cxt.setParams({ propertyName: key });
	            cxt.subschema({
	                keyword: "propertyNames",
	                data: key,
	                dataTypes: ["string"],
	                propertyName: key,
	                compositeRule: true,
	            }, valid);
	            gen.if((0, codegen_1.not)(valid), () => {
	                cxt.error(true);
	                if (!it.allErrors)
	                    gen.break();
	            });
	        });
	        cxt.ok(valid);
	    },
	};
	propertyNames.default = def;
	
	return propertyNames;
}

var additionalProperties = {};

var hasRequiredAdditionalProperties;

function requireAdditionalProperties () {
	if (hasRequiredAdditionalProperties) return additionalProperties;
	hasRequiredAdditionalProperties = 1;
	Object.defineProperty(additionalProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const names_1 = requireNames();
	const util_1 = requireUtil();
	const error = {
	    message: "must NOT have additional properties",
	    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,
	};
	const def = {
	    keyword: "additionalProperties",
	    type: ["object"],
	    schemaType: ["boolean", "object"],
	    allowUndefined: true,
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
	        /* istanbul ignore if */
	        if (!errsCount)
	            throw new Error("ajv implementation error");
	        const { allErrors, opts } = it;
	        it.props = true;
	        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
	            return;
	        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
	        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
	        checkAdditionalProperties();
	        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);
	        function checkAdditionalProperties() {
	            gen.forIn("key", data, (key) => {
	                if (!props.length && !patProps.length)
	                    additionalPropertyCode(key);
	                else
	                    gen.if(isAdditional(key), () => additionalPropertyCode(key));
	            });
	        }
	        function isAdditional(key) {
	            let definedProp;
	            if (props.length > 8) {
	                // TODO maybe an option instead of hard-coded 8?
	                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
	                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
	            }
	            else if (props.length) {
	                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));
	            }
	            else {
	                definedProp = codegen_1.nil;
	            }
	            if (patProps.length) {
	                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
	            }
	            return (0, codegen_1.not)(definedProp);
	        }
	        function deleteAdditional(key) {
	            gen.code((0, codegen_1._) `delete ${data}[${key}]`);
	        }
	        function additionalPropertyCode(key) {
	            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {
	                deleteAdditional(key);
	                return;
	            }
	            if (schema === false) {
	                cxt.setParams({ additionalProperty: key });
	                cxt.error();
	                if (!allErrors)
	                    gen.break();
	                return;
	            }
	            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
	                const valid = gen.name("valid");
	                if (opts.removeAdditional === "failing") {
	                    applyAdditionalSchema(key, valid, false);
	                    gen.if((0, codegen_1.not)(valid), () => {
	                        cxt.reset();
	                        deleteAdditional(key);
	                    });
	                }
	                else {
	                    applyAdditionalSchema(key, valid);
	                    if (!allErrors)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                }
	            }
	        }
	        function applyAdditionalSchema(key, valid, errors) {
	            const subschema = {
	                keyword: "additionalProperties",
	                dataProp: key,
	                dataPropType: util_1.Type.Str,
	            };
	            if (errors === false) {
	                Object.assign(subschema, {
	                    compositeRule: true,
	                    createErrors: false,
	                    allErrors: false,
	                });
	            }
	            cxt.subschema(subschema, valid);
	        }
	    },
	};
	additionalProperties.default = def;
	
	return additionalProperties;
}

var properties$1 = {};

var hasRequiredProperties;

function requireProperties () {
	if (hasRequiredProperties) return properties$1;
	hasRequiredProperties = 1;
	Object.defineProperty(properties$1, "__esModule", { value: true });
	const validate_1 = requireValidate();
	const code_1 = requireCode();
	const util_1 = requireUtil();
	const additionalProperties_1 = requireAdditionalProperties();
	const def = {
	    keyword: "properties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, parentSchema, data, it } = cxt;
	        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
	            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
	        }
	        const allProps = (0, code_1.allSchemaProperties)(schema);
	        for (const prop of allProps) {
	            it.definedProperties.add(prop);
	        }
	        if (it.opts.unevaluated && allProps.length && it.props !== true) {
	            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
	        }
	        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (properties.length === 0)
	            return;
	        const valid = gen.name("valid");
	        for (const prop of properties) {
	            if (hasDefault(prop)) {
	                applyPropertySchema(prop);
	            }
	            else {
	                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
	                applyPropertySchema(prop);
	                if (!it.allErrors)
	                    gen.else().var(valid, true);
	                gen.endIf();
	            }
	            cxt.it.definedProperties.add(prop);
	            cxt.ok(valid);
	        }
	        function hasDefault(prop) {
	            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;
	        }
	        function applyPropertySchema(prop) {
	            cxt.subschema({
	                keyword: "properties",
	                schemaProp: prop,
	                dataProp: prop,
	            }, valid);
	        }
	    },
	};
	properties$1.default = def;
	
	return properties$1;
}

var patternProperties = {};

var hasRequiredPatternProperties;

function requirePatternProperties () {
	if (hasRequiredPatternProperties) return patternProperties;
	hasRequiredPatternProperties = 1;
	Object.defineProperty(patternProperties, "__esModule", { value: true });
	const code_1 = requireCode();
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const util_2 = requireUtil();
	const def = {
	    keyword: "patternProperties",
	    type: "object",
	    schemaType: "object",
	    code(cxt) {
	        const { gen, schema, data, parentSchema, it } = cxt;
	        const { opts } = it;
	        const patterns = (0, code_1.allSchemaProperties)(schema);
	        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
	        if (patterns.length === 0 ||
	            (alwaysValidPatterns.length === patterns.length &&
	                (!it.opts.unevaluated || it.props === true))) {
	            return;
	        }
	        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
	        const valid = gen.name("valid");
	        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
	            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
	        }
	        const { props } = it;
	        validatePatternProperties();
	        function validatePatternProperties() {
	            for (const pat of patterns) {
	                if (checkProperties)
	                    checkMatchingProperties(pat);
	                if (it.allErrors) {
	                    validateProperties(pat);
	                }
	                else {
	                    gen.var(valid, true); // TODO var
	                    validateProperties(pat);
	                    gen.if(valid);
	                }
	            }
	        }
	        function checkMatchingProperties(pat) {
	            for (const prop in checkProperties) {
	                if (new RegExp(pat).test(prop)) {
	                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
	                }
	            }
	        }
	        function validateProperties(pat) {
	            gen.forIn("key", data, (key) => {
	                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
	                    const alwaysValid = alwaysValidPatterns.includes(pat);
	                    if (!alwaysValid) {
	                        cxt.subschema({
	                            keyword: "patternProperties",
	                            schemaProp: pat,
	                            dataProp: key,
	                            dataPropType: util_2.Type.Str,
	                        }, valid);
	                    }
	                    if (it.opts.unevaluated && props !== true) {
	                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);
	                    }
	                    else if (!alwaysValid && !it.allErrors) {
	                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
	                        // or if all properties were evaluated (props === true)
	                        gen.if((0, codegen_1.not)(valid), () => gen.break());
	                    }
	                });
	            });
	        }
	    },
	};
	patternProperties.default = def;
	
	return patternProperties;
}

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: "not",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        if ((0, util_1.alwaysValidSchema)(it, schema)) {
	            cxt.fail();
	            return;
	        }
	        const valid = gen.name("valid");
	        cxt.subschema({
	            keyword: "not",
	            compositeRule: true,
	            createErrors: false,
	            allErrors: false,
	        }, valid);
	        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
	    },
	    error: { message: "must NOT be valid" },
	};
	not.default = def;
	
	return not;
}

var anyOf = {};

var hasRequiredAnyOf;

function requireAnyOf () {
	if (hasRequiredAnyOf) return anyOf;
	hasRequiredAnyOf = 1;
	Object.defineProperty(anyOf, "__esModule", { value: true });
	const code_1 = requireCode();
	const def = {
	    keyword: "anyOf",
	    schemaType: "array",
	    trackErrors: true,
	    code: code_1.validateUnion,
	    error: { message: "must match a schema in anyOf" },
	};
	anyOf.default = def;
	
	return anyOf;
}

var oneOf = {};

var hasRequiredOneOf;

function requireOneOf () {
	if (hasRequiredOneOf) return oneOf;
	hasRequiredOneOf = 1;
	Object.defineProperty(oneOf, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: "must match exactly one schema in oneOf",
	    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,
	};
	const def = {
	    keyword: "oneOf",
	    schemaType: "array",
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, schema, parentSchema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        if (it.opts.discriminator && parentSchema.discriminator)
	            return;
	        const schArr = schema;
	        const valid = gen.let("valid", false);
	        const passing = gen.let("passing", null);
	        const schValid = gen.name("_valid");
	        cxt.setParams({ passing });
	        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas
	        gen.block(validateOneOf);
	        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
	        function validateOneOf() {
	            schArr.forEach((sch, i) => {
	                let schCxt;
	                if ((0, util_1.alwaysValidSchema)(it, sch)) {
	                    gen.var(schValid, true);
	                }
	                else {
	                    schCxt = cxt.subschema({
	                        keyword: "oneOf",
	                        schemaProp: i,
	                        compositeRule: true,
	                    }, schValid);
	                }
	                if (i > 0) {
	                    gen
	                        .if((0, codegen_1._) `${schValid} && ${valid}`)
	                        .assign(valid, false)
	                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)
	                        .else();
	                }
	                gen.if(schValid, () => {
	                    gen.assign(valid, true);
	                    gen.assign(passing, i);
	                    if (schCxt)
	                        cxt.mergeEvaluated(schCxt, codegen_1.Name);
	                });
	            });
	        }
	    },
	};
	oneOf.default = def;
	
	return oneOf;
}

var allOf = {};

var hasRequiredAllOf;

function requireAllOf () {
	if (hasRequiredAllOf) return allOf;
	hasRequiredAllOf = 1;
	Object.defineProperty(allOf, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: "allOf",
	    schemaType: "array",
	    code(cxt) {
	        const { gen, schema, it } = cxt;
	        /* istanbul ignore if */
	        if (!Array.isArray(schema))
	            throw new Error("ajv implementation error");
	        const valid = gen.name("valid");
	        schema.forEach((sch, i) => {
	            if ((0, util_1.alwaysValidSchema)(it, sch))
	                return;
	            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
	            cxt.ok(valid);
	            cxt.mergeEvaluated(schCxt);
	        });
	    },
	};
	allOf.default = def;
	
	return allOf;
}

var _if = {};

var hasRequired_if;

function require_if () {
	if (hasRequired_if) return _if;
	hasRequired_if = 1;
	Object.defineProperty(_if, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,
	    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,
	};
	const def = {
	    keyword: "if",
	    schemaType: ["object", "boolean"],
	    trackErrors: true,
	    error,
	    code(cxt) {
	        const { gen, parentSchema, it } = cxt;
	        if (parentSchema.then === undefined && parentSchema.else === undefined) {
	            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
	        }
	        const hasThen = hasSchema(it, "then");
	        const hasElse = hasSchema(it, "else");
	        if (!hasThen && !hasElse)
	            return;
	        const valid = gen.let("valid", true);
	        const schValid = gen.name("_valid");
	        validateIf();
	        cxt.reset();
	        if (hasThen && hasElse) {
	            const ifClause = gen.let("ifClause");
	            cxt.setParams({ ifClause });
	            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
	        }
	        else if (hasThen) {
	            gen.if(schValid, validateClause("then"));
	        }
	        else {
	            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
	        }
	        cxt.pass(valid, () => cxt.error(true));
	        function validateIf() {
	            const schCxt = cxt.subschema({
	                keyword: "if",
	                compositeRule: true,
	                createErrors: false,
	                allErrors: false,
	            }, schValid);
	            cxt.mergeEvaluated(schCxt);
	        }
	        function validateClause(keyword, ifClause) {
	            return () => {
	                const schCxt = cxt.subschema({ keyword }, schValid);
	                gen.assign(valid, schValid);
	                cxt.mergeValidEvaluated(schCxt, valid);
	                if (ifClause)
	                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);
	                else
	                    cxt.setParams({ ifClause: keyword });
	            };
	        }
	    },
	};
	function hasSchema(it, keyword) {
	    const schema = it.schema[keyword];
	    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
	}
	_if.default = def;
	
	return _if;
}

var thenElse = {};

var hasRequiredThenElse;

function requireThenElse () {
	if (hasRequiredThenElse) return thenElse;
	hasRequiredThenElse = 1;
	Object.defineProperty(thenElse, "__esModule", { value: true });
	const util_1 = requireUtil();
	const def = {
	    keyword: ["then", "else"],
	    schemaType: ["object", "boolean"],
	    code({ keyword, parentSchema, it }) {
	        if (parentSchema.if === undefined)
	            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
	    },
	};
	thenElse.default = def;
	
	return thenElse;
}

var hasRequiredApplicator;

function requireApplicator () {
	if (hasRequiredApplicator) return applicator;
	hasRequiredApplicator = 1;
	Object.defineProperty(applicator, "__esModule", { value: true });
	const additionalItems_1 = requireAdditionalItems();
	const prefixItems_1 = requirePrefixItems();
	const items_1 = requireItems();
	const items2020_1 = requireItems2020();
	const contains_1 = requireContains();
	const dependencies_1 = requireDependencies();
	const propertyNames_1 = requirePropertyNames();
	const additionalProperties_1 = requireAdditionalProperties();
	const properties_1 = requireProperties();
	const patternProperties_1 = requirePatternProperties();
	const not_1 = requireNot();
	const anyOf_1 = requireAnyOf();
	const oneOf_1 = requireOneOf();
	const allOf_1 = requireAllOf();
	const if_1 = require_if();
	const thenElse_1 = requireThenElse();
	function getApplicator(draft2020 = false) {
	    const applicator = [
	        // any
	        not_1.default,
	        anyOf_1.default,
	        oneOf_1.default,
	        allOf_1.default,
	        if_1.default,
	        thenElse_1.default,
	        // object
	        propertyNames_1.default,
	        additionalProperties_1.default,
	        dependencies_1.default,
	        properties_1.default,
	        patternProperties_1.default,
	    ];
	    // array
	    if (draft2020)
	        applicator.push(prefixItems_1.default, items2020_1.default);
	    else
	        applicator.push(additionalItems_1.default, items_1.default);
	    applicator.push(contains_1.default);
	    return applicator;
	}
	applicator.default = getApplicator;
	
	return applicator;
}

var format$1 = {};

var format = {};

var hasRequiredFormat$1;

function requireFormat$1 () {
	if (hasRequiredFormat$1) return format;
	hasRequiredFormat$1 = 1;
	Object.defineProperty(format, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const error = {
	    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,
	    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,
	};
	const def = {
	    keyword: "format",
	    type: ["number", "string"],
	    schemaType: "string",
	    $data: true,
	    error,
	    code(cxt, ruleType) {
	        const { gen, data, $data, schema, schemaCode, it } = cxt;
	        const { opts, errSchemaPath, schemaEnv, self } = it;
	        if (!opts.validateFormats)
	            return;
	        if ($data)
	            validate$DataFormat();
	        else
	            validateFormat();
	        function validate$DataFormat() {
	            const fmts = gen.scopeValue("formats", {
	                ref: self.formats,
	                code: opts.code.formats,
	            });
	            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);
	            const fType = gen.let("fType");
	            const format = gen.let("format");
	            // TODO simplify
	            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
	            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
	            function unknownFmt() {
	                if (opts.strictSchema === false)
	                    return codegen_1.nil;
	                return (0, codegen_1._) `${schemaCode} && !${format}`;
	            }
	            function invalidFmt() {
	                const callFormat = schemaEnv.$async
	                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`
	                    : (0, codegen_1._) `${format}(${data})`;
	                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
	                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
	            }
	        }
	        function validateFormat() {
	            const formatDef = self.formats[schema];
	            if (!formatDef) {
	                unknownFormat();
	                return;
	            }
	            if (formatDef === true)
	                return;
	            const [fmtType, format, fmtRef] = getFormat(formatDef);
	            if (fmtType === ruleType)
	                cxt.pass(validCondition());
	            function unknownFormat() {
	                if (opts.strictSchema === false) {
	                    self.logger.warn(unknownMsg());
	                    return;
	                }
	                throw new Error(unknownMsg());
	                function unknownMsg() {
	                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
	                }
	            }
	            function getFormat(fmtDef) {
	                const code = fmtDef instanceof RegExp
	                    ? (0, codegen_1.regexpCode)(fmtDef)
	                    : opts.code.formats
	                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`
	                        : undefined;
	                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
	                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
	                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];
	                }
	                return ["string", fmtDef, fmt];
	            }
	            function validCondition() {
	                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
	                    if (!schemaEnv.$async)
	                        throw new Error("async format in sync schema");
	                    return (0, codegen_1._) `await ${fmtRef}(${data})`;
	                }
	                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;
	            }
	        }
	    },
	};
	format.default = def;
	
	return format;
}

var hasRequiredFormat;

function requireFormat () {
	if (hasRequiredFormat) return format$1;
	hasRequiredFormat = 1;
	Object.defineProperty(format$1, "__esModule", { value: true });
	const format_1 = requireFormat$1();
	const format = [format_1.default];
	format$1.default = format;
	
	return format$1;
}

var metadata = {};

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
	metadata.metadataVocabulary = [
	    "title",
	    "description",
	    "default",
	    "deprecated",
	    "readOnly",
	    "writeOnly",
	    "examples",
	];
	metadata.contentVocabulary = [
	    "contentMediaType",
	    "contentEncoding",
	    "contentSchema",
	];
	
	return metadata;
}

var hasRequiredDraft7;

function requireDraft7 () {
	if (hasRequiredDraft7) return draft7;
	hasRequiredDraft7 = 1;
	Object.defineProperty(draft7, "__esModule", { value: true });
	const core_1 = requireCore();
	const validation_1 = requireValidation();
	const applicator_1 = requireApplicator();
	const format_1 = requireFormat();
	const metadata_1 = requireMetadata();
	const draft7Vocabularies = [
	    core_1.default,
	    validation_1.default,
	    (0, applicator_1.default)(),
	    format_1.default,
	    metadata_1.metadataVocabulary,
	    metadata_1.contentVocabulary,
	];
	draft7.default = draft7Vocabularies;
	
	return draft7;
}

var discriminator = {};

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	types.DiscrError = void 0;
	var DiscrError;
	(function (DiscrError) {
	    DiscrError["Tag"] = "tag";
	    DiscrError["Mapping"] = "mapping";
	})(DiscrError || (types.DiscrError = DiscrError = {}));
	
	return types;
}

var hasRequiredDiscriminator;

function requireDiscriminator () {
	if (hasRequiredDiscriminator) return discriminator;
	hasRequiredDiscriminator = 1;
	Object.defineProperty(discriminator, "__esModule", { value: true });
	const codegen_1 = requireCodegen();
	const types_1 = requireTypes();
	const compile_1 = requireCompile();
	const ref_error_1 = requireRef_error();
	const util_1 = requireUtil();
	const error = {
	    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag
	        ? `tag "${tagName}" must be string`
	        : `value of tag "${tagName}" must be in oneOf`,
	    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,
	};
	const def = {
	    keyword: "discriminator",
	    type: "object",
	    schemaType: "object",
	    error,
	    code(cxt) {
	        const { gen, data, schema, parentSchema, it } = cxt;
	        const { oneOf } = parentSchema;
	        if (!it.opts.discriminator) {
	            throw new Error("discriminator: requires discriminator option");
	        }
	        const tagName = schema.propertyName;
	        if (typeof tagName != "string")
	            throw new Error("discriminator: requires propertyName");
	        if (schema.mapping)
	            throw new Error("discriminator: mapping is not supported");
	        if (!oneOf)
	            throw new Error("discriminator: requires oneOf keyword");
	        const valid = gen.let("valid", false);
	        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);
	        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
	        cxt.ok(valid);
	        function validateMapping() {
	            const mapping = getMapping();
	            gen.if(false);
	            for (const tagValue in mapping) {
	                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);
	                gen.assign(valid, applyTagSchema(mapping[tagValue]));
	            }
	            gen.else();
	            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
	            gen.endIf();
	        }
	        function applyTagSchema(schemaProp) {
	            const _valid = gen.name("valid");
	            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
	            cxt.mergeEvaluated(schCxt, codegen_1.Name);
	            return _valid;
	        }
	        function getMapping() {
	            var _a;
	            const oneOfMapping = {};
	            const topRequired = hasRequired(parentSchema);
	            let tagRequired = true;
	            for (let i = 0; i < oneOf.length; i++) {
	                let sch = oneOf[i];
	                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
	                    const ref = sch.$ref;
	                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
	                    if (sch instanceof compile_1.SchemaEnv)
	                        sch = sch.schema;
	                    if (sch === undefined)
	                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
	                }
	                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
	                if (typeof propSch != "object") {
	                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
	                }
	                tagRequired = tagRequired && (topRequired || hasRequired(sch));
	                addMappings(propSch, i);
	            }
	            if (!tagRequired)
	                throw new Error(`discriminator: "${tagName}" must be required`);
	            return oneOfMapping;
	            function hasRequired({ required }) {
	                return Array.isArray(required) && required.includes(tagName);
	            }
	            function addMappings(sch, i) {
	                if (sch.const) {
	                    addMapping(sch.const, i);
	                }
	                else if (sch.enum) {
	                    for (const tagValue of sch.enum) {
	                        addMapping(tagValue, i);
	                    }
	                }
	                else {
	                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
	                }
	            }
	            function addMapping(tagValue, i) {
	                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
	                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);
	                }
	                oneOfMapping[tagValue] = i;
	            }
	        }
	    },
	};
	discriminator.default = def;
	
	return discriminator;
}

var $schema = "http://json-schema.org/draft-07/schema#";
var $id = "http://json-schema.org/draft-07/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$3 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": true
};

var hasRequiredAjv;

function requireAjv () {
	if (hasRequiredAjv) return ajv.exports;
	hasRequiredAjv = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
		const core_1 = requireCore$1();
		const draft7_1 = requireDraft7();
		const discriminator_1 = requireDiscriminator();
		const draft7MetaSchema = require$$3;
		const META_SUPPORT_DATA = ["/properties"];
		const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
		class Ajv extends core_1.default {
		    _addVocabularies() {
		        super._addVocabularies();
		        draft7_1.default.forEach((v) => this.addVocabulary(v));
		        if (this.opts.discriminator)
		            this.addKeyword(discriminator_1.default);
		    }
		    _addDefaultMetaSchema() {
		        super._addDefaultMetaSchema();
		        if (!this.opts.meta)
		            return;
		        const metaSchema = this.opts.$data
		            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)
		            : draft7MetaSchema;
		        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
		        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
		    }
		    defaultMeta() {
		        return (this.opts.defaultMeta =
		            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));
		    }
		}
		exports.Ajv = Ajv;
		module.exports = exports = Ajv;
		module.exports.Ajv = Ajv;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = Ajv;
		var validate_1 = requireValidate();
		Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });
		var codegen_1 = requireCodegen();
		Object.defineProperty(exports, "_", { enumerable: true, get: function () { return codegen_1._; } });
		Object.defineProperty(exports, "str", { enumerable: true, get: function () { return codegen_1.str; } });
		Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return codegen_1.stringify; } });
		Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return codegen_1.nil; } });
		Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return codegen_1.Name; } });
		Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function () { return codegen_1.CodeGen; } });
		var validation_error_1 = requireValidation_error();
		Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return validation_error_1.default; } });
		var ref_error_1 = requireRef_error();
		Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function () { return ref_error_1.default; } });
		
	} (ajv, ajv.exports));
	return ajv.exports;
}

var hasRequiredLimit;

function requireLimit () {
	if (hasRequiredLimit) return limit;
	hasRequiredLimit = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.formatLimitDefinition = void 0;
		const ajv_1 = requireAjv();
		const codegen_1 = requireCodegen();
		const ops = codegen_1.operators;
		const KWDs = {
		    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
		    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
		    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
		    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
		};
		const error = {
		    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `should be ${KWDs[keyword].okStr} ${schemaCode}`,
		    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
		};
		exports.formatLimitDefinition = {
		    keyword: Object.keys(KWDs),
		    type: "string",
		    schemaType: "string",
		    $data: true,
		    error,
		    code(cxt) {
		        const { gen, data, schemaCode, keyword, it } = cxt;
		        const { opts, self } = it;
		        if (!opts.validateFormats)
		            return;
		        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
		        if (fCxt.$data)
		            validate$DataFormat();
		        else
		            validateFormat();
		        function validate$DataFormat() {
		            const fmts = gen.scopeValue("formats", {
		                ref: self.formats,
		                code: opts.code.formats,
		            });
		            const fmt = gen.const("fmt", (0, codegen_1._) `${fmts}[${fCxt.schemaCode}]`);
		            cxt.fail$data((0, codegen_1.or)((0, codegen_1._) `typeof ${fmt} != "object"`, (0, codegen_1._) `${fmt} instanceof RegExp`, (0, codegen_1._) `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
		        }
		        function validateFormat() {
		            const format = fCxt.schema;
		            const fmtDef = self.formats[format];
		            if (!fmtDef || fmtDef === true)
		                return;
		            if (typeof fmtDef != "object" ||
		                fmtDef instanceof RegExp ||
		                typeof fmtDef.compare != "function") {
		                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
		            }
		            const fmt = gen.scopeValue("formats", {
		                key: format,
		                ref: fmtDef,
		                code: opts.code.formats ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined,
		            });
		            cxt.fail$data(compareCode(fmt));
		        }
		        function compareCode(fmt) {
		            return (0, codegen_1._) `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
		        }
		    },
		    dependencies: ["format"],
		};
		const formatLimitPlugin = (ajv) => {
		    ajv.addKeyword(exports.formatLimitDefinition);
		    return ajv;
		};
		exports.default = formatLimitPlugin;
		
	} (limit));
	return limit;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist.exports;
	hasRequiredDist = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const formats_1 = requireFormats();
		const limit_1 = requireLimit();
		const codegen_1 = requireCodegen();
		const fullName = new codegen_1.Name("fullFormats");
		const fastName = new codegen_1.Name("fastFormats");
		const formatsPlugin = (ajv, opts = { keywords: true }) => {
		    if (Array.isArray(opts)) {
		        addFormats(ajv, opts, formats_1.fullFormats, fullName);
		        return ajv;
		    }
		    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
		    const list = opts.formats || formats_1.formatNames;
		    addFormats(ajv, list, formats, exportName);
		    if (opts.keywords)
		        (0, limit_1.default)(ajv);
		    return ajv;
		};
		formatsPlugin.get = (name, mode = "full") => {
		    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
		    const f = formats[name];
		    if (!f)
		        throw new Error(`Unknown format "${name}"`);
		    return f;
		};
		function addFormats(ajv, list, fs, exportName) {
		    var _a;
		    var _b;
		    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = (0, codegen_1._) `require("ajv-formats/dist/formats").${exportName}`);
		    for (const f of list)
		        ajv.addFormat(f, fs[f]);
		}
		module.exports = exports = formatsPlugin;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.default = formatsPlugin;
		
	} (dist, dist.exports));
	return dist.exports;
}

var distExports = requireDist();
var index = /*@__PURE__*/getDefaultExportFromCjs(distExports);

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: index
});

export { getSeasonsWarningState, init, registerSettings, resetSeasonsWarningState, setSeasonsWarningState, setup, setupAPI };
//# sourceMappingURL=module.js.map
